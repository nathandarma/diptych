{"ast":null,"code":"import $ckyCP$intlStringsmodulejs from \"./intlStrings.mjs\";\nimport { useEffectEvent as $ckyCP$useEffectEvent, useLayoutEffect as $ckyCP$useLayoutEffect, focusWithoutScrolling as $ckyCP$focusWithoutScrolling, mergeProps as $ckyCP$mergeProps } from \"@react-aria/utils\";\nimport { useHover as $ckyCP$useHover, getInteractionModality as $ckyCP$getInteractionModality, useFocusWithin as $ckyCP$useFocusWithin } from \"@react-aria/interactions\";\nimport { useRef as $ckyCP$useRef, useEffect as $ckyCP$useEffect } from \"react\";\nimport { useLandmark as $ckyCP$useLandmark } from \"@react-aria/landmark\";\nimport { useLocalizedStringFormatter as $ckyCP$useLocalizedStringFormatter } from \"@react-aria/i18n\";\nfunction $parcel$interopDefault(a) {\n  return a && a.__esModule ? a.default : a;\n}\n/*\n * Copyright 2025 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nfunction $6cc546b19ee7130a$export$b8cbbb20a51697de(props, state, ref) {\n  let stringFormatter = (0, $ckyCP$useLocalizedStringFormatter)((0, $parcel$interopDefault($ckyCP$intlStringsmodulejs)), '@react-aria/toast');\n  let {\n    landmarkProps: landmarkProps\n  } = (0, $ckyCP$useLandmark)({\n    role: 'region',\n    'aria-label': props['aria-label'] || stringFormatter.format('notifications', {\n      count: state.visibleToasts.length\n    })\n  }, ref);\n  let isHovered = (0, $ckyCP$useRef)(false);\n  let isFocused = (0, $ckyCP$useRef)(false);\n  let updateTimers = (0, $ckyCP$useEffectEvent)(() => {\n    if (isHovered.current || isFocused.current) state.pauseAll();else state.resumeAll();\n  });\n  let {\n    hoverProps: hoverProps\n  } = (0, $ckyCP$useHover)({\n    onHoverStart: () => {\n      isHovered.current = true;\n      updateTimers();\n    },\n    onHoverEnd: () => {\n      isHovered.current = false;\n      updateTimers();\n    }\n  });\n  // Manage focus within the toast region.\n  // If a focused containing toast is removed, move focus to the next toast, or the previous toast if there is no next toast.\n  let toasts = (0, $ckyCP$useRef)([]);\n  let prevVisibleToasts = (0, $ckyCP$useRef)(state.visibleToasts);\n  let focusedToast = (0, $ckyCP$useRef)(null);\n  (0, $ckyCP$useLayoutEffect)(() => {\n    // If no toast has focus, then don't do anything.\n    if (focusedToast.current === -1 || state.visibleToasts.length === 0 || !ref.current) {\n      toasts.current = [];\n      prevVisibleToasts.current = state.visibleToasts;\n      return;\n    }\n    toasts.current = [...ref.current.querySelectorAll('[role=\"alertdialog\"]')];\n    // If the visible toasts haven't changed, we don't need to do anything.\n    if (prevVisibleToasts.current.length === state.visibleToasts.length && state.visibleToasts.every((t, i) => t.key === prevVisibleToasts.current[i].key)) {\n      prevVisibleToasts.current = state.visibleToasts;\n      return;\n    }\n    // Get a list of all toasts by index and add info if they are removed.\n    let allToasts = prevVisibleToasts.current.map((t, i) => ({\n      ...t,\n      i: i,\n      isRemoved: !state.visibleToasts.some(t2 => t.key === t2.key)\n    }));\n    let removedFocusedToastIndex = allToasts.findIndex(t => t.i === focusedToast.current && t.isRemoved);\n    // If the focused toast was removed, focus the next or previous toast.\n    if (removedFocusedToastIndex > -1) {\n      var _lastFocused_current;\n      // In pointer modality, move focus out of the toast region.\n      // Otherwise auto-dismiss timers will appear \"stuck\".\n      if ((0, $ckyCP$getInteractionModality)() === 'pointer' && ((_lastFocused_current = lastFocused.current) === null || _lastFocused_current === void 0 ? void 0 : _lastFocused_current.isConnected)) (0, $ckyCP$focusWithoutScrolling)(lastFocused.current);else {\n        let i = 0;\n        let nextToast;\n        let prevToast;\n        while (i <= removedFocusedToastIndex) {\n          if (!allToasts[i].isRemoved) prevToast = Math.max(0, i - 1);\n          i++;\n        }\n        while (i < allToasts.length) {\n          if (!allToasts[i].isRemoved) {\n            nextToast = i - 1;\n            break;\n          }\n          i++;\n        }\n        // in the case where it's one toast at a time, both will be undefined, but we know the index must be 0\n        if (prevToast === undefined && nextToast === undefined) prevToast = 0;\n        // prioritize going to newer toasts\n        if (prevToast >= 0 && prevToast < toasts.current.length) (0, $ckyCP$focusWithoutScrolling)(toasts.current[prevToast]);else if (nextToast >= 0 && nextToast < toasts.current.length) (0, $ckyCP$focusWithoutScrolling)(toasts.current[nextToast]);\n      }\n    }\n    prevVisibleToasts.current = state.visibleToasts;\n  }, [state.visibleToasts, ref, updateTimers]);\n  let lastFocused = (0, $ckyCP$useRef)(null);\n  let {\n    focusWithinProps: focusWithinProps\n  } = (0, $ckyCP$useFocusWithin)({\n    onFocusWithin: e => {\n      isFocused.current = true;\n      lastFocused.current = e.relatedTarget;\n      updateTimers();\n    },\n    onBlurWithin: () => {\n      isFocused.current = false;\n      lastFocused.current = null;\n      updateTimers();\n    }\n  });\n  // When the number of visible toasts becomes 0 or the region unmounts,\n  // restore focus to the last element that had focus before the user moved focus\n  // into the region. FocusScope restore focus doesn't update whenever the focus\n  // moves in, it only happens once, so we correct it.\n  // Because we're in a hook, we can't control if the user unmounts or not.\n  (0, $ckyCP$useEffect)(() => {\n    var _lastFocused_current;\n    if (state.visibleToasts.length === 0 && ((_lastFocused_current = lastFocused.current) === null || _lastFocused_current === void 0 ? void 0 : _lastFocused_current.isConnected)) {\n      if ((0, $ckyCP$getInteractionModality)() === 'pointer') (0, $ckyCP$focusWithoutScrolling)(lastFocused.current);else lastFocused.current.focus();\n      lastFocused.current = null;\n    }\n  }, [ref, state.visibleToasts.length]);\n  (0, $ckyCP$useEffect)(() => {\n    return () => {\n      var _lastFocused_current;\n      if ((_lastFocused_current = lastFocused.current) === null || _lastFocused_current === void 0 ? void 0 : _lastFocused_current.isConnected) {\n        if ((0, $ckyCP$getInteractionModality)() === 'pointer') (0, $ckyCP$focusWithoutScrolling)(lastFocused.current);else lastFocused.current.focus();\n        lastFocused.current = null;\n      }\n    };\n  }, [ref]);\n  return {\n    regionProps: (0, $ckyCP$mergeProps)(landmarkProps, hoverProps, focusWithinProps, {\n      tabIndex: -1,\n      // Mark the toast region as a \"top layer\", so that it:\n      //   - is not aria-hidden when opening an overlay\n      //   - allows focus even outside a containing focus scope\n      //   - doesnâ€™t dismiss overlays when clicking on it, even though it is outside\n      // @ts-ignore\n      'data-react-aria-top-layer': true,\n      // listen to focus events separate from focuswithin because that will only fire once\n      // and we need to follow all focus changes\n      onFocus: e => {\n        let target = e.target.closest('[role=\"alertdialog\"]');\n        focusedToast.current = toasts.current.findIndex(t => t === target);\n      },\n      onBlur: () => {\n        focusedToast.current = -1;\n      }\n    })\n  };\n}\nexport { $6cc546b19ee7130a$export$b8cbbb20a51697de as useToastRegion };","map":{"version":3,"names":["$6cc546b19ee7130a$export$b8cbbb20a51697de","props","state","ref","stringFormatter","$ckyCP$useLocalizedStringFormatter","$parcel$interopDefault","$ckyCP$intlStringsmodulejs","landmarkProps","$ckyCP$useLandmark","role","format","count","visibleToasts","length","isHovered","$ckyCP$useRef","isFocused","updateTimers","$ckyCP$useEffectEvent","current","pauseAll","resumeAll","hoverProps","$ckyCP$useHover","onHoverStart","onHoverEnd","toasts","prevVisibleToasts","focusedToast","$ckyCP$useLayoutEffect","querySelectorAll","every","t","i","key","allToasts","map","isRemoved","some","t2","removedFocusedToastIndex","findIndex","_lastFocused_current","$ckyCP$getInteractionModality","lastFocused","isConnected","$ckyCP$focusWithoutScrolling","nextToast","prevToast","Math","max","undefined","focusWithinProps","$ckyCP$useFocusWithin","onFocusWithin","e","relatedTarget","onBlurWithin","$ckyCP$useEffect","focus","regionProps","$ckyCP$mergeProps","tabIndex","onFocus","target","closest","onBlur"],"sources":["/Users/nathandarma/Documents/App Testing/Diptych/diptych/node_modules/@react-aria/toast/dist/packages/@react-aria/toast/src/useToastRegion.ts"],"sourcesContent":["/*\n * Copyright 2025 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {AriaLabelingProps, DOMAttributes, FocusableElement, RefObject} from '@react-types/shared';\nimport {focusWithoutScrolling, mergeProps, useEffectEvent, useLayoutEffect} from '@react-aria/utils';\nimport {getInteractionModality, useFocusWithin, useHover} from '@react-aria/interactions';\n// @ts-ignore\nimport intlMessages from '../intl/*.json';\nimport {ToastState} from '@react-stately/toast';\nimport {useEffect, useRef} from 'react';\nimport {useLandmark} from '@react-aria/landmark';\nimport {useLocalizedStringFormatter} from '@react-aria/i18n';\n\nexport interface AriaToastRegionProps extends AriaLabelingProps {\n  /**\n   * An accessibility label for the toast region.\n   * @default \"Notifications\"\n   */\n  'aria-label'?: string\n}\n\nexport interface ToastRegionAria {\n  /** Props for the landmark region element. */\n  regionProps: DOMAttributes\n}\n\n/**\n * Provides the behavior and accessibility implementation for a toast region containing one or more toasts.\n * Toasts display brief, temporary notifications of actions, errors, or other events in an application.\n */\nexport function useToastRegion<T>(props: AriaToastRegionProps, state: ToastState<T>, ref: RefObject<HTMLElement | null>): ToastRegionAria {\n  let stringFormatter = useLocalizedStringFormatter(intlMessages, '@react-aria/toast');\n  let {landmarkProps} = useLandmark({\n    role: 'region',\n    'aria-label': props['aria-label'] || stringFormatter.format('notifications', {count: state.visibleToasts.length})\n  }, ref);\n\n  let isHovered = useRef(false);\n  let isFocused = useRef(false);\n  let updateTimers = useEffectEvent(() => {\n    if (isHovered.current || isFocused.current) {\n      state.pauseAll();\n    } else {\n      state.resumeAll();\n    }\n  });\n\n  let {hoverProps} = useHover({\n    onHoverStart: () => {\n      isHovered.current = true;\n      updateTimers();\n    },\n    onHoverEnd: () => {\n      isHovered.current = false;\n      updateTimers();\n    }\n  });\n\n  // Manage focus within the toast region.\n  // If a focused containing toast is removed, move focus to the next toast, or the previous toast if there is no next toast.\n  let toasts = useRef<FocusableElement[]>([]);\n  let prevVisibleToasts = useRef(state.visibleToasts);\n  let focusedToast = useRef<number | null>(null);\n  useLayoutEffect(() => {\n    // If no toast has focus, then don't do anything.\n    if (focusedToast.current === -1 || state.visibleToasts.length === 0 || !ref.current) {\n      toasts.current = [];\n      prevVisibleToasts.current = state.visibleToasts;\n      return;\n    }\n    toasts.current = [...ref.current.querySelectorAll('[role=\"alertdialog\"]')] as FocusableElement[];\n    // If the visible toasts haven't changed, we don't need to do anything.\n    if (prevVisibleToasts.current.length === state.visibleToasts.length\n      && state.visibleToasts.every((t, i) => t.key === prevVisibleToasts.current[i].key)) {\n      prevVisibleToasts.current = state.visibleToasts;\n      return;\n    }\n    // Get a list of all toasts by index and add info if they are removed.\n    let allToasts = prevVisibleToasts.current\n      .map((t, i) => ({\n        ...t,\n        i,\n        isRemoved: !state.visibleToasts.some(t2 => t.key === t2.key)\n      }));\n\n    let removedFocusedToastIndex = allToasts.findIndex(t => t.i === focusedToast.current && t.isRemoved);\n\n    // If the focused toast was removed, focus the next or previous toast.\n    if (removedFocusedToastIndex > -1) {\n      // In pointer modality, move focus out of the toast region.\n      // Otherwise auto-dismiss timers will appear \"stuck\".\n      if (getInteractionModality() === 'pointer' && lastFocused.current?.isConnected) {\n        focusWithoutScrolling(lastFocused.current);\n      } else {\n        let i = 0;\n        let nextToast;\n        let prevToast;\n        while (i <= removedFocusedToastIndex) {\n          if (!allToasts[i].isRemoved) {\n            prevToast = Math.max(0, i - 1);\n          }\n          i++;\n        }\n        while (i < allToasts.length) {\n          if (!allToasts[i].isRemoved) {\n            nextToast = i - 1;\n            break;\n          }\n          i++;\n        }\n\n        // in the case where it's one toast at a time, both will be undefined, but we know the index must be 0\n        if (prevToast === undefined && nextToast === undefined) {\n          prevToast = 0;\n        }\n\n        // prioritize going to newer toasts\n        if (prevToast >= 0 && prevToast < toasts.current.length) {\n          focusWithoutScrolling(toasts.current[prevToast]);\n        } else if (nextToast >= 0 && nextToast < toasts.current.length) {\n          focusWithoutScrolling(toasts.current[nextToast]);\n        }\n      }\n    }\n\n    prevVisibleToasts.current = state.visibleToasts;\n  }, [state.visibleToasts, ref, updateTimers]);\n\n  let lastFocused = useRef<FocusableElement | null>(null);\n  let {focusWithinProps} = useFocusWithin({\n    onFocusWithin: (e) => {\n      isFocused.current = true;\n      lastFocused.current = e.relatedTarget as FocusableElement;\n      updateTimers();\n    },\n    onBlurWithin: () => {\n      isFocused.current = false;\n      lastFocused.current = null;\n      updateTimers();\n    }\n  });\n\n  // When the number of visible toasts becomes 0 or the region unmounts,\n  // restore focus to the last element that had focus before the user moved focus\n  // into the region. FocusScope restore focus doesn't update whenever the focus\n  // moves in, it only happens once, so we correct it.\n  // Because we're in a hook, we can't control if the user unmounts or not.\n  useEffect(() => {\n    if (state.visibleToasts.length === 0 && lastFocused.current?.isConnected) {\n      if (getInteractionModality() === 'pointer') {\n        focusWithoutScrolling(lastFocused.current);\n      } else {\n        lastFocused.current.focus();\n      }\n      lastFocused.current = null;\n    }\n  }, [ref, state.visibleToasts.length]);\n\n  useEffect(() => {\n    return () => {\n      if (lastFocused.current?.isConnected) {\n        if (getInteractionModality() === 'pointer') {\n          focusWithoutScrolling(lastFocused.current);\n        } else {\n          lastFocused.current.focus();\n        }\n        lastFocused.current = null;\n      }\n    };\n  }, [ref]);\n\n  return {\n    regionProps: mergeProps(landmarkProps, hoverProps, focusWithinProps, {\n      tabIndex: -1,\n      // Mark the toast region as a \"top layer\", so that it:\n      //   - is not aria-hidden when opening an overlay\n      //   - allows focus even outside a containing focus scope\n      //   - doesnâ€™t dismiss overlays when clicking on it, even though it is outside\n      // @ts-ignore\n      'data-react-aria-top-layer': true,\n      // listen to focus events separate from focuswithin because that will only fire once\n      // and we need to follow all focus changes\n      onFocus: (e) => {\n        let target = e.target.closest('[role=\"alertdialog\"]');\n        focusedToast.current = toasts.current.findIndex(t => t === target);\n      },\n      onBlur: () => {\n        focusedToast.current = -1;\n      }\n    })\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}