{"ast":null,"code":"import { getFirstItem as $iLnZt$getFirstItem, getLastItem as $iLnZt$getLastItem } from \"@react-stately/collections\";\nimport { GridCollection as $iLnZt$GridCollection } from \"@react-stately/grid\";\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nconst $788781baa30117fa$var$ROW_HEADER_COLUMN_KEY = 'row-header-column-' + Math.random().toString(36).slice(2);\nlet $788781baa30117fa$var$ROW_HEADER_COLUMN_KEY_DRAG = 'row-header-column-' + Math.random().toString(36).slice(2);\nwhile ($788781baa30117fa$var$ROW_HEADER_COLUMN_KEY === $788781baa30117fa$var$ROW_HEADER_COLUMN_KEY_DRAG) $788781baa30117fa$var$ROW_HEADER_COLUMN_KEY_DRAG = 'row-header-column-' + Math.random().toString(36).slice(2);\nfunction $788781baa30117fa$export$7c127db850d4e81e(keyMap, columnNodes) {\n  if (columnNodes.length === 0) return [];\n  let columns = [];\n  let seen = new Map();\n  for (let column of columnNodes) {\n    let parentKey = column.parentKey;\n    let col = [column];\n    while (parentKey) {\n      let parent = keyMap.get(parentKey);\n      if (!parent) break;\n      // If we've already seen this parent, than it is shared\n      // with a previous column. If the current column is taller\n      // than the previous column, than we need to shift the parent\n      // in the previous column so it's level with the current column.\n      if (seen.has(parent)) {\n        var _parent;\n        var _colSpan;\n        (_colSpan = (_parent = parent).colSpan) !== null && _colSpan !== void 0 ? _colSpan : _parent.colSpan = 0;\n        parent.colSpan++;\n        parent.colspan = parent.colSpan;\n        let {\n          column: column,\n          index: index\n        } = seen.get(parent);\n        if (index > col.length) break;\n        for (let i = index; i < col.length; i++) column.splice(i, 0, null);\n        // Adjust shifted indices\n        for (let i = col.length; i < column.length; i++)\n        // eslint-disable-next-line max-depth\n        if (column[i] && seen.has(column[i])) seen.get(column[i]).index = i;\n      } else {\n        parent.colSpan = 1;\n        parent.colspan = 1;\n        col.push(parent);\n        seen.set(parent, {\n          column: col,\n          index: col.length - 1\n        });\n      }\n      parentKey = parent.parentKey;\n    }\n    columns.push(col);\n    column.index = columns.length - 1;\n  }\n  let maxLength = Math.max(...columns.map(c => c.length));\n  let headerRows = Array(maxLength).fill(0).map(() => []);\n  // Convert columns into rows.\n  let colIndex = 0;\n  for (let column of columns) {\n    let i = maxLength - 1;\n    for (let item of column) {\n      if (item) {\n        // Fill the space up until the current column with a placeholder\n        let row = headerRows[i];\n        let rowLength = row.reduce((p, c) => {\n          var _c_colSpan;\n          return p + ((_c_colSpan = c.colSpan) !== null && _c_colSpan !== void 0 ? _c_colSpan : 1);\n        }, 0);\n        if (rowLength < colIndex) {\n          let placeholder = {\n            type: 'placeholder',\n            key: 'placeholder-' + item.key,\n            colspan: colIndex - rowLength,\n            colSpan: colIndex - rowLength,\n            index: rowLength,\n            value: null,\n            rendered: null,\n            level: i,\n            hasChildNodes: false,\n            childNodes: [],\n            textValue: ''\n          };\n          // eslint-disable-next-line max-depth\n          if (row.length > 0) {\n            row[row.length - 1].nextKey = placeholder.key;\n            placeholder.prevKey = row[row.length - 1].key;\n          }\n          row.push(placeholder);\n        }\n        if (row.length > 0) {\n          row[row.length - 1].nextKey = item.key;\n          item.prevKey = row[row.length - 1].key;\n        }\n        item.level = i;\n        item.colIndex = colIndex;\n        row.push(item);\n      }\n      i--;\n    }\n    colIndex++;\n  }\n  // Add placeholders at the end of each row that is shorter than the maximum\n  let i = 0;\n  for (let row of headerRows) {\n    let rowLength = row.reduce((p, c) => {\n      var _c_colSpan;\n      return p + ((_c_colSpan = c.colSpan) !== null && _c_colSpan !== void 0 ? _c_colSpan : 1);\n    }, 0);\n    if (rowLength < columnNodes.length) {\n      let placeholder = {\n        type: 'placeholder',\n        key: 'placeholder-' + row[row.length - 1].key,\n        colSpan: columnNodes.length - rowLength,\n        colspan: columnNodes.length - rowLength,\n        index: rowLength,\n        value: null,\n        rendered: null,\n        level: i,\n        hasChildNodes: false,\n        childNodes: [],\n        textValue: '',\n        prevKey: row[row.length - 1].key\n      };\n      row.push(placeholder);\n    }\n    i++;\n  }\n  return headerRows.map((childNodes, index) => {\n    let row = {\n      type: 'headerrow',\n      key: 'headerrow-' + index,\n      index: index,\n      value: null,\n      rendered: null,\n      level: 0,\n      hasChildNodes: true,\n      childNodes: childNodes,\n      textValue: ''\n    };\n    return row;\n  });\n}\nclass $788781baa30117fa$export$596e1b2e2cf93690 extends (0, $iLnZt$GridCollection) {\n  *[Symbol.iterator]() {\n    yield* this.body.childNodes;\n  }\n  get size() {\n    return this._size;\n  }\n  getKeys() {\n    return this.keyMap.keys();\n  }\n  getKeyBefore(key) {\n    let node = this.keyMap.get(key);\n    var _node_prevKey;\n    return (_node_prevKey = node === null || node === void 0 ? void 0 : node.prevKey) !== null && _node_prevKey !== void 0 ? _node_prevKey : null;\n  }\n  getKeyAfter(key) {\n    let node = this.keyMap.get(key);\n    var _node_nextKey;\n    return (_node_nextKey = node === null || node === void 0 ? void 0 : node.nextKey) !== null && _node_nextKey !== void 0 ? _node_nextKey : null;\n  }\n  getFirstKey() {\n    var _getFirstItem;\n    var _getFirstItem_key;\n    return (_getFirstItem_key = (_getFirstItem = (0, $iLnZt$getFirstItem)(this.body.childNodes)) === null || _getFirstItem === void 0 ? void 0 : _getFirstItem.key) !== null && _getFirstItem_key !== void 0 ? _getFirstItem_key : null;\n  }\n  getLastKey() {\n    var _getLastItem;\n    var _getLastItem_key;\n    return (_getLastItem_key = (_getLastItem = (0, $iLnZt$getLastItem)(this.body.childNodes)) === null || _getLastItem === void 0 ? void 0 : _getLastItem.key) !== null && _getLastItem_key !== void 0 ? _getLastItem_key : null;\n  }\n  getItem(key) {\n    var _this_keyMap_get;\n    return (_this_keyMap_get = this.keyMap.get(key)) !== null && _this_keyMap_get !== void 0 ? _this_keyMap_get : null;\n  }\n  at(idx) {\n    const keys = [...this.getKeys()];\n    return this.getItem(keys[idx]);\n  }\n  getChildren(key) {\n    if (key === this.body.key) return this.body.childNodes;\n    return super.getChildren(key);\n  }\n  getTextValue(key) {\n    let row = this.getItem(key);\n    if (!row) return '';\n    // If the row has a textValue, use that.\n    if (row.textValue) return row.textValue;\n    // Otherwise combine the text of each of the row header columns.\n    let rowHeaderColumnKeys = this.rowHeaderColumnKeys;\n    if (rowHeaderColumnKeys) {\n      let text = [];\n      for (let cell of row.childNodes) {\n        let column = this.columns[cell.index];\n        if (rowHeaderColumnKeys.has(column.key) && cell.textValue) text.push(cell.textValue);\n        if (text.length === rowHeaderColumnKeys.size) break;\n      }\n      return text.join(' ');\n    }\n    return '';\n  }\n  constructor(nodes, prev, opts) {\n    let rowHeaderColumnKeys = new Set();\n    let body = null;\n    let columns = [];\n    // Add cell for selection checkboxes if needed.\n    if (opts === null || opts === void 0 ? void 0 : opts.showSelectionCheckboxes) {\n      let rowHeaderColumn = {\n        type: 'column',\n        key: $788781baa30117fa$var$ROW_HEADER_COLUMN_KEY,\n        value: null,\n        textValue: '',\n        level: 0,\n        index: (opts === null || opts === void 0 ? void 0 : opts.showDragButtons) ? 1 : 0,\n        hasChildNodes: false,\n        rendered: null,\n        childNodes: [],\n        props: {\n          isSelectionCell: true\n        }\n      };\n      columns.unshift(rowHeaderColumn);\n    }\n    // Add cell for drag buttons if needed.\n    if (opts === null || opts === void 0 ? void 0 : opts.showDragButtons) {\n      let rowHeaderColumn = {\n        type: 'column',\n        key: $788781baa30117fa$var$ROW_HEADER_COLUMN_KEY_DRAG,\n        value: null,\n        textValue: '',\n        level: 0,\n        index: 0,\n        hasChildNodes: false,\n        rendered: null,\n        childNodes: [],\n        props: {\n          isDragButtonCell: true\n        }\n      };\n      columns.unshift(rowHeaderColumn);\n    }\n    let rows = [];\n    let columnKeyMap = new Map();\n    let visit = node => {\n      switch (node.type) {\n        case 'body':\n          body = node;\n          break;\n        case 'column':\n          columnKeyMap.set(node.key, node);\n          if (!node.hasChildNodes) {\n            columns.push(node);\n            if (node.props.isRowHeader) rowHeaderColumnKeys.add(node.key);\n          }\n          break;\n        case 'item':\n          rows.push(node);\n          return;\n        // do not go into childNodes\n      }\n      for (let child of node.childNodes) visit(child);\n    };\n    for (let node of nodes) visit(node);\n    let headerRows = $788781baa30117fa$export$7c127db850d4e81e(columnKeyMap, columns);\n    headerRows.forEach((row, i) => rows.splice(i, 0, row));\n    super({\n      columnCount: columns.length,\n      items: rows,\n      visitNode: node => {\n        node.column = columns[node.index];\n        return node;\n      }\n    }), this._size = 0;\n    this.columns = columns;\n    this.rowHeaderColumnKeys = rowHeaderColumnKeys;\n    this.body = body;\n    this.headerRows = headerRows;\n    this._size = [...body.childNodes].length;\n    // Default row header column to the first one.\n    if (this.rowHeaderColumnKeys.size === 0) {\n      let col = this.columns.find(column => {\n        var _column_props, _column_props1;\n        return !((_column_props = column.props) === null || _column_props === void 0 ? void 0 : _column_props.isDragButtonCell) && !((_column_props1 = column.props) === null || _column_props1 === void 0 ? void 0 : _column_props1.isSelectionCell);\n      });\n      if (col) this.rowHeaderColumnKeys.add(col.key);\n    }\n  }\n}\nexport { $788781baa30117fa$export$7c127db850d4e81e as buildHeaderRows, $788781baa30117fa$export$596e1b2e2cf93690 as TableCollection };","map":{"version":3,"names":["$788781baa30117fa$var$ROW_HEADER_COLUMN_KEY","Math","random","toString","slice","$788781baa30117fa$var$ROW_HEADER_COLUMN_KEY_DRAG","$788781baa30117fa$export$7c127db850d4e81e","keyMap","columnNodes","length","columns","seen","Map","column","parentKey","col","parent","get","has","_parent","_colSpan","colSpan","colspan","index","i","splice","push","set","maxLength","max","map","c","headerRows","Array","fill","colIndex","item","row","rowLength","reduce","p","_c_colSpan","placeholder","type","key","value","rendered","level","hasChildNodes","childNodes","textValue","nextKey","prevKey","$788781baa30117fa$export$596e1b2e2cf93690","$iLnZt$GridCollection","Symbol","iterator","body","size","_size","getKeys","keys","getKeyBefore","node","_node_prevKey","getKeyAfter","_node_nextKey","getFirstKey","_getFirstItem","_getFirstItem_key","$iLnZt$getFirstItem","getLastKey","_getLastItem","_getLastItem_key","$iLnZt$getLastItem","getItem","_this_keyMap_get","at","idx","getChildren","getTextValue","rowHeaderColumnKeys","text","cell","join","constructor","nodes","prev","opts","Set","showSelectionCheckboxes","rowHeaderColumn","showDragButtons","props","isSelectionCell","unshift","isDragButtonCell","rows","columnKeyMap","visit","isRowHeader","add","child","forEach","columnCount","items","visitNode","find","_column_props","_column_props1"],"sources":["/Users/nathandarma/Documents/App Testing/Diptych/diptych/node_modules/@react-stately/table/dist/packages/@react-stately/table/src/TableCollection.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {getFirstItem, getLastItem} from '@react-stately/collections';\nimport {GridCollection} from '@react-stately/grid';\nimport {GridNode} from '@react-types/grid';\nimport {TableCollection as ITableCollection} from '@react-types/table';\nimport {Key} from '@react-types/shared';\n\ninterface GridCollectionOptions {\n  showSelectionCheckboxes?: boolean,\n  showDragButtons?: boolean\n}\n\nconst ROW_HEADER_COLUMN_KEY = 'row-header-column-' + Math.random().toString(36).slice(2);\nlet ROW_HEADER_COLUMN_KEY_DRAG = 'row-header-column-' + Math.random().toString(36).slice(2);\nwhile (ROW_HEADER_COLUMN_KEY === ROW_HEADER_COLUMN_KEY_DRAG) {\n  ROW_HEADER_COLUMN_KEY_DRAG = 'row-header-column-' + Math.random().toString(36).slice(2);\n}\n\n/** @private */\nexport function buildHeaderRows<T>(keyMap: Map<Key, GridNode<T>>, columnNodes: GridNode<T>[]): GridNode<T>[] {\n  if (columnNodes.length === 0) {\n    return [];\n  }\n\n  let columns: GridNode<T>[][] = [];\n  let seen = new Map();\n  for (let column of columnNodes) {\n    let parentKey = column.parentKey;\n    let col = [column];\n\n    while (parentKey) {\n      let parent: GridNode<T> | undefined = keyMap.get(parentKey);\n      if (!parent) {\n        break;\n      }\n\n      // If we've already seen this parent, than it is shared\n      // with a previous column. If the current column is taller\n      // than the previous column, than we need to shift the parent\n      // in the previous column so it's level with the current column.\n      if (seen.has(parent)) {\n        parent.colSpan ??= 0;\n        parent.colSpan++;\n        parent.colspan = parent.colSpan;\n\n        let {column, index} = seen.get(parent);\n        if (index > col.length) {\n          break;\n        }\n\n        for (let i = index; i < col.length; i++) {\n          column.splice(i, 0, null);\n        }\n\n        // Adjust shifted indices\n        for (let i = col.length; i < column.length; i++) {\n          // eslint-disable-next-line max-depth\n          if (column[i] && seen.has(column[i])) {\n            seen.get(column[i]).index = i;\n          }\n        }\n      } else {\n        parent.colSpan = 1;\n        parent.colspan = 1;\n        col.push(parent);\n        seen.set(parent, {column: col, index: col.length - 1});\n      }\n\n      parentKey = parent.parentKey;\n    }\n\n    columns.push(col);\n    column.index = columns.length - 1;\n  }\n\n  let maxLength = Math.max(...columns.map(c => c.length));\n  let headerRows: GridNode<T>[][] = Array(maxLength).fill(0).map(() => []);\n\n  // Convert columns into rows.\n  let colIndex = 0;\n  for (let column of columns) {\n    let i = maxLength - 1;\n    for (let item of column) {\n      if (item) {\n        // Fill the space up until the current column with a placeholder\n        let row = headerRows[i];\n        let rowLength = row.reduce((p, c) => p + (c.colSpan ?? 1), 0);\n        if (rowLength < colIndex) {\n          let placeholder: GridNode<T> = {\n            type: 'placeholder',\n            key: 'placeholder-' + item.key,\n            colspan: colIndex - rowLength,\n            colSpan: colIndex - rowLength,\n            index: rowLength,\n            value: null,\n            rendered: null,\n            level: i,\n            hasChildNodes: false,\n            childNodes: [],\n            textValue: ''\n          };\n\n          // eslint-disable-next-line max-depth\n          if (row.length > 0) {\n            row[row.length - 1].nextKey = placeholder.key;\n            placeholder.prevKey = row[row.length - 1].key;\n          }\n\n          row.push(placeholder);\n        }\n\n        if (row.length > 0) {\n          row[row.length - 1].nextKey = item.key;\n          item.prevKey = row[row.length - 1].key;\n        }\n\n        item.level = i;\n        item.colIndex = colIndex;\n        row.push(item);\n      }\n\n      i--;\n    }\n\n    colIndex++;\n  }\n\n  // Add placeholders at the end of each row that is shorter than the maximum\n  let i = 0;\n  for (let row of headerRows) {\n    let rowLength = row.reduce((p, c) => p + (c.colSpan ?? 1), 0);\n    if (rowLength < columnNodes.length) {\n      let placeholder: GridNode<T> = {\n        type: 'placeholder',\n        key: 'placeholder-' + row[row.length - 1].key,\n        colSpan: columnNodes.length - rowLength,\n        colspan: columnNodes.length - rowLength,\n        index: rowLength,\n        value: null,\n        rendered: null,\n        level: i,\n        hasChildNodes: false,\n        childNodes: [],\n        textValue: '',\n        prevKey: row[row.length - 1].key\n      };\n\n      row.push(placeholder);\n    }\n\n    i++;\n  }\n\n  return headerRows.map((childNodes, index) => {\n    let row: GridNode<T> = {\n      type: 'headerrow',\n      key: 'headerrow-' + index,\n      index,\n      value: null,\n      rendered: null,\n      level: 0,\n      hasChildNodes: true,\n      childNodes,\n      textValue: ''\n    };\n\n    return row;\n  });\n}\n\nexport class TableCollection<T> extends GridCollection<T> implements ITableCollection<T> {\n  headerRows: GridNode<T>[];\n  columns: GridNode<T>[];\n  rowHeaderColumnKeys: Set<Key>;\n  body: GridNode<T>;\n  _size: number = 0;\n\n  constructor(nodes: Iterable<GridNode<T>>, prev?: ITableCollection<T> | null, opts?: GridCollectionOptions) {\n    let rowHeaderColumnKeys: Set<Key> = new Set();\n    let body: GridNode<T> | null = null;\n    let columns: GridNode<T>[] = [];\n    // Add cell for selection checkboxes if needed.\n    if (opts?.showSelectionCheckboxes) {\n      let rowHeaderColumn: GridNode<T> = {\n        type: 'column',\n        key: ROW_HEADER_COLUMN_KEY,\n        value: null,\n        textValue: '',\n        level: 0,\n        index: opts?.showDragButtons ? 1 : 0,\n        hasChildNodes: false,\n        rendered: null,\n        childNodes: [],\n        props: {\n          isSelectionCell: true\n        }\n      };\n\n      columns.unshift(rowHeaderColumn);\n    }\n\n    // Add cell for drag buttons if needed.\n    if (opts?.showDragButtons) {\n      let rowHeaderColumn: GridNode<T> = {\n        type: 'column',\n        key: ROW_HEADER_COLUMN_KEY_DRAG,\n        value: null,\n        textValue: '',\n        level: 0,\n        index: 0,\n        hasChildNodes: false,\n        rendered: null,\n        childNodes: [],\n        props: {\n          isDragButtonCell: true\n        }\n      };\n\n      columns.unshift(rowHeaderColumn);\n    }\n\n    let rows: GridNode<T>[] = [];\n    let columnKeyMap = new Map();\n    let visit = (node: GridNode<T>) => {\n      switch (node.type) {\n        case 'body':\n          body = node;\n          break;\n        case 'column':\n          columnKeyMap.set(node.key, node);\n          if (!node.hasChildNodes) {\n            columns.push(node);\n\n            if (node.props.isRowHeader) {\n              rowHeaderColumnKeys.add(node.key);\n            }\n          }\n          break;\n        case 'item':\n          rows.push(node);\n          return; // do not go into childNodes\n      }\n      for (let child of node.childNodes) {\n        visit(child);\n      }\n    };\n\n    for (let node of nodes) {\n      visit(node);\n    }\n\n    let headerRows = buildHeaderRows(columnKeyMap, columns) as GridNode<T>[];\n    headerRows.forEach((row, i) => rows.splice(i, 0, row));\n\n    super({\n      columnCount: columns.length,\n      items: rows,\n      visitNode: node => {\n        node.column = columns[node.index];\n        return node;\n      }\n    });\n    this.columns = columns;\n    this.rowHeaderColumnKeys = rowHeaderColumnKeys;\n    this.body = body!;\n    this.headerRows = headerRows;\n    this._size = [...body!.childNodes].length;\n\n    // Default row header column to the first one.\n    if (this.rowHeaderColumnKeys.size === 0) {\n      let col = this.columns.find(column => !column.props?.isDragButtonCell && !column.props?.isSelectionCell);\n      if (col) {\n        this.rowHeaderColumnKeys.add(col.key);\n      }\n    }\n  }\n\n  *[Symbol.iterator](): IterableIterator<GridNode<T>> {\n    yield* this.body.childNodes;\n  }\n\n  get size(): number {\n    return this._size;\n  }\n\n  getKeys(): IterableIterator<Key> {\n    return this.keyMap.keys();\n  }\n\n  getKeyBefore(key: Key): Key | null {\n    let node = this.keyMap.get(key);\n    return node?.prevKey ?? null;\n  }\n\n  getKeyAfter(key: Key): Key | null {\n    let node = this.keyMap.get(key);\n    return node?.nextKey ?? null;\n  }\n\n  getFirstKey(): Key | null {\n    return getFirstItem(this.body.childNodes)?.key ?? null;\n  }\n\n  getLastKey(): Key | null {\n    return getLastItem(this.body.childNodes)?.key ?? null;\n  }\n\n  getItem(key: Key): GridNode<T> | null {\n    return this.keyMap.get(key) ?? null;\n  }\n\n  at(idx: number): GridNode<T> | null {\n    const keys = [...this.getKeys()];\n    return this.getItem(keys[idx]);\n  }\n\n  getChildren(key: Key): Iterable<GridNode<T>> {\n    if (key === this.body.key) {\n      return this.body.childNodes;\n    }\n\n    return super.getChildren(key);\n  }\n\n  getTextValue(key: Key): string {\n    let row = this.getItem(key);\n    if (!row) {\n      return '';\n    }\n\n    // If the row has a textValue, use that.\n    if (row.textValue) {\n      return row.textValue;\n    }\n\n    // Otherwise combine the text of each of the row header columns.\n    let rowHeaderColumnKeys = this.rowHeaderColumnKeys;\n    if (rowHeaderColumnKeys) {\n      let text: string[] = [];\n      for (let cell of row.childNodes) {\n        let column = this.columns[cell.index];\n        if (rowHeaderColumnKeys.has(column.key) && cell.textValue) {\n          text.push(cell.textValue);\n        }\n\n        if (text.length === rowHeaderColumnKeys.size) {\n          break;\n        }\n      }\n\n      return text.join(' ');\n    }\n\n    return '';\n  }\n}\n"],"mappings":";;;AAAA;;;;;;;;;;;;AAuBA,MAAMA,2CAAA,GAAwB,uBAAuBC,IAAA,CAAKC,MAAM,GAAGC,QAAQ,CAAC,IAAIC,KAAK,CAAC;AACtF,IAAIC,gDAAA,GAA6B,uBAAuBJ,IAAA,CAAKC,MAAM,GAAGC,QAAQ,CAAC,IAAIC,KAAK,CAAC;AACzF,OAAOJ,2CAAA,KAA0BK,gDAAA,EAC/BA,gDAAA,GAA6B,uBAAuBJ,IAAA,CAAKC,MAAM,GAAGC,QAAQ,CAAC,IAAIC,KAAK,CAAC;AAIhF,SAASE,0CAAmBC,MAA6B,EAAEC,WAA0B;EAC1F,IAAIA,WAAA,CAAYC,MAAM,KAAK,GACzB,OAAO,EAAE;EAGX,IAAIC,OAAA,GAA2B,EAAE;EACjC,IAAIC,IAAA,GAAO,IAAIC,GAAA;EACf,KAAK,IAAIC,MAAA,IAAUL,WAAA,EAAa;IAC9B,IAAIM,SAAA,GAAYD,MAAA,CAAOC,SAAS;IAChC,IAAIC,GAAA,GAAM,CAACF,MAAA,CAAO;IAElB,OAAOC,SAAA,EAAW;MAChB,IAAIE,MAAA,GAAkCT,MAAA,CAAOU,GAAG,CAACH,SAAA;MACjD,IAAI,CAACE,MAAA,EACH;MAGF;MACA;MACA;MACA;MACA,IAAIL,IAAA,CAAKO,GAAG,CAACF,MAAA,GAAS;YACpBG,OAAA;;QAAA,CAAAC,QAAA,IAAAD,OAAA,GAAAH,MAAA,EAAOK,OAAA,cAAAD,QAAA,cAAAA,QAAA,GAAPD,OAAA,CAAOE,OAAA,GAAY;QACnBL,MAAA,CAAOK,OAAO;QACdL,MAAA,CAAOM,OAAO,GAAGN,MAAA,CAAOK,OAAO;QAE/B,IAAI;UAAAR,MAAA,EAACA,MAAM;UAAAU,KAAA,EAAEA;QAAK,CAAC,GAAGZ,IAAA,CAAKM,GAAG,CAACD,MAAA;QAC/B,IAAIO,KAAA,GAAQR,GAAA,CAAIN,MAAM,EACpB;QAGF,KAAK,IAAIe,CAAA,GAAID,KAAA,EAAOC,CAAA,GAAIT,GAAA,CAAIN,MAAM,EAAEe,CAAA,IAClCX,MAAA,CAAOY,MAAM,CAACD,CAAA,EAAG,GAAG;QAGtB;QACA,KAAK,IAAIA,CAAA,GAAIT,GAAA,CAAIN,MAAM,EAAEe,CAAA,GAAIX,MAAA,CAAOJ,MAAM,EAAEe,CAAA;QAC1C;QACA,IAAIX,MAAM,CAACW,CAAA,CAAE,IAAIb,IAAA,CAAKO,GAAG,CAACL,MAAM,CAACW,CAAA,CAAE,GACjCb,IAAA,CAAKM,GAAG,CAACJ,MAAM,CAACW,CAAA,CAAE,EAAED,KAAK,GAAGC,CAAA;MAGlC,OAAO;QACLR,MAAA,CAAOK,OAAO,GAAG;QACjBL,MAAA,CAAOM,OAAO,GAAG;QACjBP,GAAA,CAAIW,IAAI,CAACV,MAAA;QACTL,IAAA,CAAKgB,GAAG,CAACX,MAAA,EAAQ;UAACH,MAAA,EAAQE,GAAA;UAAKQ,KAAA,EAAOR,GAAA,CAAIN,MAAM,GAAG;QAAC;MACtD;MAEAK,SAAA,GAAYE,MAAA,CAAOF,SAAS;IAC9B;IAEAJ,OAAA,CAAQgB,IAAI,CAACX,GAAA;IACbF,MAAA,CAAOU,KAAK,GAAGb,OAAA,CAAQD,MAAM,GAAG;EAClC;EAEA,IAAImB,SAAA,GAAY3B,IAAA,CAAK4B,GAAG,IAAInB,OAAA,CAAQoB,GAAG,CAACC,CAAA,IAAKA,CAAA,CAAEtB,MAAM;EACrD,IAAIuB,UAAA,GAA8BC,KAAA,CAAML,SAAA,EAAWM,IAAI,CAAC,GAAGJ,GAAG,CAAC,MAAM,EAAE;EAEvE;EACA,IAAIK,QAAA,GAAW;EACf,KAAK,IAAItB,MAAA,IAAUH,OAAA,EAAS;IAC1B,IAAIc,CAAA,GAAII,SAAA,GAAY;IACpB,KAAK,IAAIQ,IAAA,IAAQvB,MAAA,EAAQ;MACvB,IAAIuB,IAAA,EAAM;QACR;QACA,IAAIC,GAAA,GAAML,UAAU,CAACR,CAAA,CAAE;QACvB,IAAIc,SAAA,GAAYD,GAAA,CAAIE,MAAM,CAAC,CAACC,CAAA,EAAGT,CAAA;cAAWU,UAAA;iBAALD,CAAA,IAAK,CAAAC,UAAA,GAAAV,CAAA,CAAEV,OAAO,cAAToB,UAAA,cAAAA,UAAA,GAAa;WAAI;QAC3D,IAAIH,SAAA,GAAYH,QAAA,EAAU;UACxB,IAAIO,WAAA,GAA2B;YAC7BC,IAAA,EAAM;YACNC,GAAA,EAAK,iBAAiBR,IAAA,CAAKQ,GAAG;YAC9BtB,OAAA,EAASa,QAAA,GAAWG,SAAA;YACpBjB,OAAA,EAASc,QAAA,GAAWG,SAAA;YACpBf,KAAA,EAAOe,SAAA;YACPO,KAAA,EAAO;YACPC,QAAA,EAAU;YACVC,KAAA,EAAOvB,CAAA;YACPwB,aAAA,EAAe;YACfC,UAAA,EAAY,EAAE;YACdC,SAAA,EAAW;UACb;UAEA;UACA,IAAIb,GAAA,CAAI5B,MAAM,GAAG,GAAG;YAClB4B,GAAG,CAACA,GAAA,CAAI5B,MAAM,GAAG,EAAE,CAAC0C,OAAO,GAAGT,WAAA,CAAYE,GAAG;YAC7CF,WAAA,CAAYU,OAAO,GAAGf,GAAG,CAACA,GAAA,CAAI5B,MAAM,GAAG,EAAE,CAACmC,GAAG;UAC/C;UAEAP,GAAA,CAAIX,IAAI,CAACgB,WAAA;QACX;QAEA,IAAIL,GAAA,CAAI5B,MAAM,GAAG,GAAG;UAClB4B,GAAG,CAACA,GAAA,CAAI5B,MAAM,GAAG,EAAE,CAAC0C,OAAO,GAAGf,IAAA,CAAKQ,GAAG;UACtCR,IAAA,CAAKgB,OAAO,GAAGf,GAAG,CAACA,GAAA,CAAI5B,MAAM,GAAG,EAAE,CAACmC,GAAG;QACxC;QAEAR,IAAA,CAAKW,KAAK,GAAGvB,CAAA;QACbY,IAAA,CAAKD,QAAQ,GAAGA,QAAA;QAChBE,GAAA,CAAIX,IAAI,CAACU,IAAA;MACX;MAEAZ,CAAA;IACF;IAEAW,QAAA;EACF;EAEA;EACA,IAAIX,CAAA,GAAI;EACR,KAAK,IAAIa,GAAA,IAAOL,UAAA,EAAY;IAC1B,IAAIM,SAAA,GAAYD,GAAA,CAAIE,MAAM,CAAC,CAACC,CAAA,EAAGT,CAAA;UAAWU,UAAA;aAALD,CAAA,IAAK,CAAAC,UAAA,GAAAV,CAAA,CAAEV,OAAO,cAAToB,UAAA,cAAAA,UAAA,GAAa;OAAI;IAC3D,IAAIH,SAAA,GAAY9B,WAAA,CAAYC,MAAM,EAAE;MAClC,IAAIiC,WAAA,GAA2B;QAC7BC,IAAA,EAAM;QACNC,GAAA,EAAK,iBAAiBP,GAAG,CAACA,GAAA,CAAI5B,MAAM,GAAG,EAAE,CAACmC,GAAG;QAC7CvB,OAAA,EAASb,WAAA,CAAYC,MAAM,GAAG6B,SAAA;QAC9BhB,OAAA,EAASd,WAAA,CAAYC,MAAM,GAAG6B,SAAA;QAC9Bf,KAAA,EAAOe,SAAA;QACPO,KAAA,EAAO;QACPC,QAAA,EAAU;QACVC,KAAA,EAAOvB,CAAA;QACPwB,aAAA,EAAe;QACfC,UAAA,EAAY,EAAE;QACdC,SAAA,EAAW;QACXE,OAAA,EAASf,GAAG,CAACA,GAAA,CAAI5B,MAAM,GAAG,EAAE,CAACmC;MAC/B;MAEAP,GAAA,CAAIX,IAAI,CAACgB,WAAA;IACX;IAEAlB,CAAA;EACF;EAEA,OAAOQ,UAAA,CAAWF,GAAG,CAAC,CAACmB,UAAA,EAAY1B,KAAA;IACjC,IAAIc,GAAA,GAAmB;MACrBM,IAAA,EAAM;MACNC,GAAA,EAAK,eAAerB,KAAA;aACpBA,KAAA;MACAsB,KAAA,EAAO;MACPC,QAAA,EAAU;MACVC,KAAA,EAAO;MACPC,aAAA,EAAe;kBACfC,UAAA;MACAC,SAAA,EAAW;IACb;IAEA,OAAOb,GAAA;EACT;AACF;AAEO,MAAMgB,yCAAA,UAA2B,GAAAC,qBAAa;EA2GnD,EAAEC,MAAA,CAAOC,QAAQ,IAAmC;IAClD,OAAO,IAAI,CAACC,IAAI,CAACR,UAAU;EAC7B;EAEA,IAAIS,KAAA,EAAe;IACjB,OAAO,IAAI,CAACC,KAAK;EACnB;EAEAC,QAAA,EAAiC;IAC/B,OAAO,IAAI,CAACrD,MAAM,CAACsD,IAAI;EACzB;EAEAC,aAAalB,GAAQ,EAAc;IACjC,IAAImB,IAAA,GAAO,IAAI,CAACxD,MAAM,CAACU,GAAG,CAAC2B,GAAA;QACpBoB,aAAA;IAAP,OAAO,CAAAA,aAAA,GAAAD,IAAA,aAAAA,IAAA,uBAAAA,IAAA,CAAMX,OAAO,cAAbY,aAAA,cAAAA,aAAA,GAAiB;EAC1B;EAEAC,YAAYrB,GAAQ,EAAc;IAChC,IAAImB,IAAA,GAAO,IAAI,CAACxD,MAAM,CAACU,GAAG,CAAC2B,GAAA;QACpBsB,aAAA;IAAP,OAAO,CAAAA,aAAA,GAAAH,IAAA,aAAAA,IAAA,uBAAAA,IAAA,CAAMZ,OAAO,cAAbe,aAAA,cAAAA,aAAA,GAAiB;EAC1B;EAEAC,YAAA,EAA0B;QACjBC,aAAA;QAAAC,iBAAA;IAAP,OAAO,CAAAA,iBAAA,IAAAD,aAAA,OAAAE,mBAAW,EAAE,IAAI,CAACb,IAAI,CAACR,UAAU,eAAjCmB,aAAA,uBAAAA,aAAA,CAAoCxB,GAAG,cAAvCyB,iBAAA,cAAAA,iBAAA,GAA2C;EACpD;EAEAE,WAAA,EAAyB;QAChBC,YAAA;QAAAC,gBAAA;IAAP,OAAO,CAAAA,gBAAA,IAAAD,YAAA,OAAAE,kBAAU,EAAE,IAAI,CAACjB,IAAI,CAACR,UAAU,eAAhCuB,YAAA,uBAAAA,YAAA,CAAmC5B,GAAG,cAAtC6B,gBAAA,cAAAA,gBAAA,GAA0C;EACnD;EAEAE,QAAQ/B,GAAQ,EAAsB;QAC7BgC,gBAAA;IAAP,OAAO,CAAAA,gBAAA,OAAI,CAACrE,MAAM,CAACU,GAAG,CAAC2B,GAAA,eAAhBgC,gBAAA,cAAAA,gBAAA,GAAwB;EACjC;EAEAC,GAAGC,GAAW,EAAsB;IAClC,MAAMjB,IAAA,GAAO,C,GAAI,IAAI,CAACD,OAAO,GAAG;IAChC,OAAO,IAAI,CAACe,OAAO,CAACd,IAAI,CAACiB,GAAA,CAAI;EAC/B;EAEAC,YAAYnC,GAAQ,EAAyB;IAC3C,IAAIA,GAAA,KAAQ,IAAI,CAACa,IAAI,CAACb,GAAG,EACvB,OAAO,IAAI,CAACa,IAAI,CAACR,UAAU;IAG7B,OAAO,KAAK,CAAC8B,WAAA,CAAYnC,GAAA;EAC3B;EAEAoC,aAAapC,GAAQ,EAAU;IAC7B,IAAIP,GAAA,GAAM,IAAI,CAACsC,OAAO,CAAC/B,GAAA;IACvB,IAAI,CAACP,GAAA,EACH,OAAO;IAGT;IACA,IAAIA,GAAA,CAAIa,SAAS,EACf,OAAOb,GAAA,CAAIa,SAAS;IAGtB;IACA,IAAI+B,mBAAA,GAAsB,IAAI,CAACA,mBAAmB;IAClD,IAAIA,mBAAA,EAAqB;MACvB,IAAIC,IAAA,GAAiB,EAAE;MACvB,KAAK,IAAIC,IAAA,IAAQ9C,GAAA,CAAIY,UAAU,EAAE;QAC/B,IAAIpC,MAAA,GAAS,IAAI,CAACH,OAAO,CAACyE,IAAA,CAAK5D,KAAK,CAAC;QACrC,IAAI0D,mBAAA,CAAoB/D,GAAG,CAACL,MAAA,CAAO+B,GAAG,KAAKuC,IAAA,CAAKjC,SAAS,EACvDgC,IAAA,CAAKxD,IAAI,CAACyD,IAAA,CAAKjC,SAAS;QAG1B,IAAIgC,IAAA,CAAKzE,MAAM,KAAKwE,mBAAA,CAAoBvB,IAAI,EAC1C;MAEJ;MAEA,OAAOwB,IAAA,CAAKE,IAAI,CAAC;IACnB;IAEA,OAAO;EACT;EAjLAC,YAAYC,KAA4B,EAAEC,IAAiC,EAAEC,IAA4B,EAAE;IACzG,IAAIP,mBAAA,GAAgC,IAAIQ,GAAA;IACxC,IAAIhC,IAAA,GAA2B;IAC/B,IAAI/C,OAAA,GAAyB,EAAE;IAC/B;IACA,IAAI8E,IAAA,aAAAA,IAAA,uBAAAA,IAAA,CAAME,uBAAuB,EAAE;MACjC,IAAIC,eAAA,GAA+B;QACjChD,IAAA,EAAM;QACNC,GAAA,EAAK5C,2CAAA;QACL6C,KAAA,EAAO;QACPK,SAAA,EAAW;QACXH,KAAA,EAAO;QACPxB,KAAA,EAAO,CAAAiE,IAAA,aAAAA,IAAA,uBAAAA,IAAA,CAAMI,eAAe,IAAG,IAAI;QACnC5C,aAAA,EAAe;QACfF,QAAA,EAAU;QACVG,UAAA,EAAY,EAAE;QACd4C,KAAA,EAAO;UACLC,eAAA,EAAiB;QACnB;MACF;MAEApF,OAAA,CAAQqF,OAAO,CAACJ,eAAA;IAClB;IAEA;IACA,IAAIH,IAAA,aAAAA,IAAA,uBAAAA,IAAA,CAAMI,eAAe,EAAE;MACzB,IAAID,eAAA,GAA+B;QACjChD,IAAA,EAAM;QACNC,GAAA,EAAKvC,gDAAA;QACLwC,KAAA,EAAO;QACPK,SAAA,EAAW;QACXH,KAAA,EAAO;QACPxB,KAAA,EAAO;QACPyB,aAAA,EAAe;QACfF,QAAA,EAAU;QACVG,UAAA,EAAY,EAAE;QACd4C,KAAA,EAAO;UACLG,gBAAA,EAAkB;QACpB;MACF;MAEAtF,OAAA,CAAQqF,OAAO,CAACJ,eAAA;IAClB;IAEA,IAAIM,IAAA,GAAsB,EAAE;IAC5B,IAAIC,YAAA,GAAe,IAAItF,GAAA;IACvB,IAAIuF,KAAA,GAASpC,IAAA;MACX,QAAQA,IAAA,CAAKpB,IAAI;QACf,KAAK;UACHc,IAAA,GAAOM,IAAA;UACP;QACF,KAAK;UACHmC,YAAA,CAAavE,GAAG,CAACoC,IAAA,CAAKnB,GAAG,EAAEmB,IAAA;UAC3B,IAAI,CAACA,IAAA,CAAKf,aAAa,EAAE;YACvBtC,OAAA,CAAQgB,IAAI,CAACqC,IAAA;YAEb,IAAIA,IAAA,CAAK8B,KAAK,CAACO,WAAW,EACxBnB,mBAAA,CAAoBoB,GAAG,CAACtC,IAAA,CAAKnB,GAAG;UAEpC;UACA;QACF,KAAK;UACHqD,IAAA,CAAKvE,IAAI,CAACqC,IAAA;UACV;QAAQ;MACZ;MACA,KAAK,IAAIuC,KAAA,IAASvC,IAAA,CAAKd,UAAU,EAC/BkD,KAAA,CAAMG,KAAA;IAEV;IAEA,KAAK,IAAIvC,IAAA,IAAQuB,KAAA,EACfa,KAAA,CAAMpC,IAAA;IAGR,IAAI/B,UAAA,GAAa1B,yCAAA,CAAgB4F,YAAA,EAAcxF,OAAA;IAC/CsB,UAAA,CAAWuE,OAAO,CAAC,CAAClE,GAAA,EAAKb,CAAA,KAAMyE,IAAA,CAAKxE,MAAM,CAACD,CAAA,EAAG,GAAGa,GAAA;IAEjD,KAAK,CAAC;MACJmE,WAAA,EAAa9F,OAAA,CAAQD,MAAM;MAC3BgG,KAAA,EAAOR,IAAA;MACPS,SAAA,EAAW3C,IAAA;QACTA,IAAA,CAAKlD,MAAM,GAAGH,OAAO,CAACqD,IAAA,CAAKxC,KAAK,CAAC;QACjC,OAAOwC,IAAA;MACT;IACF,SAtFFJ,KAAA,GAAgB;IAuFd,IAAI,CAACjD,OAAO,GAAGA,OAAA;IACf,IAAI,CAACuE,mBAAmB,GAAGA,mBAAA;IAC3B,IAAI,CAACxB,IAAI,GAAGA,IAAA;IACZ,IAAI,CAACzB,UAAU,GAAGA,UAAA;IAClB,IAAI,CAAC2B,KAAK,GAAG,C,GAAIF,IAAA,CAAMR,UAAU,CAAC,CAACxC,MAAM;IAEzC;IACA,IAAI,IAAI,CAACwE,mBAAmB,CAACvB,IAAI,KAAK,GAAG;MACvC,IAAI3C,GAAA,GAAM,IAAI,CAACL,OAAO,CAACiG,IAAI,CAAC9F,MAAA;YAAW+F,aAAA,EAAmCC,cAAA;eAApC,GAACD,aAAA,GAAA/F,MAAA,CAAOgF,KAAK,cAAZe,aAAA,uBAAAA,aAAA,CAAcZ,gBAAgB,KAAI,GAACa,cAAA,GAAAhG,MAAA,CAAOgF,KAAK,cAAZgB,cAAA,uBAAAA,cAAA,CAAcf,eAAe;;MACvG,IAAI/E,GAAA,EACF,IAAI,CAACkE,mBAAmB,CAACoB,GAAG,CAACtF,GAAA,CAAI6B,GAAG;IAExC;EACF;AAgFF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}