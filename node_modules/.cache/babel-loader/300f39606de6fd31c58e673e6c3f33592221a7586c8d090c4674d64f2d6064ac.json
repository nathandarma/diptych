{"ast":null,"code":"import { getFormatOptions as $35a22f14a1f04b11$export$7e319ea407e63bc0, getPlaceholderTime as $35a22f14a1f04b11$export$c5221a78ef73c5e9, getRangeValidationResult as $35a22f14a1f04b11$export$80ff8fc0ae339c13, useDefaultProps as $35a22f14a1f04b11$export$2440da353cedad43 } from \"./utils.mjs\";\nimport { toCalendarDate as $hac8C$toCalendarDate, toCalendarDateTime as $hac8C$toCalendarDateTime, DateFormatter as $hac8C$DateFormatter } from \"@internationalized/date\";\nimport { useFormValidationState as $hac8C$useFormValidationState } from \"@react-stately/form\";\nimport { useOverlayTriggerState as $hac8C$useOverlayTriggerState } from \"@react-stately/overlays\";\nimport { useControlledState as $hac8C$useControlledState } from \"@react-stately/utils\";\nimport { useState as $hac8C$useState, useMemo as $hac8C$useMemo } from \"react\";\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nfunction $93c38a5e28be6249$export$e50a61c1de9f574(props) {\n  var _value_start, _value_end;\n  let overlayState = (0, $hac8C$useOverlayTriggerState)(props);\n  let [controlledValue, setControlledValue] = (0, $hac8C$useControlledState)(props.value, props.defaultValue || null, props.onChange);\n  let [placeholderValue, setPlaceholderValue] = (0, $hac8C$useState)(() => controlledValue || {\n    start: null,\n    end: null\n  });\n  // Reset the placeholder if the value prop is set to null.\n  if (controlledValue == null && placeholderValue.start && placeholderValue.end) {\n    placeholderValue = {\n      start: null,\n      end: null\n    };\n    setPlaceholderValue(placeholderValue);\n  }\n  let value = controlledValue || placeholderValue;\n  let setValue = value => {\n    setPlaceholderValue(value || {\n      start: null,\n      end: null\n    });\n    if ($93c38a5e28be6249$var$isCompleteRange(value)) setControlledValue(value);else setControlledValue(null);\n  };\n  let v = (value === null || value === void 0 ? void 0 : value.start) || (value === null || value === void 0 ? void 0 : value.end) || props.placeholderValue || null;\n  let [granularity, defaultTimeZone] = (0, $35a22f14a1f04b11$export$2440da353cedad43)(v, props.granularity);\n  let hasTime = granularity === 'hour' || granularity === 'minute' || granularity === 'second';\n  var _props_shouldCloseOnSelect;\n  let shouldCloseOnSelect = (_props_shouldCloseOnSelect = props.shouldCloseOnSelect) !== null && _props_shouldCloseOnSelect !== void 0 ? _props_shouldCloseOnSelect : true;\n  let [dateRange, setSelectedDateRange] = (0, $hac8C$useState)(null);\n  let [timeRange, setSelectedTimeRange] = (0, $hac8C$useState)(null);\n  if (value && $93c38a5e28be6249$var$isCompleteRange(value)) {\n    dateRange = value;\n    if ('hour' in value.start) timeRange = value;\n  }\n  let commitValue = (dateRange, timeRange) => {\n    setValue({\n      start: 'timeZone' in timeRange.start ? timeRange.start.set((0, $hac8C$toCalendarDate)(dateRange.start)) : (0, $hac8C$toCalendarDateTime)(dateRange.start, timeRange.start),\n      end: 'timeZone' in timeRange.end ? timeRange.end.set((0, $hac8C$toCalendarDate)(dateRange.end)) : (0, $hac8C$toCalendarDateTime)(dateRange.end, timeRange.end)\n    });\n    setSelectedDateRange(null);\n    setSelectedTimeRange(null);\n    validation.commitValidation();\n  };\n  // Intercept setValue to make sure the Time section is not changed by date selection in Calendar\n  let setDateRange = range => {\n    let shouldClose = typeof shouldCloseOnSelect === 'function' ? shouldCloseOnSelect() : shouldCloseOnSelect;\n    if (hasTime) {\n      if ($93c38a5e28be6249$var$isCompleteRange(range) && (timeRange === null || timeRange === void 0 ? void 0 : timeRange.start) && (timeRange === null || timeRange === void 0 ? void 0 : timeRange.end)) commitValue(range, {\n        start: (timeRange === null || timeRange === void 0 ? void 0 : timeRange.start) || (0, $35a22f14a1f04b11$export$c5221a78ef73c5e9)(props.placeholderValue),\n        end: (timeRange === null || timeRange === void 0 ? void 0 : timeRange.end) || (0, $35a22f14a1f04b11$export$c5221a78ef73c5e9)(props.placeholderValue)\n      });else setSelectedDateRange(range);\n    } else if ($93c38a5e28be6249$var$isCompleteRange(range)) {\n      setValue(range);\n      validation.commitValidation();\n    } else setSelectedDateRange(range);\n    if (shouldClose) overlayState.setOpen(false);\n  };\n  let setTimeRange = range => {\n    if ($93c38a5e28be6249$var$isCompleteRange(dateRange) && $93c38a5e28be6249$var$isCompleteRange(range)) commitValue(dateRange, range);else setSelectedTimeRange(range);\n  };\n  let showEra = (value === null || value === void 0 ? void 0 : (_value_start = value.start) === null || _value_start === void 0 ? void 0 : _value_start.calendar.identifier) === 'gregory' && value.start.era === 'BC' || (value === null || value === void 0 ? void 0 : (_value_end = value.end) === null || _value_end === void 0 ? void 0 : _value_end.calendar.identifier) === 'gregory' && value.end.era === 'BC';\n  let formatOpts = (0, $hac8C$useMemo)(() => ({\n    granularity: granularity,\n    timeZone: defaultTimeZone,\n    hideTimeZone: props.hideTimeZone,\n    hourCycle: props.hourCycle,\n    shouldForceLeadingZeros: props.shouldForceLeadingZeros,\n    showEra: showEra\n  }), [granularity, props.hourCycle, props.shouldForceLeadingZeros, defaultTimeZone, props.hideTimeZone, showEra]);\n  let {\n    minValue: minValue,\n    maxValue: maxValue,\n    isDateUnavailable: isDateUnavailable\n  } = props;\n  let builtinValidation = (0, $hac8C$useMemo)(() => (0, $35a22f14a1f04b11$export$80ff8fc0ae339c13)(value, minValue, maxValue, isDateUnavailable, formatOpts), [value, minValue, maxValue, isDateUnavailable, formatOpts]);\n  let validation = (0, $hac8C$useFormValidationState)({\n    ...props,\n    value: controlledValue,\n    name: (0, $hac8C$useMemo)(() => [props.startName, props.endName].filter(n => n != null), [props.startName, props.endName]),\n    builtinValidation: builtinValidation\n  });\n  let isValueInvalid = validation.displayValidation.isInvalid;\n  let validationState = props.validationState || (isValueInvalid ? 'invalid' : null);\n  return {\n    ...validation,\n    value: value,\n    setValue: setValue,\n    dateRange: dateRange,\n    timeRange: timeRange,\n    granularity: granularity,\n    hasTime: hasTime,\n    setDate(part, date) {\n      var _dateRange_end, _dateRange_start;\n      if (part === 'start') setDateRange({\n        start: date,\n        end: (_dateRange_end = dateRange === null || dateRange === void 0 ? void 0 : dateRange.end) !== null && _dateRange_end !== void 0 ? _dateRange_end : null\n      });else setDateRange({\n        start: (_dateRange_start = dateRange === null || dateRange === void 0 ? void 0 : dateRange.start) !== null && _dateRange_start !== void 0 ? _dateRange_start : null,\n        end: date\n      });\n    },\n    setTime(part, time) {\n      var _timeRange_end, _timeRange_start;\n      if (part === 'start') setTimeRange({\n        start: time,\n        end: (_timeRange_end = timeRange === null || timeRange === void 0 ? void 0 : timeRange.end) !== null && _timeRange_end !== void 0 ? _timeRange_end : null\n      });else setTimeRange({\n        start: (_timeRange_start = timeRange === null || timeRange === void 0 ? void 0 : timeRange.start) !== null && _timeRange_start !== void 0 ? _timeRange_start : null,\n        end: time\n      });\n    },\n    setDateTime(part, dateTime) {\n      var _value_end, _value_start;\n      if (part === 'start') setValue({\n        start: dateTime,\n        end: (_value_end = value === null || value === void 0 ? void 0 : value.end) !== null && _value_end !== void 0 ? _value_end : null\n      });else setValue({\n        start: (_value_start = value === null || value === void 0 ? void 0 : value.start) !== null && _value_start !== void 0 ? _value_start : null,\n        end: dateTime\n      });\n    },\n    setDateRange: setDateRange,\n    setTimeRange: setTimeRange,\n    ...overlayState,\n    setOpen(isOpen) {\n      // Commit the selected date range when the calendar is closed. Use a placeholder time if one wasn't set.\n      // If only the time range was set and not the date range, don't commit. The state will be preserved until\n      // the user opens the popover again.\n      if (!isOpen && !((value === null || value === void 0 ? void 0 : value.start) && (value === null || value === void 0 ? void 0 : value.end)) && $93c38a5e28be6249$var$isCompleteRange(dateRange) && hasTime) commitValue(dateRange, {\n        start: (timeRange === null || timeRange === void 0 ? void 0 : timeRange.start) || (0, $35a22f14a1f04b11$export$c5221a78ef73c5e9)(props.placeholderValue),\n        end: (timeRange === null || timeRange === void 0 ? void 0 : timeRange.end) || (0, $35a22f14a1f04b11$export$c5221a78ef73c5e9)(props.placeholderValue)\n      });\n      overlayState.setOpen(isOpen);\n    },\n    validationState: validationState,\n    isInvalid: isValueInvalid,\n    formatValue(locale, fieldOptions) {\n      if (!value || !value.start || !value.end) return null;\n      let startTimeZone = 'timeZone' in value.start ? value.start.timeZone : undefined;\n      let startGranularity = props.granularity || (value.start && 'minute' in value.start ? 'minute' : 'day');\n      let endTimeZone = 'timeZone' in value.end ? value.end.timeZone : undefined;\n      let endGranularity = props.granularity || (value.end && 'minute' in value.end ? 'minute' : 'day');\n      let startOptions = (0, $35a22f14a1f04b11$export$7e319ea407e63bc0)(fieldOptions, {\n        granularity: startGranularity,\n        timeZone: startTimeZone,\n        hideTimeZone: props.hideTimeZone,\n        hourCycle: props.hourCycle,\n        showEra: value.start.calendar.identifier === 'gregory' && value.start.era === 'BC' || value.end.calendar.identifier === 'gregory' && value.end.era === 'BC'\n      });\n      let startDate = value.start.toDate(startTimeZone || 'UTC');\n      let endDate = value.end.toDate(endTimeZone || 'UTC');\n      let startFormatter = new (0, $hac8C$DateFormatter)(locale, startOptions);\n      let endFormatter;\n      if (startTimeZone === endTimeZone && startGranularity === endGranularity && value.start.compare(value.end) !== 0) {\n        // Use formatRange, as it results in shorter output when some of the fields\n        // are shared between the start and end dates (e.g. the same month).\n        // Formatting will fail if the end date is before the start date. Fall back below when that happens.\n        try {\n          let parts = startFormatter.formatRangeToParts(startDate, endDate);\n          // Find the separator between the start and end date. This is determined\n          // by finding the last shared literal before the end range.\n          let separatorIndex = -1;\n          for (let i = 0; i < parts.length; i++) {\n            let part = parts[i];\n            if (part.source === 'shared' && part.type === 'literal') separatorIndex = i;else if (part.source === 'endRange') break;\n          }\n          // Now we can combine the parts into start and end strings.\n          let start = '';\n          let end = '';\n          for (let i = 0; i < parts.length; i++) {\n            if (i < separatorIndex) start += parts[i].value;else if (i > separatorIndex) end += parts[i].value;\n          }\n          return {\n            start: start,\n            end: end\n          };\n        } catch {\n          // ignore\n        }\n        endFormatter = startFormatter;\n      } else {\n        let endOptions = (0, $35a22f14a1f04b11$export$7e319ea407e63bc0)(fieldOptions, {\n          granularity: endGranularity,\n          timeZone: endTimeZone,\n          hideTimeZone: props.hideTimeZone,\n          hourCycle: props.hourCycle\n        });\n        endFormatter = new (0, $hac8C$DateFormatter)(locale, endOptions);\n      }\n      return {\n        start: startFormatter.format(startDate),\n        end: endFormatter.format(endDate)\n      };\n    },\n    getDateFormatter(locale, formatOptions) {\n      let newOptions = {\n        ...formatOpts,\n        ...formatOptions\n      };\n      let newFormatOptions = (0, $35a22f14a1f04b11$export$7e319ea407e63bc0)({}, newOptions);\n      return new (0, $hac8C$DateFormatter)(locale, newFormatOptions);\n    }\n  };\n}\nfunction $93c38a5e28be6249$var$isCompleteRange(value) {\n  return (value === null || value === void 0 ? void 0 : value.start) != null && value.end != null;\n}\nexport { $93c38a5e28be6249$export$e50a61c1de9f574 as useDateRangePickerState };","map":{"version":3,"names":["$93c38a5e28be6249$export$e50a61c1de9f574","props","_value_start","_value_end","overlayState","$hac8C$useOverlayTriggerState","controlledValue","setControlledValue","$hac8C$useControlledState","value","defaultValue","onChange","placeholderValue","setPlaceholderValue","$hac8C$useState","start","end","setValue","$93c38a5e28be6249$var$isCompleteRange","v","granularity","defaultTimeZone","$35a22f14a1f04b11$export$2440da353cedad43","hasTime","_props_shouldCloseOnSelect","shouldCloseOnSelect","dateRange","setSelectedDateRange","timeRange","setSelectedTimeRange","commitValue","set","$hac8C$toCalendarDate","$hac8C$toCalendarDateTime","validation","commitValidation","setDateRange","range","shouldClose","$35a22f14a1f04b11$export$c5221a78ef73c5e9","setOpen","setTimeRange","showEra","calendar","identifier","era","formatOpts","$hac8C$useMemo","timeZone","hideTimeZone","hourCycle","shouldForceLeadingZeros","minValue","maxValue","isDateUnavailable","builtinValidation","$35a22f14a1f04b11$export$80ff8fc0ae339c13","$hac8C$useFormValidationState","name","startName","endName","filter","n","isValueInvalid","displayValidation","isInvalid","validationState","setDate","part","date","_dateRange_end","_dateRange_start","setTime","time","_timeRange_end","_timeRange_start","setDateTime","dateTime","isOpen","formatValue","locale","fieldOptions","startTimeZone","undefined","startGranularity","endTimeZone","endGranularity","startOptions","$35a22f14a1f04b11$export$7e319ea407e63bc0","startDate","toDate","endDate","startFormatter","$hac8C$DateFormatter","endFormatter","compare","parts","formatRangeToParts","separatorIndex","i","length","source","type","endOptions","format","getDateFormatter","formatOptions","newOptions","newFormatOptions"],"sources":["/Users/nathandarma/Documents/App Testing/Diptych/diptych/node_modules/@react-stately/datepicker/dist/packages/@react-stately/datepicker/src/useDateRangePickerState.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\n\nimport {DateFormatter, toCalendarDate, toCalendarDateTime} from '@internationalized/date';\nimport {DateRange, DateRangePickerProps, DateValue, Granularity, MappedDateValue, TimeValue} from '@react-types/datepicker';\nimport {FieldOptions, FormatterOptions, getFormatOptions, getPlaceholderTime, getRangeValidationResult, useDefaultProps} from './utils';\nimport {FormValidationState, useFormValidationState} from '@react-stately/form';\nimport {OverlayTriggerState, useOverlayTriggerState} from '@react-stately/overlays';\nimport {RangeValue, ValidationState} from '@react-types/shared';\nimport {useControlledState} from '@react-stately/utils';\nimport {useMemo, useState} from 'react';\n\nexport interface DateRangePickerStateOptions<T extends DateValue = DateValue> extends DateRangePickerProps<T> {\n  /**\n   * Determines whether the date picker popover should close automatically when a date is selected.\n   * @default true\n   */\n  shouldCloseOnSelect?: boolean | (() => boolean)\n}\n\ntype TimeRange = RangeValue<TimeValue>;\nexport interface DateRangePickerState extends OverlayTriggerState, FormValidationState {\n  /** The currently selected date range. */\n  value: RangeValue<DateValue | null>,\n  /** Sets the selected date range. */\n  setValue(value: DateRange | null): void,\n  /**\n   * The date portion of the selected range. This may be set prior to `value` if the user has\n   * selected a date range but has not yet selected a time range.\n   */\n  dateRange: RangeValue<DateValue | null> | null,\n  /** Sets the date portion of the selected range. */\n  setDateRange(value: DateRange): void,\n  /**\n   * The time portion of the selected range. This may be set prior to `value` if the user has\n   * selected a time range but has not yet selected a date range.\n   */\n  timeRange: RangeValue<TimeValue | null> | null,\n  /** Sets the time portion of the selected range. */\n  setTimeRange(value: TimeRange): void,\n  /** Sets the date portion of either the start or end of the selected range. */\n  setDate(part: 'start' | 'end', value: DateValue | null): void,\n  /** Sets the time portion of either the start or end of the selected range. */\n  setTime(part: 'start' | 'end', value: TimeValue | null): void,\n  /** Sets the date and time of either the start or end of the selected range. */\n  setDateTime(part: 'start' | 'end', value: DateValue | null): void,\n  /** The granularity for the field, based on the `granularity` prop and current value. */\n  granularity: Granularity,\n  /** Whether the date range picker supports selecting times, according to the `granularity` prop and current value. */\n  hasTime: boolean,\n  /** Whether the calendar popover is currently open. */\n  isOpen: boolean,\n  /** Sets whether the calendar popover is open. */\n  setOpen(isOpen: boolean): void,\n  /**\n   * The current validation state of the date range picker, based on the `validationState`, `minValue`, and `maxValue` props.\n   * @deprecated Use `isInvalid` instead.\n   */\n  validationState: ValidationState | null,\n  /** Whether the date range picker is invalid, based on the `isInvalid`, `minValue`, and `maxValue` props. */\n  isInvalid: boolean,\n  /** Formats the selected range using the given options. */\n  formatValue(locale: string, fieldOptions: FieldOptions): {start: string, end: string} | null,\n  /** Gets a formatter based on state's props. */\n  getDateFormatter(locale: string, formatOptions: FormatterOptions): DateFormatter\n}\n\n/**\n * Provides state management for a date range picker component.\n * A date range picker combines two DateFields and a RangeCalendar popover to allow\n * users to enter or select a date and time range.\n */\nexport function useDateRangePickerState<T extends DateValue = DateValue>(props: DateRangePickerStateOptions<T>): DateRangePickerState {\n  let overlayState = useOverlayTriggerState(props);\n  let [controlledValue, setControlledValue] = useControlledState<DateRange | null, RangeValue<MappedDateValue<T>> | null>(props.value, props.defaultValue || null, props.onChange);\n  let [placeholderValue, setPlaceholderValue] = useState<RangeValue<DateValue | null>>(() => controlledValue || {start: null, end: null});\n\n  // Reset the placeholder if the value prop is set to null.\n  if (controlledValue == null && placeholderValue.start && placeholderValue.end) {\n    placeholderValue = {start: null, end: null};\n    setPlaceholderValue(placeholderValue);\n  }\n\n  let value = controlledValue || placeholderValue;\n\n  let setValue = (value: RangeValue<DateValue | null> | null) => {\n    setPlaceholderValue(value || {start: null, end: null});\n    if (isCompleteRange(value)) {\n      setControlledValue(value);\n    } else {\n      setControlledValue(null);\n    }\n  };\n\n  let v = (value?.start || value?.end || props.placeholderValue || null);\n  let [granularity, defaultTimeZone] = useDefaultProps(v, props.granularity);\n  let hasTime = granularity === 'hour' || granularity === 'minute' || granularity === 'second';\n  let shouldCloseOnSelect = props.shouldCloseOnSelect ?? true;\n\n  let [dateRange, setSelectedDateRange] = useState<RangeValue<DateValue | null> | null>(null);\n  let [timeRange, setSelectedTimeRange] = useState<RangeValue<TimeValue | null> | null>(null);\n\n  if (value && isCompleteRange(value)) {\n    dateRange = value;\n    if ('hour' in value.start) {\n      timeRange = value as TimeRange;\n    }\n  }\n\n  let commitValue = (dateRange: DateRange, timeRange: TimeRange) => {\n    setValue({\n      start: 'timeZone' in timeRange.start ? timeRange.start.set(toCalendarDate(dateRange.start)) : toCalendarDateTime(dateRange.start, timeRange.start),\n      end: 'timeZone' in timeRange.end ? timeRange.end.set(toCalendarDate(dateRange.end)) : toCalendarDateTime(dateRange.end, timeRange.end)\n    });\n    setSelectedDateRange(null);\n    setSelectedTimeRange(null);\n    validation.commitValidation();\n  };\n\n  // Intercept setValue to make sure the Time section is not changed by date selection in Calendar\n  let setDateRange = (range: RangeValue<DateValue | null>) => {\n    let shouldClose = typeof shouldCloseOnSelect === 'function' ? shouldCloseOnSelect() : shouldCloseOnSelect;\n    if (hasTime) {\n      if (isCompleteRange(range) && timeRange?.start && timeRange?.end) {\n        commitValue(range, {\n          start: timeRange?.start || getPlaceholderTime(props.placeholderValue),\n          end: timeRange?.end || getPlaceholderTime(props.placeholderValue)\n        });\n      } else {\n        setSelectedDateRange(range);\n      }\n    } else if (isCompleteRange(range)) {\n      setValue(range);\n      validation.commitValidation();\n    } else {\n      setSelectedDateRange(range);\n    }\n\n    if (shouldClose) {\n      overlayState.setOpen(false);\n    }\n  };\n\n  let setTimeRange = (range: RangeValue<TimeValue | null>) => {\n    if (isCompleteRange(dateRange) && isCompleteRange(range)) {\n      commitValue(dateRange, range);\n    } else {\n      setSelectedTimeRange(range);\n    }\n  };\n\n  let showEra = (value?.start?.calendar.identifier === 'gregory' && value.start.era === 'BC') || (value?.end?.calendar.identifier === 'gregory' && value.end.era === 'BC');\n  let formatOpts = useMemo(() => ({\n    granularity,\n    timeZone: defaultTimeZone,\n    hideTimeZone: props.hideTimeZone,\n    hourCycle: props.hourCycle,\n    shouldForceLeadingZeros: props.shouldForceLeadingZeros,\n    showEra\n  }), [granularity, props.hourCycle, props.shouldForceLeadingZeros, defaultTimeZone, props.hideTimeZone, showEra]);\n\n  let {minValue, maxValue, isDateUnavailable} = props;\n  let builtinValidation = useMemo(() => getRangeValidationResult(\n    value,\n    minValue,\n    maxValue,\n    isDateUnavailable,\n    formatOpts\n  ), [value, minValue, maxValue, isDateUnavailable, formatOpts]);\n\n  let validation = useFormValidationState({\n    ...props,\n    value: controlledValue as RangeValue<MappedDateValue<T>> | null,\n    name: useMemo(() => [props.startName, props.endName].filter(n => n != null), [props.startName, props.endName]),\n    builtinValidation\n  });\n\n  let isValueInvalid = validation.displayValidation.isInvalid;\n  let validationState: ValidationState | null = props.validationState || (isValueInvalid ? 'invalid' : null);\n\n  return {\n    ...validation,\n    value,\n    setValue,\n    dateRange,\n    timeRange,\n    granularity,\n    hasTime,\n    setDate(part, date) {\n      if (part === 'start') {\n        setDateRange({start: date, end: dateRange?.end ?? null});\n      } else {\n        setDateRange({start: dateRange?.start ?? null, end: date});\n      }\n    },\n    setTime(part, time) {\n      if (part === 'start') {\n        setTimeRange({start: time, end: timeRange?.end ?? null});\n      } else {\n        setTimeRange({start: timeRange?.start ?? null, end: time});\n      }\n    },\n    setDateTime(part, dateTime) {\n      if (part === 'start') {\n        setValue({start: dateTime, end: value?.end ?? null});\n      } else {\n        setValue({start: value?.start ?? null, end: dateTime});\n      }\n    },\n    setDateRange,\n    setTimeRange,\n    ...overlayState,\n    setOpen(isOpen) {\n      // Commit the selected date range when the calendar is closed. Use a placeholder time if one wasn't set.\n      // If only the time range was set and not the date range, don't commit. The state will be preserved until\n      // the user opens the popover again.\n      if (!isOpen && !(value?.start && value?.end) && isCompleteRange(dateRange) && hasTime) {\n        commitValue(dateRange, {\n          start: timeRange?.start || getPlaceholderTime(props.placeholderValue),\n          end: timeRange?.end || getPlaceholderTime(props.placeholderValue)\n        });\n      }\n\n      overlayState.setOpen(isOpen);\n    },\n    validationState,\n    isInvalid: isValueInvalid,\n    formatValue(locale, fieldOptions) {\n      if (!value || !value.start || !value.end) {\n        return null;\n      }\n\n      let startTimeZone = 'timeZone' in value.start ? value.start.timeZone : undefined;\n      let startGranularity = props.granularity || (value.start && 'minute' in value.start ? 'minute' : 'day');\n      let endTimeZone = 'timeZone' in value.end ? value.end.timeZone : undefined;\n      let endGranularity = props.granularity || (value.end && 'minute' in value.end ? 'minute' : 'day');\n\n      let startOptions = getFormatOptions(fieldOptions, {\n        granularity: startGranularity,\n        timeZone: startTimeZone,\n        hideTimeZone: props.hideTimeZone,\n        hourCycle: props.hourCycle,\n        showEra: (value.start.calendar.identifier === 'gregory' && value.start.era === 'BC') ||\n          (value.end.calendar.identifier === 'gregory' && value.end.era === 'BC')\n      });\n\n      let startDate = value.start.toDate(startTimeZone || 'UTC');\n      let endDate = value.end.toDate(endTimeZone || 'UTC');\n\n      let startFormatter = new DateFormatter(locale, startOptions);\n      let endFormatter: Intl.DateTimeFormat;\n      if (startTimeZone === endTimeZone && startGranularity === endGranularity && value.start.compare(value.end) !== 0) {\n        // Use formatRange, as it results in shorter output when some of the fields\n        // are shared between the start and end dates (e.g. the same month).\n        // Formatting will fail if the end date is before the start date. Fall back below when that happens.\n        try {\n          let parts = startFormatter.formatRangeToParts(startDate, endDate);\n\n          // Find the separator between the start and end date. This is determined\n          // by finding the last shared literal before the end range.\n          let separatorIndex = -1;\n          for (let i = 0; i < parts.length; i++) {\n            let part = parts[i];\n            if (part.source === 'shared' && part.type === 'literal') {\n              separatorIndex = i;\n            } else if (part.source === 'endRange') {\n              break;\n            }\n          }\n\n          // Now we can combine the parts into start and end strings.\n          let start = '';\n          let end = '';\n          for (let i = 0; i < parts.length; i++) {\n            if (i < separatorIndex) {\n              start += parts[i].value;\n            } else if (i > separatorIndex) {\n              end += parts[i].value;\n            }\n          }\n\n          return {start, end};\n        } catch {\n          // ignore\n        }\n\n        endFormatter = startFormatter;\n      } else {\n        let endOptions = getFormatOptions(fieldOptions, {\n          granularity: endGranularity,\n          timeZone: endTimeZone,\n          hideTimeZone: props.hideTimeZone,\n          hourCycle: props.hourCycle\n        });\n\n        endFormatter = new DateFormatter(locale, endOptions);\n      }\n\n      return {\n        start: startFormatter.format(startDate),\n        end: endFormatter.format(endDate)\n      };\n    },\n    getDateFormatter(locale, formatOptions: FormatterOptions) {\n      let newOptions = {...formatOpts, ...formatOptions};\n      let newFormatOptions = getFormatOptions({}, newOptions);\n      return new DateFormatter(locale, newFormatOptions);\n    }\n  };\n}\n\nfunction isCompleteRange<T>(value: RangeValue<T | null> | null): value is RangeValue<T> {\n  return value?.start != null && value.end != null;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}