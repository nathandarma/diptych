{"ast":null,"code":"import { DOMLayoutDelegate as $kbsd1$DOMLayoutDelegate } from \"@react-aria/selection\";\nimport { getChildNodes as $kbsd1$getChildNodes, getLastItem as $kbsd1$getLastItem, getFirstItem as $kbsd1$getFirstItem, getNthItem as $kbsd1$getNthItem } from \"@react-stately/collections\";\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nclass $d1c300d9c497e402$export$de9feff04fda126e {\n  isCell(node) {\n    return node.type === 'cell';\n  }\n  isRow(node) {\n    return node.type === 'row' || node.type === 'item';\n  }\n  isDisabled(item) {\n    var _item_props;\n    return this.disabledBehavior === 'all' && (((_item_props = item.props) === null || _item_props === void 0 ? void 0 : _item_props.isDisabled) || this.disabledKeys.has(item.key));\n  }\n  findPreviousKey(fromKey, pred) {\n    let key = fromKey != null ? this.collection.getKeyBefore(fromKey) : this.collection.getLastKey();\n    while (key != null) {\n      let item = this.collection.getItem(key);\n      if (!item) return null;\n      if (!this.isDisabled(item) && (!pred || pred(item))) return key;\n      key = this.collection.getKeyBefore(key);\n    }\n    return null;\n  }\n  findNextKey(fromKey, pred) {\n    let key = fromKey != null ? this.collection.getKeyAfter(fromKey) : this.collection.getFirstKey();\n    while (key != null) {\n      let item = this.collection.getItem(key);\n      if (!item) return null;\n      if (!this.isDisabled(item) && (!pred || pred(item))) return key;\n      key = this.collection.getKeyAfter(key);\n      if (key == null) return null;\n    }\n    return null;\n  }\n  getKeyForItemInRowByIndex(key, index = 0) {\n    if (index < 0) return null;\n    let item = this.collection.getItem(key);\n    if (!item) return null;\n    let i = 0;\n    for (let child of (0, $kbsd1$getChildNodes)(item, this.collection)) {\n      var _child_key;\n      if (child.colSpan && child.colSpan + i > index) return (_child_key = child.key) !== null && _child_key !== void 0 ? _child_key : null;\n      if (child.colSpan) i = i + child.colSpan - 1;\n      var _child_key1;\n      if (i === index) return (_child_key1 = child.key) !== null && _child_key1 !== void 0 ? _child_key1 : null;\n      i++;\n    }\n    return null;\n  }\n  getKeyBelow(fromKey) {\n    let key = fromKey;\n    let startItem = this.collection.getItem(key);\n    if (!startItem) return null;\n    var _startItem_parentKey;\n    // If focus was on a cell, start searching from the parent row\n    if (this.isCell(startItem)) key = (_startItem_parentKey = startItem.parentKey) !== null && _startItem_parentKey !== void 0 ? _startItem_parentKey : null;\n    if (key == null) return null;\n    // Find the next item\n    key = this.findNextKey(key, item => item.type === 'item');\n    if (key != null) {\n      // If focus was on a cell, focus the cell with the same index in the next row.\n      if (this.isCell(startItem)) {\n        let startIndex = startItem.colIndex ? startItem.colIndex : startItem.index;\n        return this.getKeyForItemInRowByIndex(key, startIndex);\n      }\n      // Otherwise, focus the next row\n      if (this.focusMode === 'row') return key;\n    }\n    return null;\n  }\n  getKeyAbove(fromKey) {\n    let key = fromKey;\n    let startItem = this.collection.getItem(key);\n    if (!startItem) return null;\n    var _startItem_parentKey;\n    // If focus is on a cell, start searching from the parent row\n    if (this.isCell(startItem)) key = (_startItem_parentKey = startItem.parentKey) !== null && _startItem_parentKey !== void 0 ? _startItem_parentKey : null;\n    if (key == null) return null;\n    // Find the previous item\n    key = this.findPreviousKey(key, item => item.type === 'item');\n    if (key != null) {\n      // If focus was on a cell, focus the cell with the same index in the previous row.\n      if (this.isCell(startItem)) {\n        let startIndex = startItem.colIndex ? startItem.colIndex : startItem.index;\n        return this.getKeyForItemInRowByIndex(key, startIndex);\n      }\n      // Otherwise, focus the previous row\n      if (this.focusMode === 'row') return key;\n    }\n    return null;\n  }\n  getKeyRightOf(key) {\n    let item = this.collection.getItem(key);\n    if (!item) return null;\n    // If focus is on a row, focus the first child cell.\n    if (this.isRow(item)) {\n      var _getLastItem, _getFirstItem;\n      let children = (0, $kbsd1$getChildNodes)(item, this.collection);\n      var _ref;\n      return (_ref = this.direction === 'rtl' ? (_getLastItem = (0, $kbsd1$getLastItem)(children)) === null || _getLastItem === void 0 ? void 0 : _getLastItem.key : (_getFirstItem = (0, $kbsd1$getFirstItem)(children)) === null || _getFirstItem === void 0 ? void 0 : _getFirstItem.key) !== null && _ref !== void 0 ? _ref : null;\n    }\n    // If focus is on a cell, focus the next cell if any,\n    // otherwise focus the parent row.\n    if (this.isCell(item) && item.parentKey != null) {\n      let parent = this.collection.getItem(item.parentKey);\n      if (!parent) return null;\n      let children = (0, $kbsd1$getChildNodes)(parent, this.collection);\n      var _ref1;\n      let next = (_ref1 = this.direction === 'rtl' ? (0, $kbsd1$getNthItem)(children, item.index - 1) : (0, $kbsd1$getNthItem)(children, item.index + 1)) !== null && _ref1 !== void 0 ? _ref1 : null;\n      var _next_key;\n      if (next) return (_next_key = next.key) !== null && _next_key !== void 0 ? _next_key : null;\n      var _item_parentKey;\n      // focus row only if focusMode is set to row\n      if (this.focusMode === 'row') return (_item_parentKey = item.parentKey) !== null && _item_parentKey !== void 0 ? _item_parentKey : null;\n      var _ref2;\n      return (_ref2 = this.direction === 'rtl' ? this.getFirstKey(key) : this.getLastKey(key)) !== null && _ref2 !== void 0 ? _ref2 : null;\n    }\n    return null;\n  }\n  getKeyLeftOf(key) {\n    let item = this.collection.getItem(key);\n    if (!item) return null;\n    // If focus is on a row, focus the last child cell.\n    if (this.isRow(item)) {\n      var _getFirstItem, _getLastItem;\n      let children = (0, $kbsd1$getChildNodes)(item, this.collection);\n      var _ref;\n      return (_ref = this.direction === 'rtl' ? (_getFirstItem = (0, $kbsd1$getFirstItem)(children)) === null || _getFirstItem === void 0 ? void 0 : _getFirstItem.key : (_getLastItem = (0, $kbsd1$getLastItem)(children)) === null || _getLastItem === void 0 ? void 0 : _getLastItem.key) !== null && _ref !== void 0 ? _ref : null;\n    }\n    // If focus is on a cell, focus the previous cell if any,\n    // otherwise focus the parent row.\n    if (this.isCell(item) && item.parentKey != null) {\n      let parent = this.collection.getItem(item.parentKey);\n      if (!parent) return null;\n      let children = (0, $kbsd1$getChildNodes)(parent, this.collection);\n      var _ref1;\n      let prev = (_ref1 = this.direction === 'rtl' ? (0, $kbsd1$getNthItem)(children, item.index + 1) : (0, $kbsd1$getNthItem)(children, item.index - 1)) !== null && _ref1 !== void 0 ? _ref1 : null;\n      var _prev_key;\n      if (prev) return (_prev_key = prev.key) !== null && _prev_key !== void 0 ? _prev_key : null;\n      var _item_parentKey;\n      // focus row only if focusMode is set to row\n      if (this.focusMode === 'row') return (_item_parentKey = item.parentKey) !== null && _item_parentKey !== void 0 ? _item_parentKey : null;\n      var _ref2;\n      return (_ref2 = this.direction === 'rtl' ? this.getLastKey(key) : this.getFirstKey(key)) !== null && _ref2 !== void 0 ? _ref2 : null;\n    }\n    return null;\n  }\n  getFirstKey(fromKey, global) {\n    let key = fromKey !== null && fromKey !== void 0 ? fromKey : null;\n    let item;\n    if (key != null) {\n      item = this.collection.getItem(key);\n      if (!item) return null;\n      // If global flag is not set, and a cell is currently focused,\n      // move focus to the first cell in the parent row.\n      if (this.isCell(item) && !global && item.parentKey != null) {\n        var _getFirstItem;\n        let parent = this.collection.getItem(item.parentKey);\n        if (!parent) return null;\n        var _getFirstItem_key;\n        return (_getFirstItem_key = (_getFirstItem = (0, $kbsd1$getFirstItem)((0, $kbsd1$getChildNodes)(parent, this.collection))) === null || _getFirstItem === void 0 ? void 0 : _getFirstItem.key) !== null && _getFirstItem_key !== void 0 ? _getFirstItem_key : null;\n      }\n    }\n    // Find the first row\n    key = this.findNextKey(undefined, item => item.type === 'item');\n    // If global flag is set (or if focus mode is cell), focus the first cell in the first row.\n    if (key != null && (item && this.isCell(item) && global || this.focusMode === 'cell')) {\n      var _getFirstItem1;\n      let item = this.collection.getItem(key);\n      if (!item) return null;\n      var _getFirstItem_key1;\n      key = (_getFirstItem_key1 = (_getFirstItem1 = (0, $kbsd1$getFirstItem)((0, $kbsd1$getChildNodes)(item, this.collection))) === null || _getFirstItem1 === void 0 ? void 0 : _getFirstItem1.key) !== null && _getFirstItem_key1 !== void 0 ? _getFirstItem_key1 : null;\n    }\n    // Otherwise, focus the row itself.\n    return key;\n  }\n  getLastKey(fromKey, global) {\n    let key = fromKey !== null && fromKey !== void 0 ? fromKey : null;\n    let item;\n    if (key != null) {\n      item = this.collection.getItem(key);\n      if (!item) return null;\n      // If global flag is not set, and a cell is currently focused,\n      // move focus to the last cell in the parent row.\n      if (this.isCell(item) && !global && item.parentKey != null) {\n        var _getLastItem;\n        let parent = this.collection.getItem(item.parentKey);\n        if (!parent) return null;\n        let children = (0, $kbsd1$getChildNodes)(parent, this.collection);\n        var _getLastItem_key;\n        return (_getLastItem_key = (_getLastItem = (0, $kbsd1$getLastItem)(children)) === null || _getLastItem === void 0 ? void 0 : _getLastItem.key) !== null && _getLastItem_key !== void 0 ? _getLastItem_key : null;\n      }\n    }\n    // Find the last row\n    key = this.findPreviousKey(undefined, item => item.type === 'item');\n    // If global flag is set (or if focus mode is cell), focus the last cell in the last row.\n    if (key != null && (item && this.isCell(item) && global || this.focusMode === 'cell')) {\n      var _getLastItem1;\n      let item = this.collection.getItem(key);\n      if (!item) return null;\n      let children = (0, $kbsd1$getChildNodes)(item, this.collection);\n      var _getLastItem_key1;\n      key = (_getLastItem_key1 = (_getLastItem1 = (0, $kbsd1$getLastItem)(children)) === null || _getLastItem1 === void 0 ? void 0 : _getLastItem1.key) !== null && _getLastItem_key1 !== void 0 ? _getLastItem_key1 : null;\n    }\n    // Otherwise, focus the row itself.\n    return key;\n  }\n  getKeyPageAbove(fromKey) {\n    let key = fromKey;\n    let itemRect = this.layoutDelegate.getItemRect(key);\n    if (!itemRect) return null;\n    let pageY = Math.max(0, itemRect.y + itemRect.height - this.layoutDelegate.getVisibleRect().height);\n    while (itemRect && itemRect.y > pageY && key != null) {\n      var _this_getKeyAbove;\n      key = (_this_getKeyAbove = this.getKeyAbove(key)) !== null && _this_getKeyAbove !== void 0 ? _this_getKeyAbove : null;\n      if (key == null) break;\n      itemRect = this.layoutDelegate.getItemRect(key);\n    }\n    return key;\n  }\n  getKeyPageBelow(fromKey) {\n    let key = fromKey;\n    let itemRect = this.layoutDelegate.getItemRect(key);\n    if (!itemRect) return null;\n    let pageHeight = this.layoutDelegate.getVisibleRect().height;\n    let pageY = Math.min(this.layoutDelegate.getContentSize().height, itemRect.y + pageHeight);\n    while (itemRect && itemRect.y + itemRect.height < pageY) {\n      let nextKey = this.getKeyBelow(key);\n      // If nextKey is undefined, we've reached the last row already\n      if (nextKey == null) break;\n      itemRect = this.layoutDelegate.getItemRect(nextKey);\n      key = nextKey;\n    }\n    return key;\n  }\n  getKeyForSearch(search, fromKey) {\n    let key = fromKey !== null && fromKey !== void 0 ? fromKey : null;\n    if (!this.collator) return null;\n    let collection = this.collection;\n    key = fromKey !== null && fromKey !== void 0 ? fromKey : this.getFirstKey();\n    if (key == null) return null;\n    // If the starting key is a cell, search from its parent row.\n    let startItem = collection.getItem(key);\n    if (!startItem) return null;\n    var _startItem_parentKey;\n    if (startItem.type === 'cell') key = (_startItem_parentKey = startItem.parentKey) !== null && _startItem_parentKey !== void 0 ? _startItem_parentKey : null;\n    let hasWrapped = false;\n    while (key != null) {\n      let item = collection.getItem(key);\n      if (!item) return null;\n      // check row text value for match\n      if (item.textValue) {\n        let substring = item.textValue.slice(0, search.length);\n        if (this.collator.compare(substring, search) === 0) {\n          var _getFirstItem;\n          var _getFirstItem_key;\n          if (this.isRow(item) && this.focusMode === 'cell') return (_getFirstItem_key = (_getFirstItem = (0, $kbsd1$getFirstItem)((0, $kbsd1$getChildNodes)(item, this.collection))) === null || _getFirstItem === void 0 ? void 0 : _getFirstItem.key) !== null && _getFirstItem_key !== void 0 ? _getFirstItem_key : null;\n          return item.key;\n        }\n      }\n      key = this.findNextKey(key, item => item.type === 'item');\n      // Wrap around when reaching the end of the collection\n      if (key == null && !hasWrapped) {\n        key = this.getFirstKey();\n        hasWrapped = true;\n      }\n    }\n    return null;\n  }\n  constructor(options) {\n    this.collection = options.collection;\n    this.disabledKeys = options.disabledKeys;\n    this.disabledBehavior = options.disabledBehavior || 'all';\n    this.direction = options.direction;\n    this.collator = options.collator;\n    if (!options.layout && !options.ref) throw new Error('Either a layout or a ref must be specified.');\n    this.layoutDelegate = options.layoutDelegate || (options.layout ? new $d1c300d9c497e402$var$DeprecatedLayoutDelegate(options.layout) : new (0, $kbsd1$DOMLayoutDelegate)(options.ref));\n    this.focusMode = options.focusMode || 'row';\n  }\n}\nclass $d1c300d9c497e402$var$DeprecatedLayoutDelegate {\n  getContentSize() {\n    return this.layout.getContentSize();\n  }\n  getItemRect(key) {\n    var _this_layout_getLayoutInfo;\n    return ((_this_layout_getLayoutInfo = this.layout.getLayoutInfo(key)) === null || _this_layout_getLayoutInfo === void 0 ? void 0 : _this_layout_getLayoutInfo.rect) || null;\n  }\n  getVisibleRect() {\n    return this.layout.virtualizer.visibleRect;\n  }\n  constructor(layout) {\n    this.layout = layout;\n  }\n}\nexport { $d1c300d9c497e402$export$de9feff04fda126e as GridKeyboardDelegate };","map":{"version":3,"names":["$d1c300d9c497e402$export$de9feff04fda126e","isCell","node","type","isRow","isDisabled","item","_item_props","disabledBehavior","props","disabledKeys","has","key","findPreviousKey","fromKey","pred","collection","getKeyBefore","getLastKey","getItem","findNextKey","getKeyAfter","getFirstKey","getKeyForItemInRowByIndex","index","i","child","$kbsd1$getChildNodes","_child_key","colSpan","_child_key1","getKeyBelow","startItem","_startItem_parentKey","parentKey","startIndex","colIndex","focusMode","getKeyAbove","getKeyRightOf","_getLastItem","_getFirstItem","children","_ref","direction","$kbsd1$getLastItem","$kbsd1$getFirstItem","parent","_ref1","next","$kbsd1$getNthItem","_next_key","_item_parentKey","_ref2","getKeyLeftOf","prev","_prev_key","global","_getFirstItem_key","undefined","_getFirstItem1","_getFirstItem_key1","_getLastItem_key","_getLastItem1","_getLastItem_key1","getKeyPageAbove","itemRect","layoutDelegate","getItemRect","pageY","Math","max","y","height","getVisibleRect","_this_getKeyAbove","getKeyPageBelow","pageHeight","min","getContentSize","nextKey","getKeyForSearch","search","collator","hasWrapped","textValue","substring","slice","length","compare","constructor","options","layout","ref","Error","$d1c300d9c497e402$var$DeprecatedLayoutDelegate","$kbsd1$DOMLayoutDelegate","_this_layout_getLayoutInfo","getLayoutInfo","rect","virtualizer","visibleRect"],"sources":["/Users/nathandarma/Documents/App Testing/Diptych/diptych/node_modules/@react-aria/grid/dist/packages/@react-aria/grid/src/GridKeyboardDelegate.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Direction, DisabledBehavior, Key, KeyboardDelegate, LayoutDelegate, Node, Rect, RefObject, Size} from '@react-types/shared';\nimport {DOMLayoutDelegate} from '@react-aria/selection';\nimport {getChildNodes, getFirstItem, getLastItem, getNthItem} from '@react-stately/collections';\nimport {GridCollection, GridNode} from '@react-types/grid';\n\nexport interface GridKeyboardDelegateOptions<C> {\n  collection: C,\n  disabledKeys: Set<Key>,\n  disabledBehavior?: DisabledBehavior,\n  ref?: RefObject<HTMLElement | null>,\n  direction: Direction,\n  collator?: Intl.Collator,\n  layoutDelegate?: LayoutDelegate,\n  /** @deprecated - Use layoutDelegate instead. */\n  layout?: DeprecatedLayout,\n  focusMode?: 'row' | 'cell'\n}\n\nexport class GridKeyboardDelegate<T, C extends GridCollection<T>> implements KeyboardDelegate {\n  collection: C;\n  protected disabledKeys: Set<Key>;\n  protected disabledBehavior: DisabledBehavior;\n  protected direction: Direction;\n  protected collator: Intl.Collator | undefined;\n  protected layoutDelegate: LayoutDelegate;\n  protected focusMode;\n\n  constructor(options: GridKeyboardDelegateOptions<C>) {\n    this.collection = options.collection;\n    this.disabledKeys = options.disabledKeys;\n    this.disabledBehavior = options.disabledBehavior || 'all';\n    this.direction = options.direction;\n    this.collator = options.collator;\n    if (!options.layout && !options.ref) {\n      throw new Error('Either a layout or a ref must be specified.');\n    }\n    this.layoutDelegate = options.layoutDelegate || (options.layout ? new DeprecatedLayoutDelegate(options.layout) : new DOMLayoutDelegate(options.ref!));\n    this.focusMode = options.focusMode || 'row';\n  }\n\n  protected isCell(node: Node<T>): boolean {\n    return node.type === 'cell';\n  }\n\n  protected isRow(node: Node<T>): boolean {\n    return node.type === 'row' || node.type === 'item';\n  }\n\n  private isDisabled(item: Node<unknown>) {\n    return this.disabledBehavior === 'all' && (item.props?.isDisabled || this.disabledKeys.has(item.key));\n  }\n\n  protected findPreviousKey(fromKey?: Key, pred?: (item: Node<T>) => boolean): Key | null {\n    let key = fromKey != null\n      ? this.collection.getKeyBefore(fromKey)\n      : this.collection.getLastKey();\n\n    while (key != null) {\n      let item = this.collection.getItem(key);\n      if (!item) {\n        return null;\n      }\n      if (!this.isDisabled(item) && (!pred || pred(item))) {\n        return key;\n      }\n\n      key = this.collection.getKeyBefore(key);\n    }\n    return null;\n  }\n\n  protected findNextKey(fromKey?: Key, pred?: (item: Node<T>) => boolean): Key | null {\n    let key = fromKey != null\n      ? this.collection.getKeyAfter(fromKey)\n      : this.collection.getFirstKey();\n\n    while (key != null) {\n      let item = this.collection.getItem(key);\n      if (!item) {\n        return null;\n      }\n      if (!this.isDisabled(item) && (!pred || pred(item))) {\n        return key;\n      }\n\n      key = this.collection.getKeyAfter(key);\n      if (key == null) {\n        return null;\n      }\n    }\n    return null;\n  }\n\n  protected getKeyForItemInRowByIndex(key: Key, index: number = 0): Key | null {\n    if (index < 0) {\n      return null;\n    }\n\n    let item = this.collection.getItem(key);\n    if (!item) {\n      return null;\n    }\n\n    let i = 0;\n    for (let child of getChildNodes(item, this.collection) as Iterable<GridNode<T>>) {\n      if (child.colSpan && child.colSpan + i > index) {\n        return child.key ?? null;\n      }\n\n      if (child.colSpan) {\n        i = i + child.colSpan - 1;\n      }\n\n      if (i === index) {\n        return child.key ?? null;\n      }\n\n      i++;\n    }\n    return null;\n  }\n\n  getKeyBelow(fromKey: Key): Key | null {\n    let key: Key | null = fromKey;\n    let startItem = this.collection.getItem(key);\n    if (!startItem) {\n      return null;\n    }\n\n    // If focus was on a cell, start searching from the parent row\n    if (this.isCell(startItem)) {\n      key = startItem.parentKey ?? null;\n    }\n    if (key == null) {\n      return null;\n    }\n\n    // Find the next item\n    key = this.findNextKey(key, (item => item.type === 'item'));\n    if (key != null) {\n      // If focus was on a cell, focus the cell with the same index in the next row.\n      if (this.isCell(startItem)) {\n        let startIndex = startItem.colIndex ? startItem.colIndex : startItem.index;\n        return this.getKeyForItemInRowByIndex(key, startIndex);\n      }\n\n      // Otherwise, focus the next row\n      if (this.focusMode === 'row') {\n        return key;\n      }\n    }\n    return null;\n  }\n\n  getKeyAbove(fromKey: Key): Key | null {\n    let key: Key | null = fromKey;\n    let startItem = this.collection.getItem(key);\n    if (!startItem) {\n      return null;\n    }\n\n    // If focus is on a cell, start searching from the parent row\n    if (this.isCell(startItem)) {\n      key = startItem.parentKey ?? null;\n    }\n    if (key == null) {\n      return null;\n    }\n\n    // Find the previous item\n    key = this.findPreviousKey(key, item => item.type === 'item');\n    if (key != null) {\n      // If focus was on a cell, focus the cell with the same index in the previous row.\n      if (this.isCell(startItem)) {\n        let startIndex = startItem.colIndex ? startItem.colIndex : startItem.index;\n        return this.getKeyForItemInRowByIndex(key, startIndex);\n      }\n\n      // Otherwise, focus the previous row\n      if (this.focusMode === 'row') {\n        return key;\n      }\n    }\n    return null;\n  }\n\n  getKeyRightOf(key: Key): Key | null {\n    let item = this.collection.getItem(key);\n    if (!item) {\n      return null;\n    }\n\n    // If focus is on a row, focus the first child cell.\n    if (this.isRow(item)) {\n      let children = getChildNodes(item, this.collection);\n      return (this.direction === 'rtl'\n        ? getLastItem(children)?.key\n        : getFirstItem(children)?.key) ?? null;\n    }\n\n    // If focus is on a cell, focus the next cell if any,\n    // otherwise focus the parent row.\n    if (this.isCell(item) && item.parentKey != null) {\n      let parent = this.collection.getItem(item.parentKey);\n      if (!parent) {\n        return null;\n      }\n      let children = getChildNodes(parent, this.collection);\n      let next = (this.direction === 'rtl'\n        ? getNthItem(children, item.index - 1)\n        : getNthItem(children, item.index + 1)) ?? null;\n\n      if (next) {\n        return next.key ?? null;\n      }\n\n      // focus row only if focusMode is set to row\n      if (this.focusMode === 'row') {\n        return item.parentKey ?? null;\n      }\n\n      return (this.direction === 'rtl' ? this.getFirstKey(key) : this.getLastKey(key)) ?? null;\n    }\n    return null;\n  }\n\n  getKeyLeftOf(key: Key): Key | null {\n    let item = this.collection.getItem(key);\n    if (!item) {\n      return null;\n    }\n\n    // If focus is on a row, focus the last child cell.\n    if (this.isRow(item)) {\n      let children = getChildNodes(item, this.collection);\n      return (this.direction === 'rtl'\n        ? getFirstItem(children)?.key\n        : getLastItem(children)?.key) ?? null;\n    }\n\n    // If focus is on a cell, focus the previous cell if any,\n    // otherwise focus the parent row.\n    if (this.isCell(item) && item.parentKey != null) {\n      let parent = this.collection.getItem(item.parentKey);\n      if (!parent) {\n        return null;\n      }\n      let children = getChildNodes(parent, this.collection);\n      let prev = (this.direction === 'rtl'\n        ? getNthItem(children, item.index + 1)\n        : getNthItem(children, item.index - 1)) ?? null;\n\n      if (prev) {\n        return prev.key ?? null;\n      }\n\n      // focus row only if focusMode is set to row\n      if (this.focusMode === 'row') {\n        return item.parentKey ?? null;\n      }\n\n      return (this.direction === 'rtl' ? this.getLastKey(key) : this.getFirstKey(key)) ?? null;\n    }\n    return null;\n  }\n\n  getFirstKey(fromKey?: Key, global?: boolean): Key | null {\n    let key: Key | null = fromKey ?? null;\n    let item: Node<T> | undefined | null;\n    if (key != null) {\n      item = this.collection.getItem(key);\n      if (!item) {\n        return null;\n      }\n\n      // If global flag is not set, and a cell is currently focused,\n      // move focus to the first cell in the parent row.\n      if (this.isCell(item) && !global && item.parentKey != null) {\n        let parent = this.collection.getItem(item.parentKey);\n        if (!parent) {\n          return null;\n        }\n        return getFirstItem(getChildNodes(parent, this.collection))?.key ?? null;\n      }\n    }\n\n    // Find the first row\n    key = this.findNextKey(undefined, item => item.type === 'item');\n\n    // If global flag is set (or if focus mode is cell), focus the first cell in the first row.\n    if (key != null && ((item && this.isCell(item) && global) || this.focusMode === 'cell')) {\n      let item = this.collection.getItem(key);\n      if (!item) {\n        return null;\n      }\n      key = getFirstItem(getChildNodes(item, this.collection))?.key ?? null;\n    }\n\n    // Otherwise, focus the row itself.\n    return key;\n  }\n\n  getLastKey(fromKey?: Key, global?: boolean): Key | null {\n    let key: Key | null = fromKey ?? null;\n    let item: Node<T> | undefined | null;\n    if (key != null) {\n      item = this.collection.getItem(key);\n      if (!item) {\n        return null;\n      }\n\n      // If global flag is not set, and a cell is currently focused,\n      // move focus to the last cell in the parent row.\n      if (this.isCell(item) && !global && item.parentKey != null) {\n        let parent = this.collection.getItem(item.parentKey);\n        if (!parent) {\n          return null;\n        }\n        let children = getChildNodes(parent, this.collection);\n        return getLastItem(children)?.key ?? null;\n      }\n    }\n\n    // Find the last row\n    key = this.findPreviousKey(undefined, item => item.type === 'item');\n\n    // If global flag is set (or if focus mode is cell), focus the last cell in the last row.\n    if (key != null && ((item && this.isCell(item) && global) || this.focusMode === 'cell')) {\n      let item = this.collection.getItem(key);\n      if (!item) {\n        return null;\n      }\n      let children = getChildNodes(item, this.collection);\n      key = getLastItem(children)?.key ?? null;\n    }\n\n    // Otherwise, focus the row itself.\n    return key;\n  }\n\n  getKeyPageAbove(fromKey: Key): Key | null {\n    let key: Key | null = fromKey;\n    let itemRect = this.layoutDelegate.getItemRect(key);\n    if (!itemRect) {\n      return null;\n    }\n\n    let pageY = Math.max(0, itemRect.y + itemRect.height - this.layoutDelegate.getVisibleRect().height);\n\n    while (itemRect && itemRect.y > pageY && key != null) {\n      key = this.getKeyAbove(key) ?? null;\n      if (key == null) {\n        break;\n      }\n      itemRect = this.layoutDelegate.getItemRect(key);\n    }\n\n    return key;\n  }\n\n  getKeyPageBelow(fromKey: Key): Key | null {\n    let key: Key | null = fromKey;\n    let itemRect = this.layoutDelegate.getItemRect(key);\n\n    if (!itemRect) {\n      return null;\n    }\n\n    let pageHeight = this.layoutDelegate.getVisibleRect().height;\n    let pageY = Math.min(this.layoutDelegate.getContentSize().height, itemRect.y + pageHeight);\n\n    while (itemRect && (itemRect.y + itemRect.height) < pageY) {\n      let nextKey = this.getKeyBelow(key);\n      // If nextKey is undefined, we've reached the last row already\n      if (nextKey == null) {\n        break;\n      }\n\n      itemRect = this.layoutDelegate.getItemRect(nextKey);\n      key = nextKey;\n    }\n\n    return key;\n  }\n\n  getKeyForSearch(search: string, fromKey?: Key): Key | null {\n    let key: Key | null = fromKey ?? null;\n    if (!this.collator) {\n      return null;\n    }\n\n    let collection = this.collection;\n    key = fromKey ?? this.getFirstKey();\n    if (key == null) {\n      return null;\n    }\n\n    // If the starting key is a cell, search from its parent row.\n    let startItem = collection.getItem(key);\n    if (!startItem) {\n      return null;\n    }\n    if (startItem.type === 'cell') {\n      key = startItem.parentKey ?? null;\n    }\n\n    let hasWrapped = false;\n    while (key != null) {\n      let item = collection.getItem(key);\n      if (!item) {\n        return null;\n      }\n\n      // check row text value for match\n      if (item.textValue) {\n        let substring = item.textValue.slice(0, search.length);\n        if (this.collator.compare(substring, search) === 0) {\n          if (this.isRow(item) && this.focusMode === 'cell') {\n            return getFirstItem(getChildNodes(item, this.collection))?.key ?? null;\n          }\n\n          return item.key;\n        }\n      }\n\n      key = this.findNextKey(key, item => item.type === 'item');\n\n      // Wrap around when reaching the end of the collection\n      if (key == null && !hasWrapped) {\n        key = this.getFirstKey();\n        hasWrapped = true;\n      }\n    }\n\n    return null;\n  }\n}\n\n/* Backward compatibility for old Virtualizer Layout interface. */\ninterface DeprecatedLayout {\n  getLayoutInfo(key: Key): DeprecatedLayoutInfo,\n  getContentSize(): Size,\n  virtualizer: DeprecatedVirtualizer\n}\n\ninterface DeprecatedLayoutInfo {\n  rect: Rect\n}\n\ninterface DeprecatedVirtualizer {\n  visibleRect: Rect\n}\n\nclass DeprecatedLayoutDelegate implements LayoutDelegate {\n  layout: DeprecatedLayout;\n\n  constructor(layout: DeprecatedLayout) {\n    this.layout = layout;\n  }\n\n  getContentSize(): Size {\n    return this.layout.getContentSize();\n  }\n\n  getItemRect(key: Key): Rect | null {\n    return this.layout.getLayoutInfo(key)?.rect || null;\n  }\n\n  getVisibleRect(): Rect {\n    return this.layout.virtualizer.visibleRect;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}