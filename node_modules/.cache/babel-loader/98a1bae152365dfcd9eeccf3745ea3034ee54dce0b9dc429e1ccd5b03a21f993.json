{"ast":null,"code":"import { gridMap as $1af922eb41e03c8f$export$e6235c0d09b995d0 } from \"./utils.mjs\";\nimport { focusSafely as $j4Qbl$focusSafely, isFocusVisible as $j4Qbl$isFocusVisible } from \"@react-aria/interactions\";\nimport { getFocusableTreeWalker as $j4Qbl$getFocusableTreeWalker } from \"@react-aria/focus\";\nimport { scrollIntoViewport as $j4Qbl$scrollIntoViewport, getScrollParent as $j4Qbl$getScrollParent, mergeProps as $j4Qbl$mergeProps } from \"@react-aria/utils\";\nimport { useRef as $j4Qbl$useRef } from \"react\";\nimport { useLocale as $j4Qbl$useLocale } from \"@react-aria/i18n\";\nimport { useSelectableItem as $j4Qbl$useSelectableItem } from \"@react-aria/selection\";\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nfunction $ab90dcbc1b5466d0$export$c7e10bfc0c59f67c(props, state, ref) {\n  let {\n    node: node,\n    isVirtualized: isVirtualized,\n    focusMode = 'child',\n    shouldSelectOnPressUp: shouldSelectOnPressUp,\n    onAction: onAction\n  } = props;\n  let {\n    direction: direction\n  } = (0, $j4Qbl$useLocale)();\n  let {\n    keyboardDelegate: keyboardDelegate,\n    actions: {\n      onCellAction: onCellAction\n    }\n  } = (0, $1af922eb41e03c8f$export$e6235c0d09b995d0).get(state);\n  // We need to track the key of the item at the time it was last focused so that we force\n  // focus to go to the item when the DOM node is reused for a different item in a virtualizer.\n  let keyWhenFocused = (0, $j4Qbl$useRef)(null);\n  // Handles focusing the cell. If there is a focusable child,\n  // it is focused, otherwise the cell itself is focused.\n  let focus = () => {\n    if (ref.current) {\n      let treeWalker = (0, $j4Qbl$getFocusableTreeWalker)(ref.current);\n      if (focusMode === 'child') {\n        // If focus is already on a focusable child within the cell, early return so we don't shift focus\n        if (ref.current.contains(document.activeElement) && ref.current !== document.activeElement) return;\n        let focusable = state.selectionManager.childFocusStrategy === 'last' ? $ab90dcbc1b5466d0$var$last(treeWalker) : treeWalker.firstChild();\n        if (focusable) {\n          (0, $j4Qbl$focusSafely)(focusable);\n          return;\n        }\n      }\n      if (keyWhenFocused.current != null && node.key !== keyWhenFocused.current || !ref.current.contains(document.activeElement)) (0, $j4Qbl$focusSafely)(ref.current);\n    }\n  };\n  let {\n    itemProps: itemProps,\n    isPressed: isPressed\n  } = (0, $j4Qbl$useSelectableItem)({\n    selectionManager: state.selectionManager,\n    key: node.key,\n    ref: ref,\n    isVirtualized: isVirtualized,\n    focus: focus,\n    shouldSelectOnPressUp: shouldSelectOnPressUp,\n    onAction: onCellAction ? () => onCellAction(node.key) : onAction,\n    isDisabled: state.collection.size === 0\n  });\n  let onKeyDownCapture = e => {\n    if (!e.currentTarget.contains(e.target) || state.isKeyboardNavigationDisabled || !ref.current || !document.activeElement) return;\n    let walker = (0, $j4Qbl$getFocusableTreeWalker)(ref.current);\n    walker.currentNode = document.activeElement;\n    switch (e.key) {\n      case 'ArrowLeft':\n        {\n          // Find the next focusable element within the cell.\n          let focusable = direction === 'rtl' ? walker.nextNode() : walker.previousNode();\n          // Don't focus the cell itself if focusMode is \"child\"\n          if (focusMode === 'child' && focusable === ref.current) focusable = null;\n          e.preventDefault();\n          e.stopPropagation();\n          if (focusable) {\n            (0, $j4Qbl$focusSafely)(focusable);\n            (0, $j4Qbl$scrollIntoViewport)(focusable, {\n              containingElement: (0, $j4Qbl$getScrollParent)(ref.current)\n            });\n          } else {\n            var _keyboardDelegate_getKeyLeftOf;\n            // If there is no next focusable child, then move to the next cell to the left of this one.\n            // This will be handled by useSelectableCollection. However, if there is no cell to the left\n            // of this one, only one column, and the grid doesn't focus rows, then the next key will be the\n            // same as this one. In that case we need to handle focusing either the cell or the first/last\n            // child, depending on the focus mode.\n            let prev = (_keyboardDelegate_getKeyLeftOf = keyboardDelegate.getKeyLeftOf) === null || _keyboardDelegate_getKeyLeftOf === void 0 ? void 0 : _keyboardDelegate_getKeyLeftOf.call(keyboardDelegate, node.key);\n            if (prev !== node.key) {\n              var\n              // We prevent the capturing event from reaching children of the cell, e.g. pickers.\n              // We want arrow keys to navigate to the next cell instead. We need to re-dispatch\n              // the event from a higher parent so it still bubbles and gets handled by useSelectableCollection.\n              _ref_current_parentElement;\n              (_ref_current_parentElement = ref.current.parentElement) === null || _ref_current_parentElement === void 0 ? void 0 : _ref_current_parentElement.dispatchEvent(new KeyboardEvent(e.nativeEvent.type, e.nativeEvent));\n              break;\n            }\n            if (focusMode === 'cell' && direction === 'rtl') {\n              (0, $j4Qbl$focusSafely)(ref.current);\n              (0, $j4Qbl$scrollIntoViewport)(ref.current, {\n                containingElement: (0, $j4Qbl$getScrollParent)(ref.current)\n              });\n            } else {\n              walker.currentNode = ref.current;\n              focusable = direction === 'rtl' ? walker.firstChild() : $ab90dcbc1b5466d0$var$last(walker);\n              if (focusable) {\n                (0, $j4Qbl$focusSafely)(focusable);\n                (0, $j4Qbl$scrollIntoViewport)(focusable, {\n                  containingElement: (0, $j4Qbl$getScrollParent)(ref.current)\n                });\n              }\n            }\n          }\n          break;\n        }\n      case 'ArrowRight':\n        {\n          let focusable = direction === 'rtl' ? walker.previousNode() : walker.nextNode();\n          if (focusMode === 'child' && focusable === ref.current) focusable = null;\n          e.preventDefault();\n          e.stopPropagation();\n          if (focusable) {\n            (0, $j4Qbl$focusSafely)(focusable);\n            (0, $j4Qbl$scrollIntoViewport)(focusable, {\n              containingElement: (0, $j4Qbl$getScrollParent)(ref.current)\n            });\n          } else {\n            var _keyboardDelegate_getKeyRightOf;\n            let next = (_keyboardDelegate_getKeyRightOf = keyboardDelegate.getKeyRightOf) === null || _keyboardDelegate_getKeyRightOf === void 0 ? void 0 : _keyboardDelegate_getKeyRightOf.call(keyboardDelegate, node.key);\n            if (next !== node.key) {\n              var\n              // We prevent the capturing event from reaching children of the cell, e.g. pickers.\n              // We want arrow keys to navigate to the next cell instead. We need to re-dispatch\n              // the event from a higher parent so it still bubbles and gets handled by useSelectableCollection.\n              _ref_current_parentElement1;\n              (_ref_current_parentElement1 = ref.current.parentElement) === null || _ref_current_parentElement1 === void 0 ? void 0 : _ref_current_parentElement1.dispatchEvent(new KeyboardEvent(e.nativeEvent.type, e.nativeEvent));\n              break;\n            }\n            if (focusMode === 'cell' && direction === 'ltr') {\n              (0, $j4Qbl$focusSafely)(ref.current);\n              (0, $j4Qbl$scrollIntoViewport)(ref.current, {\n                containingElement: (0, $j4Qbl$getScrollParent)(ref.current)\n              });\n            } else {\n              walker.currentNode = ref.current;\n              focusable = direction === 'rtl' ? $ab90dcbc1b5466d0$var$last(walker) : walker.firstChild();\n              if (focusable) {\n                (0, $j4Qbl$focusSafely)(focusable);\n                (0, $j4Qbl$scrollIntoViewport)(focusable, {\n                  containingElement: (0, $j4Qbl$getScrollParent)(ref.current)\n                });\n              }\n            }\n          }\n          break;\n        }\n      case 'ArrowUp':\n      case 'ArrowDown':\n        // Prevent this event from reaching cell children, e.g. menu buttons. We want arrow keys to navigate\n        // to the cell above/below instead. We need to re-dispatch the event from a higher parent so it still\n        // bubbles and gets handled by useSelectableCollection.\n        if (!e.altKey && ref.current.contains(e.target)) {\n          var _ref_current_parentElement2;\n          e.stopPropagation();\n          e.preventDefault();\n          (_ref_current_parentElement2 = ref.current.parentElement) === null || _ref_current_parentElement2 === void 0 ? void 0 : _ref_current_parentElement2.dispatchEvent(new KeyboardEvent(e.nativeEvent.type, e.nativeEvent));\n        }\n        break;\n    }\n  };\n  // Grid cells can have focusable elements inside them. In this case, focus should\n  // be marshalled to that element rather than focusing the cell itself.\n  let onFocus = e => {\n    keyWhenFocused.current = node.key;\n    if (e.target !== ref.current) {\n      // useSelectableItem only handles setting the focused key when\n      // the focused element is the gridcell itself. We also want to\n      // set the focused key when a child element receives focus.\n      // If focus is currently visible (e.g. the user is navigating with the keyboard),\n      // then skip this. We want to restore focus to the previously focused row/cell\n      // in that case since the table should act like a single tab stop.\n      if (!(0, $j4Qbl$isFocusVisible)()) state.selectionManager.setFocusedKey(node.key);\n      return;\n    }\n    // If the cell itself is focused, wait a frame so that focus finishes propagatating\n    // up to the tree, and move focus to a focusable child if possible.\n    requestAnimationFrame(() => {\n      if (focusMode === 'child' && document.activeElement === ref.current) focus();\n    });\n  };\n  let gridCellProps = (0, $j4Qbl$mergeProps)(itemProps, {\n    role: 'gridcell',\n    onKeyDownCapture: onKeyDownCapture,\n    'aria-colspan': node.colSpan,\n    'aria-colindex': node.colIndex != null ? node.colIndex + 1 : undefined,\n    colSpan: isVirtualized ? undefined : node.colSpan,\n    onFocus: onFocus\n  });\n  var _node_colIndex;\n  if (isVirtualized) gridCellProps['aria-colindex'] = ((_node_colIndex = node.colIndex) !== null && _node_colIndex !== void 0 ? _node_colIndex : node.index) + 1; // aria-colindex is 1-based\n  // When pressing with a pointer and cell selection is not enabled, usePress will be applied to the\n  // row rather than the cell. However, when the row is draggable, usePress cannot preventDefault\n  // on pointer down, so the browser will try to focus the cell which has a tabIndex applied.\n  // To avoid this, remove the tabIndex from the cell briefly on pointer down.\n  if (shouldSelectOnPressUp && gridCellProps.tabIndex != null && gridCellProps.onPointerDown == null) gridCellProps.onPointerDown = e => {\n    let el = e.currentTarget;\n    let tabindex = el.getAttribute('tabindex');\n    el.removeAttribute('tabindex');\n    requestAnimationFrame(() => {\n      if (tabindex != null) el.setAttribute('tabindex', tabindex);\n    });\n  };\n  return {\n    gridCellProps: gridCellProps,\n    isPressed: isPressed\n  };\n}\nfunction $ab90dcbc1b5466d0$var$last(walker) {\n  let next = null;\n  let last = null;\n  do {\n    last = walker.lastChild();\n    if (last) next = last;\n  } while (last);\n  return next;\n}\nexport { $ab90dcbc1b5466d0$export$c7e10bfc0c59f67c as useGridCell };","map":{"version":3,"names":["$ab90dcbc1b5466d0$export$c7e10bfc0c59f67c","props","state","ref","node","isVirtualized","focusMode","shouldSelectOnPressUp","onAction","direction","$j4Qbl$useLocale","keyboardDelegate","actions","onCellAction","$1af922eb41e03c8f$export$e6235c0d09b995d0","get","keyWhenFocused","$j4Qbl$useRef","focus","current","treeWalker","$j4Qbl$getFocusableTreeWalker","contains","document","activeElement","focusable","selectionManager","childFocusStrategy","$ab90dcbc1b5466d0$var$last","firstChild","$j4Qbl$focusSafely","key","itemProps","isPressed","$j4Qbl$useSelectableItem","isDisabled","collection","size","onKeyDownCapture","e","currentTarget","target","isKeyboardNavigationDisabled","walker","currentNode","nextNode","previousNode","preventDefault","stopPropagation","$j4Qbl$scrollIntoViewport","containingElement","$j4Qbl$getScrollParent","_keyboardDelegate_getKeyLeftOf","prev","getKeyLeftOf","call","_ref_current_parentElement","parentElement","dispatchEvent","KeyboardEvent","nativeEvent","type","_keyboardDelegate_getKeyRightOf","next","getKeyRightOf","_ref_current_parentElement1","altKey","_ref_current_parentElement2","onFocus","$j4Qbl$isFocusVisible","setFocusedKey","requestAnimationFrame","gridCellProps","$j4Qbl$mergeProps","role","colSpan","colIndex","undefined","_node_colIndex","index","tabIndex","onPointerDown","el","tabindex","getAttribute","removeAttribute","setAttribute","last","lastChild"],"sources":["/Users/nathandarma/Documents/App Testing/Diptych/diptych/node_modules/@react-aria/grid/dist/packages/@react-aria/grid/src/useGridCell.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {DOMAttributes, FocusableElement, Key, RefObject} from '@react-types/shared';\nimport {focusSafely, isFocusVisible} from '@react-aria/interactions';\nimport {getFocusableTreeWalker} from '@react-aria/focus';\nimport {getScrollParent, mergeProps, scrollIntoViewport} from '@react-aria/utils';\nimport {GridCollection, GridNode} from '@react-types/grid';\nimport {gridMap} from './utils';\nimport {GridState} from '@react-stately/grid';\nimport {KeyboardEvent as ReactKeyboardEvent, useRef} from 'react';\nimport {useLocale} from '@react-aria/i18n';\nimport {useSelectableItem} from '@react-aria/selection';\n\nexport interface GridCellProps {\n  /** An object representing the grid cell. Contains all the relevant information that makes up the grid cell. */\n  node: GridNode<unknown>,\n  /** Whether the grid cell is contained in a virtual scroller. */\n  isVirtualized?: boolean,\n  /** Whether the cell or its first focusable child element should be focused when the grid cell is focused. */\n  focusMode?: 'child' | 'cell',\n  /** Whether selection should occur on press up instead of press down. */\n  shouldSelectOnPressUp?: boolean,\n  /** Indicates how many columns the data cell spans. */\n  colSpan?: number,\n  /**\n   * Handler that is called when a user performs an action on the cell.\n   * Please use onCellAction at the collection level instead.\n   * @deprecated\n   **/\n  onAction?: () => void\n}\n\nexport interface GridCellAria {\n  /** Props for the grid cell element. */\n  gridCellProps: DOMAttributes,\n  /** Whether the cell is currently in a pressed state. */\n  isPressed: boolean\n}\n\n/**\n * Provides the behavior and accessibility implementation for a cell in a grid.\n * @param props - Props for the cell.\n * @param state - State of the parent grid, as returned by `useGridState`.\n */\nexport function useGridCell<T, C extends GridCollection<T>>(props: GridCellProps, state: GridState<T, C>, ref: RefObject<FocusableElement | null>): GridCellAria {\n  let {\n    node,\n    isVirtualized,\n    focusMode = 'child',\n    shouldSelectOnPressUp,\n    onAction\n  } = props;\n\n  let {direction} = useLocale();\n  let {keyboardDelegate, actions: {onCellAction}} = gridMap.get(state)!;\n\n  // We need to track the key of the item at the time it was last focused so that we force\n  // focus to go to the item when the DOM node is reused for a different item in a virtualizer.\n  let keyWhenFocused = useRef<Key | null>(null);\n\n  // Handles focusing the cell. If there is a focusable child,\n  // it is focused, otherwise the cell itself is focused.\n  let focus = () => {\n    if (ref.current) {\n      let treeWalker = getFocusableTreeWalker(ref.current);\n      if (focusMode === 'child') {\n        // If focus is already on a focusable child within the cell, early return so we don't shift focus\n        if (ref.current.contains(document.activeElement) && ref.current !== document.activeElement) {\n          return;\n        }\n\n        let focusable = state.selectionManager.childFocusStrategy === 'last'\n          ? last(treeWalker)\n          : treeWalker.firstChild() as FocusableElement;\n        if (focusable) {\n          focusSafely(focusable);\n          return;\n        }\n      }\n\n      if (\n        (keyWhenFocused.current != null && node.key !== keyWhenFocused.current) ||\n        !ref.current.contains(document.activeElement)\n      ) {\n        focusSafely(ref.current);\n      }\n    }\n  };\n\n  let {itemProps, isPressed} = useSelectableItem({\n    selectionManager: state.selectionManager,\n    key: node.key,\n    ref,\n    isVirtualized,\n    focus,\n    shouldSelectOnPressUp,\n    onAction: onCellAction ? () => onCellAction(node.key) : onAction,\n    isDisabled: state.collection.size === 0\n  });\n\n  let onKeyDownCapture = (e: ReactKeyboardEvent) => {\n    if (!e.currentTarget.contains(e.target as Element) || state.isKeyboardNavigationDisabled || !ref.current || !document.activeElement) {\n      return;\n    }\n\n    let walker = getFocusableTreeWalker(ref.current);\n    walker.currentNode = document.activeElement;\n\n    switch (e.key) {\n      case 'ArrowLeft': {\n        // Find the next focusable element within the cell.\n        let focusable: FocusableElement | null = direction === 'rtl'\n          ? walker.nextNode() as FocusableElement\n          : walker.previousNode() as FocusableElement;\n\n        // Don't focus the cell itself if focusMode is \"child\"\n        if (focusMode === 'child' && focusable === ref.current) {\n          focusable = null;\n        }\n\n        e.preventDefault();\n        e.stopPropagation();\n        if (focusable) {\n          focusSafely(focusable);\n          scrollIntoViewport(focusable, {containingElement: getScrollParent(ref.current)});\n        } else {\n          // If there is no next focusable child, then move to the next cell to the left of this one.\n          // This will be handled by useSelectableCollection. However, if there is no cell to the left\n          // of this one, only one column, and the grid doesn't focus rows, then the next key will be the\n          // same as this one. In that case we need to handle focusing either the cell or the first/last\n          // child, depending on the focus mode.\n          let prev = keyboardDelegate.getKeyLeftOf?.(node.key);\n          if (prev !== node.key) {\n            // We prevent the capturing event from reaching children of the cell, e.g. pickers.\n            // We want arrow keys to navigate to the next cell instead. We need to re-dispatch\n            // the event from a higher parent so it still bubbles and gets handled by useSelectableCollection.\n            ref.current.parentElement?.dispatchEvent(\n              new KeyboardEvent(e.nativeEvent.type, e.nativeEvent)\n            );\n            break;\n          }\n\n          if (focusMode === 'cell' && direction === 'rtl') {\n            focusSafely(ref.current);\n            scrollIntoViewport(ref.current, {containingElement: getScrollParent(ref.current)});\n          } else {\n            walker.currentNode = ref.current;\n            focusable = direction === 'rtl'\n              ? walker.firstChild() as FocusableElement\n              : last(walker);\n            if (focusable) {\n              focusSafely(focusable);\n              scrollIntoViewport(focusable, {containingElement: getScrollParent(ref.current)});\n            }\n          }\n        }\n        break;\n      }\n      case 'ArrowRight': {\n        let focusable: FocusableElement | null = direction === 'rtl'\n          ? walker.previousNode() as FocusableElement\n          : walker.nextNode() as FocusableElement;\n\n        if (focusMode === 'child' && focusable === ref.current) {\n          focusable = null;\n        }\n\n        e.preventDefault();\n        e.stopPropagation();\n        if (focusable) {\n          focusSafely(focusable);\n          scrollIntoViewport(focusable, {containingElement: getScrollParent(ref.current)});\n        } else {\n          let next = keyboardDelegate.getKeyRightOf?.(node.key);\n          if (next !== node.key) {\n            // We prevent the capturing event from reaching children of the cell, e.g. pickers.\n            // We want arrow keys to navigate to the next cell instead. We need to re-dispatch\n            // the event from a higher parent so it still bubbles and gets handled by useSelectableCollection.\n            ref.current.parentElement?.dispatchEvent(\n              new KeyboardEvent(e.nativeEvent.type, e.nativeEvent)\n            );\n            break;\n          }\n\n          if (focusMode === 'cell' && direction === 'ltr') {\n            focusSafely(ref.current);\n            scrollIntoViewport(ref.current, {containingElement: getScrollParent(ref.current)});\n          } else {\n            walker.currentNode = ref.current;\n            focusable = direction === 'rtl'\n              ? last(walker)\n              : walker.firstChild() as FocusableElement;\n            if (focusable) {\n              focusSafely(focusable);\n              scrollIntoViewport(focusable, {containingElement: getScrollParent(ref.current)});\n            }\n          }\n        }\n        break;\n      }\n      case 'ArrowUp':\n      case 'ArrowDown':\n        // Prevent this event from reaching cell children, e.g. menu buttons. We want arrow keys to navigate\n        // to the cell above/below instead. We need to re-dispatch the event from a higher parent so it still\n        // bubbles and gets handled by useSelectableCollection.\n        if (!e.altKey && ref.current.contains(e.target as Element)) {\n          e.stopPropagation();\n          e.preventDefault();\n          ref.current.parentElement?.dispatchEvent(\n            new KeyboardEvent(e.nativeEvent.type, e.nativeEvent)\n          );\n        }\n        break;\n    }\n  };\n\n  // Grid cells can have focusable elements inside them. In this case, focus should\n  // be marshalled to that element rather than focusing the cell itself.\n  let onFocus = (e) => {\n    keyWhenFocused.current = node.key;\n    if (e.target !== ref.current) {\n      // useSelectableItem only handles setting the focused key when\n      // the focused element is the gridcell itself. We also want to\n      // set the focused key when a child element receives focus.\n      // If focus is currently visible (e.g. the user is navigating with the keyboard),\n      // then skip this. We want to restore focus to the previously focused row/cell\n      // in that case since the table should act like a single tab stop.\n      if (!isFocusVisible()) {\n        state.selectionManager.setFocusedKey(node.key);\n      }\n      return;\n    }\n\n    // If the cell itself is focused, wait a frame so that focus finishes propagatating\n    // up to the tree, and move focus to a focusable child if possible.\n    requestAnimationFrame(() => {\n      if (focusMode === 'child' && document.activeElement === ref.current) {\n        focus();\n      }\n    });\n  };\n\n  let gridCellProps: DOMAttributes = mergeProps(itemProps, {\n    role: 'gridcell',\n    onKeyDownCapture,\n    'aria-colspan': node.colSpan,\n    'aria-colindex': node.colIndex != null ? node.colIndex + 1 : undefined, // aria-colindex is 1-based\n    colSpan: isVirtualized ? undefined : node.colSpan,\n    onFocus\n  });\n\n  if (isVirtualized) {\n    gridCellProps['aria-colindex'] = (node.colIndex ?? node.index) + 1; // aria-colindex is 1-based\n  }\n\n  // When pressing with a pointer and cell selection is not enabled, usePress will be applied to the\n  // row rather than the cell. However, when the row is draggable, usePress cannot preventDefault\n  // on pointer down, so the browser will try to focus the cell which has a tabIndex applied.\n  // To avoid this, remove the tabIndex from the cell briefly on pointer down.\n  if (shouldSelectOnPressUp && gridCellProps.tabIndex != null && gridCellProps.onPointerDown == null) {\n    gridCellProps.onPointerDown = (e) => {\n      let el = e.currentTarget;\n      let tabindex = el.getAttribute('tabindex');\n      el.removeAttribute('tabindex');\n      requestAnimationFrame(() => {\n        if (tabindex != null) {\n          el.setAttribute('tabindex', tabindex);\n        }\n      });\n    };\n  }\n\n  return {\n    gridCellProps,\n    isPressed\n  };\n}\n\nfunction last(walker: TreeWalker) {\n  let next: FocusableElement | null = null;\n  let last: FocusableElement | null = null;\n  do {\n    last = walker.lastChild() as FocusableElement | null;\n    if (last) {\n      next = last;\n    }\n  } while (last);\n  return next;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}