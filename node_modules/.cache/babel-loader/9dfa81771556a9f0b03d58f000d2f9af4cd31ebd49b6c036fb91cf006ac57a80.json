{"ast":null,"code":"// src/index.ts\nimport { useEffect, useRef, useState } from \"react\";\nfunction useIntersectionObserver({\n  threshold = 0,\n  root = null,\n  rootMargin = \"0%\",\n  isEnabled = true,\n  freezeOnceVisible = false,\n  initialIsIntersecting = false,\n  onChange\n} = {}) {\n  var _a;\n  const [ref, setRef] = useState(null);\n  const [state, setState] = useState(() => ({\n    isIntersecting: initialIsIntersecting,\n    entry: void 0\n  }));\n  const callbackRef = useRef();\n  callbackRef.current = onChange;\n  const frozen = ((_a = state.entry) == null ? void 0 : _a.isIntersecting) && freezeOnceVisible;\n  useEffect(() => {\n    if (!isEnabled) return;\n    if (!ref) return;\n    if (!(\"IntersectionObserver\" in window)) return;\n    if (frozen) return;\n    let unobserve;\n    const observer = new IntersectionObserver(entries => {\n      const thresholds = Array.isArray(observer.thresholds) ? observer.thresholds : [observer.thresholds];\n      entries.forEach(entry => {\n        const isIntersecting = entry.isIntersecting && thresholds.some(threshold2 => entry.intersectionRatio >= threshold2);\n        setState({\n          isIntersecting,\n          entry\n        });\n        if (callbackRef.current) {\n          callbackRef.current(isIntersecting, entry);\n        }\n        if (isIntersecting && freezeOnceVisible && unobserve) {\n          unobserve();\n          unobserve = void 0;\n        }\n      });\n    }, {\n      threshold,\n      root,\n      rootMargin\n    });\n    observer.observe(ref);\n    return () => {\n      observer.disconnect();\n    };\n  }, [ref, isEnabled,\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  JSON.stringify(threshold), root, rootMargin, frozen, freezeOnceVisible]);\n  const prevRef = useRef(null);\n  useEffect(() => {\n    var _a2;\n    if (!ref && ((_a2 = state.entry) == null ? void 0 : _a2.target) && !freezeOnceVisible && !frozen && prevRef.current !== state.entry.target) {\n      prevRef.current = state.entry.target;\n      setState({\n        isIntersecting: initialIsIntersecting,\n        entry: void 0\n      });\n    }\n  }, [ref, state.entry, freezeOnceVisible, frozen, initialIsIntersecting]);\n  const result = [setRef, !!state.isIntersecting, state.entry];\n  result.ref = result[0];\n  result.isIntersecting = result[1];\n  result.entry = result[2];\n  return result;\n}\nexport { useIntersectionObserver };","map":{"version":3,"names":["useEffect","useRef","useState","useIntersectionObserver","threshold","root","rootMargin","isEnabled","freezeOnceVisible","initialIsIntersecting","onChange","_a","ref","setRef","state","setState","isIntersecting","entry","callbackRef","current","frozen","window","unobserve","observer","IntersectionObserver","entries","thresholds","Array","isArray","forEach","some","threshold2","intersectionRatio","observe","disconnect","JSON","stringify","prevRef","_a2","target","result"],"sources":["/Users/nathandarma/Documents/App Testing/Diptych/diptych/node_modules/@heroui/use-intersection-observer/dist/index.mjs"],"sourcesContent":["// src/index.ts\nimport { useEffect, useRef, useState } from \"react\";\nfunction useIntersectionObserver({\n  threshold = 0,\n  root = null,\n  rootMargin = \"0%\",\n  isEnabled = true,\n  freezeOnceVisible = false,\n  initialIsIntersecting = false,\n  onChange\n} = {}) {\n  var _a;\n  const [ref, setRef] = useState(null);\n  const [state, setState] = useState(() => ({\n    isIntersecting: initialIsIntersecting,\n    entry: void 0\n  }));\n  const callbackRef = useRef();\n  callbackRef.current = onChange;\n  const frozen = ((_a = state.entry) == null ? void 0 : _a.isIntersecting) && freezeOnceVisible;\n  useEffect(() => {\n    if (!isEnabled) return;\n    if (!ref) return;\n    if (!(\"IntersectionObserver\" in window)) return;\n    if (frozen) return;\n    let unobserve;\n    const observer = new IntersectionObserver(\n      (entries) => {\n        const thresholds = Array.isArray(observer.thresholds) ? observer.thresholds : [observer.thresholds];\n        entries.forEach((entry) => {\n          const isIntersecting = entry.isIntersecting && thresholds.some((threshold2) => entry.intersectionRatio >= threshold2);\n          setState({ isIntersecting, entry });\n          if (callbackRef.current) {\n            callbackRef.current(isIntersecting, entry);\n          }\n          if (isIntersecting && freezeOnceVisible && unobserve) {\n            unobserve();\n            unobserve = void 0;\n          }\n        });\n      },\n      { threshold, root, rootMargin }\n    );\n    observer.observe(ref);\n    return () => {\n      observer.disconnect();\n    };\n  }, [\n    ref,\n    isEnabled,\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    JSON.stringify(threshold),\n    root,\n    rootMargin,\n    frozen,\n    freezeOnceVisible\n  ]);\n  const prevRef = useRef(null);\n  useEffect(() => {\n    var _a2;\n    if (!ref && ((_a2 = state.entry) == null ? void 0 : _a2.target) && !freezeOnceVisible && !frozen && prevRef.current !== state.entry.target) {\n      prevRef.current = state.entry.target;\n      setState({ isIntersecting: initialIsIntersecting, entry: void 0 });\n    }\n  }, [ref, state.entry, freezeOnceVisible, frozen, initialIsIntersecting]);\n  const result = [setRef, !!state.isIntersecting, state.entry];\n  result.ref = result[0];\n  result.isIntersecting = result[1];\n  result.entry = result[2];\n  return result;\n}\nexport {\n  useIntersectionObserver\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}