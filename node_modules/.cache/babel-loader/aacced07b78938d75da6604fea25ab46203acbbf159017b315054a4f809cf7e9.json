{"ast":null,"code":"import { getFirstItem as $eIXPM$getFirstItem, getChildNodes as $eIXPM$getChildNodes } from \"@react-stately/collections\";\nimport { GridKeyboardDelegate as $eIXPM$GridKeyboardDelegate } from \"@react-aria/grid\";\n\n/*\n * Copyright 2022 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nclass $0ba3c81c7f1caedd$export$da43f8f5cb04028d extends (0, $eIXPM$GridKeyboardDelegate) {\n  isCell(node) {\n    return node.type === 'cell' || node.type === 'rowheader' || node.type === 'column';\n  }\n  getKeyBelow(key) {\n    let startItem = this.collection.getItem(key);\n    if (!startItem) return null;\n    // If focus was on a column, then focus the first child column if any,\n    // or find the corresponding cell in the first row.\n    if (startItem.type === 'column') {\n      let child = (0, $eIXPM$getFirstItem)((0, $eIXPM$getChildNodes)(startItem, this.collection));\n      if (child) return child.key;\n      let firstKey = this.getFirstKey();\n      if (firstKey == null) return null;\n      let firstItem = this.collection.getItem(firstKey);\n      if (!firstItem) return null;\n      return super.getKeyForItemInRowByIndex(firstKey, startItem.index);\n    }\n    return super.getKeyBelow(key);\n  }\n  getKeyAbove(key) {\n    let startItem = this.collection.getItem(key);\n    if (!startItem) return null;\n    // If focus was on a column, focus the parent column if any\n    if (startItem.type === 'column') {\n      let parent = startItem.parentKey != null ? this.collection.getItem(startItem.parentKey) : null;\n      if (parent && parent.type === 'column') return parent.key;\n      return null;\n    }\n    // only return above row key if not header row\n    let superKey = super.getKeyAbove(key);\n    let superItem = superKey != null ? this.collection.getItem(superKey) : null;\n    if (superItem && superItem.type !== 'headerrow') return superKey;\n    // If no item was found, and focus was on a cell, then focus the\n    // corresponding column header.\n    if (this.isCell(startItem)) return this.collection.columns[startItem.index].key;\n    // If focus was on a row, then focus the first column header.\n    return this.collection.columns[0].key;\n  }\n  findNextColumnKey(column) {\n    // Search following columns\n    let key = this.findNextKey(column.key, item => item.type === 'column');\n    if (key != null) return key;\n    // Wrap around to the first column\n    let row = this.collection.headerRows[column.level];\n    for (let item of (0, $eIXPM$getChildNodes)(row, this.collection)) {\n      if (item.type === 'column') return item.key;\n    }\n    return null;\n  }\n  findPreviousColumnKey(column) {\n    // Search previous columns\n    let key = this.findPreviousKey(column.key, item => item.type === 'column');\n    if (key != null) return key;\n    // Wrap around to the last column\n    let row = this.collection.headerRows[column.level];\n    let childNodes = [...(0, $eIXPM$getChildNodes)(row, this.collection)];\n    for (let i = childNodes.length - 1; i >= 0; i--) {\n      let item = childNodes[i];\n      if (item.type === 'column') return item.key;\n    }\n    return null;\n  }\n  getKeyRightOf(key) {\n    let item = this.collection.getItem(key);\n    if (!item) return null;\n    // If focus was on a column, then focus the next column\n    if (item.type === 'column') return this.direction === 'rtl' ? this.findPreviousColumnKey(item) : this.findNextColumnKey(item);\n    return super.getKeyRightOf(key);\n  }\n  getKeyLeftOf(key) {\n    let item = this.collection.getItem(key);\n    if (!item) return null;\n    // If focus was on a column, then focus the previous column\n    if (item.type === 'column') return this.direction === 'rtl' ? this.findNextColumnKey(item) : this.findPreviousColumnKey(item);\n    return super.getKeyLeftOf(key);\n  }\n  getKeyForSearch(search, fromKey) {\n    if (!this.collator) return null;\n    let collection = this.collection;\n    let key = fromKey !== null && fromKey !== void 0 ? fromKey : this.getFirstKey();\n    if (key == null) return null;\n    // If the starting key is a cell, search from its parent row.\n    let startItem = collection.getItem(key);\n    var _startItem_parentKey;\n    if ((startItem === null || startItem === void 0 ? void 0 : startItem.type) === 'cell') key = (_startItem_parentKey = startItem.parentKey) !== null && _startItem_parentKey !== void 0 ? _startItem_parentKey : null;\n    let hasWrapped = false;\n    while (key != null) {\n      let item = collection.getItem(key);\n      if (!item) return null;\n      if (item.textValue) {\n        let substring = item.textValue.slice(0, search.length);\n        if (this.collator.compare(substring, search) === 0) return item.key;\n      }\n      // Check each of the row header cells in this row for a match\n      for (let cell of (0, $eIXPM$getChildNodes)(item, this.collection)) {\n        let column = collection.columns[cell.index];\n        if (collection.rowHeaderColumnKeys.has(column.key) && cell.textValue) {\n          let substring = cell.textValue.slice(0, search.length);\n          if (this.collator.compare(substring, search) === 0) {\n            // If we started on a cell, end on the matching cell. Otherwise, end on the row.\n            let fromItem = fromKey != null ? collection.getItem(fromKey) : startItem;\n            return (fromItem === null || fromItem === void 0 ? void 0 : fromItem.type) === 'cell' ? cell.key : item.key;\n          }\n        }\n      }\n      key = this.getKeyBelow(key);\n      // Wrap around when reaching the end of the collection\n      if (key == null && !hasWrapped) {\n        key = this.getFirstKey();\n        hasWrapped = true;\n      }\n    }\n    return null;\n  }\n}\nexport { $0ba3c81c7f1caedd$export$da43f8f5cb04028d as TableKeyboardDelegate };","map":{"version":3,"names":["$0ba3c81c7f1caedd$export$da43f8f5cb04028d","$eIXPM$GridKeyboardDelegate","isCell","node","type","getKeyBelow","key","startItem","collection","getItem","child","$eIXPM$getFirstItem","$eIXPM$getChildNodes","firstKey","getFirstKey","firstItem","getKeyForItemInRowByIndex","index","getKeyAbove","parent","parentKey","superKey","superItem","columns","findNextColumnKey","column","findNextKey","item","row","headerRows","level","findPreviousColumnKey","findPreviousKey","childNodes","i","length","getKeyRightOf","direction","getKeyLeftOf","getKeyForSearch","search","fromKey","collator","_startItem_parentKey","hasWrapped","textValue","substring","slice","compare","cell","rowHeaderColumnKeys","has","fromItem"],"sources":["/Users/nathandarma/Documents/App Testing/Diptych/diptych/node_modules/@react-aria/table/dist/packages/@react-aria/table/src/TableKeyboardDelegate.ts"],"sourcesContent":["/*\n * Copyright 2022 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {getChildNodes, getFirstItem} from '@react-stately/collections';\nimport {GridKeyboardDelegate} from '@react-aria/grid';\nimport {Key, Node} from '@react-types/shared';\nimport {TableCollection} from '@react-types/table';\n\nexport class TableKeyboardDelegate<T> extends GridKeyboardDelegate<T, TableCollection<T>> {\n\n  protected isCell(node: Node<T>): boolean {\n    return node.type === 'cell' || node.type === 'rowheader' || node.type === 'column';\n  }\n\n  getKeyBelow(key: Key): Key | null {\n    let startItem = this.collection.getItem(key);\n    if (!startItem) {\n      return null;\n    }\n\n    // If focus was on a column, then focus the first child column if any,\n    // or find the corresponding cell in the first row.\n    if (startItem.type === 'column') {\n      let child = getFirstItem(getChildNodes(startItem, this.collection));\n      if (child) {\n        return child.key;\n      }\n\n      let firstKey = this.getFirstKey();\n      if (firstKey == null) {\n        return null;\n      }\n\n      let firstItem = this.collection.getItem(firstKey);\n      if (!firstItem) {\n        return null;\n      }\n\n      return super.getKeyForItemInRowByIndex(firstKey, startItem.index);\n    }\n\n    return super.getKeyBelow(key);\n  }\n\n  getKeyAbove(key: Key): Key | null {\n    let startItem = this.collection.getItem(key);\n    if (!startItem) {\n      return null;\n    }\n\n    // If focus was on a column, focus the parent column if any\n    if (startItem.type === 'column') {\n      let parent = startItem.parentKey != null ? this.collection.getItem(startItem.parentKey) : null;\n      if (parent && parent.type === 'column') {\n        return parent.key;\n      }\n\n      return null;\n    }\n\n    // only return above row key if not header row\n    let superKey = super.getKeyAbove(key);\n    let superItem = superKey != null ? this.collection.getItem(superKey) : null;\n    if (superItem && superItem.type !== 'headerrow') {\n      return superKey;\n    }\n\n    // If no item was found, and focus was on a cell, then focus the\n    // corresponding column header.\n    if (this.isCell(startItem)) {\n      return this.collection.columns[startItem.index].key;\n    }\n\n    // If focus was on a row, then focus the first column header.\n    return this.collection.columns[0].key;\n  }\n\n  private findNextColumnKey(column: Node<T>): Key | null {\n    // Search following columns\n    let key = this.findNextKey(column.key, item => item.type === 'column');\n    if (key != null) {\n      return key;\n    }\n\n    // Wrap around to the first column\n    let row = this.collection.headerRows[column.level];\n    for (let item of getChildNodes(row, this.collection)) {\n      if (item.type === 'column') {\n        return item.key;\n      }\n    }\n\n    return null;\n  }\n\n  private findPreviousColumnKey(column: Node<T>): Key | null {\n    // Search previous columns\n    let key = this.findPreviousKey(column.key, item => item.type === 'column');\n    if (key != null) {\n      return key;\n    }\n\n    // Wrap around to the last column\n    let row = this.collection.headerRows[column.level];\n    let childNodes = [...getChildNodes(row, this.collection)];\n    for (let i = childNodes.length - 1; i >= 0; i--) {\n      let item = childNodes[i];\n      if (item.type === 'column') {\n        return item.key;\n      }\n    }\n\n    return null;\n  }\n\n  getKeyRightOf(key: Key): Key | null {\n    let item = this.collection.getItem(key);\n    if (!item) {\n      return null;\n    }\n\n    // If focus was on a column, then focus the next column\n    if (item.type === 'column') {\n      return this.direction === 'rtl'\n        ? this.findPreviousColumnKey(item)\n        : this.findNextColumnKey(item);\n    }\n\n    return super.getKeyRightOf(key);\n  }\n\n  getKeyLeftOf(key: Key): Key | null {\n    let item = this.collection.getItem(key);\n    if (!item) {\n      return null;\n    }\n\n    // If focus was on a column, then focus the previous column\n    if (item.type === 'column') {\n      return this.direction === 'rtl'\n        ? this.findNextColumnKey(item)\n        : this.findPreviousColumnKey(item);\n    }\n\n    return super.getKeyLeftOf(key);\n  }\n\n  getKeyForSearch(search: string, fromKey?: Key): Key | null {\n    if (!this.collator) {\n      return null;\n    }\n\n    let collection = this.collection;\n    let key = fromKey ?? this.getFirstKey();\n    if (key == null) {\n      return null;\n    }\n\n    // If the starting key is a cell, search from its parent row.\n    let startItem = collection.getItem(key);\n    if (startItem?.type === 'cell') {\n      key = startItem.parentKey ?? null;\n    }\n\n    let hasWrapped = false;\n    while (key != null) {\n      let item = collection.getItem(key);\n      if (!item) {\n        return null;\n      }\n\n      if (item.textValue) {\n        let substring = item.textValue.slice(0, search.length);\n        if (this.collator.compare(substring, search) === 0) {\n          return item.key;\n        }\n      }\n\n      // Check each of the row header cells in this row for a match\n      for (let cell of getChildNodes(item, this.collection)) {\n        let column = collection.columns[cell.index];\n        if (collection.rowHeaderColumnKeys.has(column.key) && cell.textValue) {\n          let substring = cell.textValue.slice(0, search.length);\n          if (this.collator.compare(substring, search) === 0) {\n            // If we started on a cell, end on the matching cell. Otherwise, end on the row.\n            let fromItem = fromKey != null ? collection.getItem(fromKey) : startItem;\n            return fromItem?.type === 'cell'\n              ? cell.key\n              : item.key;\n          }\n        }\n      }\n\n      key = this.getKeyBelow(key);\n\n      // Wrap around when reaching the end of the collection\n      if (key == null && !hasWrapped) {\n        key = this.getFirstKey();\n        hasWrapped = true;\n      }\n    }\n\n    return null;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}