{"ast":null,"code":"// src/index.ts\nimport { useEffect, useRef, useCallback } from \"react\";\nimport { useMove } from \"@react-aria/interactions\";\nfunction useDraggable(props) {\n  const {\n    targetRef,\n    isDisabled = false,\n    canOverflow = false\n  } = props;\n  const boundary = useRef({\n    minLeft: 0,\n    minTop: 0,\n    maxLeft: 0,\n    maxTop: 0\n  });\n  let transform = {\n    offsetX: 0,\n    offsetY: 0\n  };\n  const onMoveStart = useCallback(() => {\n    var _a, _b, _c, _d, _e;\n    const {\n      offsetX,\n      offsetY\n    } = transform;\n    const targetRect = (_a = targetRef == null ? void 0 : targetRef.current) == null ? void 0 : _a.getBoundingClientRect();\n    const targetLeft = (_b = targetRect == null ? void 0 : targetRect.left) != null ? _b : 0;\n    const targetTop = (_c = targetRect == null ? void 0 : targetRect.top) != null ? _c : 0;\n    const targetWidth = (_d = targetRect == null ? void 0 : targetRect.width) != null ? _d : 0;\n    const targetHeight = (_e = targetRect == null ? void 0 : targetRect.height) != null ? _e : 0;\n    const clientWidth = document.documentElement.clientWidth;\n    const clientHeight = document.documentElement.clientHeight;\n    const minLeft = -targetLeft + offsetX;\n    const minTop = -targetTop + offsetY;\n    const maxLeft = clientWidth - targetLeft - targetWidth + offsetX;\n    const maxTop = clientHeight - targetTop - targetHeight + offsetY;\n    boundary.current = {\n      minLeft,\n      minTop,\n      maxLeft,\n      maxTop\n    };\n  }, [transform, targetRef == null ? void 0 : targetRef.current]);\n  const onMove = useCallback(e => {\n    if (isDisabled) {\n      return;\n    }\n    const {\n      offsetX,\n      offsetY\n    } = transform;\n    const {\n      minLeft,\n      minTop,\n      maxLeft,\n      maxTop\n    } = boundary.current;\n    let moveX = offsetX + e.deltaX;\n    let moveY = offsetY + e.deltaY;\n    if (!canOverflow) {\n      moveX = Math.min(Math.max(moveX, minLeft), maxLeft);\n      moveY = Math.min(Math.max(moveY, minTop), maxTop);\n    }\n    transform = {\n      offsetX: moveX,\n      offsetY: moveY\n    };\n    if (targetRef == null ? void 0 : targetRef.current) {\n      targetRef.current.style.transform = `translate(${moveX}px, ${moveY}px)`;\n    }\n  }, [isDisabled, transform, boundary.current, canOverflow, targetRef == null ? void 0 : targetRef.current]);\n  const {\n    moveProps\n  } = useMove({\n    onMoveStart,\n    onMove\n  });\n  const preventDefault = useCallback(e => {\n    e.preventDefault();\n  }, []);\n  useEffect(() => {\n    if (!isDisabled) {\n      document.body.addEventListener(\"touchmove\", preventDefault, {\n        passive: false\n      });\n    }\n    return () => {\n      document.body.removeEventListener(\"touchmove\", preventDefault);\n    };\n  }, [isDisabled]);\n  return {\n    moveProps: {\n      ...moveProps,\n      style: {\n        cursor: !isDisabled ? \"move\" : void 0\n      }\n    }\n  };\n}\nexport { useDraggable };","map":{"version":3,"names":["useEffect","useRef","useCallback","useMove","useDraggable","props","targetRef","isDisabled","canOverflow","boundary","minLeft","minTop","maxLeft","maxTop","transform","offsetX","offsetY","onMoveStart","_a","_b","_c","_d","_e","targetRect","current","getBoundingClientRect","targetLeft","left","targetTop","top","targetWidth","width","targetHeight","height","clientWidth","document","documentElement","clientHeight","onMove","e","moveX","deltaX","moveY","deltaY","Math","min","max","style","moveProps","preventDefault","body","addEventListener","passive","removeEventListener","cursor"],"sources":["/Users/nathandarma/Documents/App Testing/Diptych/diptych/node_modules/@heroui/use-draggable/dist/index.mjs"],"sourcesContent":["// src/index.ts\nimport { useEffect, useRef, useCallback } from \"react\";\nimport { useMove } from \"@react-aria/interactions\";\nfunction useDraggable(props) {\n  const { targetRef, isDisabled = false, canOverflow = false } = props;\n  const boundary = useRef({ minLeft: 0, minTop: 0, maxLeft: 0, maxTop: 0 });\n  let transform = { offsetX: 0, offsetY: 0 };\n  const onMoveStart = useCallback(() => {\n    var _a, _b, _c, _d, _e;\n    const { offsetX, offsetY } = transform;\n    const targetRect = (_a = targetRef == null ? void 0 : targetRef.current) == null ? void 0 : _a.getBoundingClientRect();\n    const targetLeft = (_b = targetRect == null ? void 0 : targetRect.left) != null ? _b : 0;\n    const targetTop = (_c = targetRect == null ? void 0 : targetRect.top) != null ? _c : 0;\n    const targetWidth = (_d = targetRect == null ? void 0 : targetRect.width) != null ? _d : 0;\n    const targetHeight = (_e = targetRect == null ? void 0 : targetRect.height) != null ? _e : 0;\n    const clientWidth = document.documentElement.clientWidth;\n    const clientHeight = document.documentElement.clientHeight;\n    const minLeft = -targetLeft + offsetX;\n    const minTop = -targetTop + offsetY;\n    const maxLeft = clientWidth - targetLeft - targetWidth + offsetX;\n    const maxTop = clientHeight - targetTop - targetHeight + offsetY;\n    boundary.current = {\n      minLeft,\n      minTop,\n      maxLeft,\n      maxTop\n    };\n  }, [transform, targetRef == null ? void 0 : targetRef.current]);\n  const onMove = useCallback(\n    (e) => {\n      if (isDisabled) {\n        return;\n      }\n      const { offsetX, offsetY } = transform;\n      const { minLeft, minTop, maxLeft, maxTop } = boundary.current;\n      let moveX = offsetX + e.deltaX;\n      let moveY = offsetY + e.deltaY;\n      if (!canOverflow) {\n        moveX = Math.min(Math.max(moveX, minLeft), maxLeft);\n        moveY = Math.min(Math.max(moveY, minTop), maxTop);\n      }\n      transform = {\n        offsetX: moveX,\n        offsetY: moveY\n      };\n      if (targetRef == null ? void 0 : targetRef.current) {\n        targetRef.current.style.transform = `translate(${moveX}px, ${moveY}px)`;\n      }\n    },\n    [isDisabled, transform, boundary.current, canOverflow, targetRef == null ? void 0 : targetRef.current]\n  );\n  const { moveProps } = useMove({\n    onMoveStart,\n    onMove\n  });\n  const preventDefault = useCallback((e) => {\n    e.preventDefault();\n  }, []);\n  useEffect(() => {\n    if (!isDisabled) {\n      document.body.addEventListener(\"touchmove\", preventDefault, { passive: false });\n    }\n    return () => {\n      document.body.removeEventListener(\"touchmove\", preventDefault);\n    };\n  }, [isDisabled]);\n  return {\n    moveProps: {\n      ...moveProps,\n      style: { cursor: !isDisabled ? \"move\" : void 0 }\n    }\n  };\n}\nexport {\n  useDraggable\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}