{"ast":null,"code":"import { useState as $3xCwh$useState, useCallback as $3xCwh$useCallback, useEffect as $3xCwh$useEffect } from \"react\";\nimport { useLayoutEffect as $3xCwh$useLayoutEffect } from \"@react-aria/utils\";\nimport { useSyncExternalStore as $3xCwh$useSyncExternalStore } from \"use-sync-external-store/shim/index.js\";\n\n/*\n * Copyright 2022 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\n// Increment this version number whenever the\n// LandmarkManagerApi or Landmark interfaces change.\nconst $a86207c5d7f7e1fb$var$LANDMARK_API_VERSION = 1;\n// Symbol under which the singleton landmark manager instance is attached to the document.\nconst $a86207c5d7f7e1fb$var$landmarkSymbol = Symbol.for('react-aria-landmark-manager');\nfunction $a86207c5d7f7e1fb$var$subscribe(fn) {\n  document.addEventListener('react-aria-landmark-manager-change', fn);\n  return () => document.removeEventListener('react-aria-landmark-manager-change', fn);\n}\nfunction $a86207c5d7f7e1fb$var$getLandmarkManager() {\n  if (typeof document === 'undefined') return null;\n  // Reuse an existing instance if it has the same or greater version.\n  let instance = document[$a86207c5d7f7e1fb$var$landmarkSymbol];\n  if (instance && instance.version >= $a86207c5d7f7e1fb$var$LANDMARK_API_VERSION) return instance;\n  // Otherwise, create a new instance and dispatch an event so anything using the existing\n  // instance updates and re-registers their landmarks with the new one.\n  document[$a86207c5d7f7e1fb$var$landmarkSymbol] = new $a86207c5d7f7e1fb$var$LandmarkManager();\n  document.dispatchEvent(new CustomEvent('react-aria-landmark-manager-change'));\n  return document[$a86207c5d7f7e1fb$var$landmarkSymbol];\n}\n// Subscribes a React component to the current landmark manager instance.\nfunction $a86207c5d7f7e1fb$var$useLandmarkManager() {\n  return (0, $3xCwh$useSyncExternalStore)($a86207c5d7f7e1fb$var$subscribe, $a86207c5d7f7e1fb$var$getLandmarkManager, $a86207c5d7f7e1fb$var$getLandmarkManager);\n}\nclass $a86207c5d7f7e1fb$var$LandmarkManager {\n  setupIfNeeded() {\n    if (this.isListening) return;\n    document.addEventListener('keydown', this.f6Handler, {\n      capture: true\n    });\n    document.addEventListener('focusin', this.focusinHandler, {\n      capture: true\n    });\n    document.addEventListener('focusout', this.focusoutHandler, {\n      capture: true\n    });\n    this.isListening = true;\n  }\n  teardownIfNeeded() {\n    if (!this.isListening || this.landmarks.length > 0 || this.refCount > 0) return;\n    document.removeEventListener('keydown', this.f6Handler, {\n      capture: true\n    });\n    document.removeEventListener('focusin', this.focusinHandler, {\n      capture: true\n    });\n    document.removeEventListener('focusout', this.focusoutHandler, {\n      capture: true\n    });\n    this.isListening = false;\n  }\n  focusLandmark(landmark, direction) {\n    var _this_landmarks_find_focus, _this_landmarks_find;\n    (_this_landmarks_find = this.landmarks.find(l => l.ref.current === landmark)) === null || _this_landmarks_find === void 0 ? void 0 : (_this_landmarks_find_focus = _this_landmarks_find.focus) === null || _this_landmarks_find_focus === void 0 ? void 0 : _this_landmarks_find_focus.call(_this_landmarks_find, direction);\n  }\n  /**\n  * Return set of landmarks with a specific role.\n  */\n  getLandmarksByRole(role) {\n    return new Set(this.landmarks.filter(l => l.role === role));\n  }\n  /**\n  * Return first landmark with a specific role.\n  */\n  getLandmarkByRole(role) {\n    return this.landmarks.find(l => l.role === role);\n  }\n  addLandmark(newLandmark) {\n    this.setupIfNeeded();\n    if (this.landmarks.find(landmark => landmark.ref === newLandmark.ref) || !newLandmark.ref.current) return;\n    if (this.landmarks.filter(landmark => landmark.role === 'main').length > 1 && process.env.NODE_ENV !== 'production') console.error('Page can contain no more than one landmark with the role \"main\".');\n    if (this.landmarks.length === 0) {\n      this.landmarks = [newLandmark];\n      this.checkLabels(newLandmark.role);\n      return;\n    }\n    // Binary search to insert new landmark based on position in document relative to existing landmarks.\n    // https://developer.mozilla.org/en-US/docs/Web/API/Node/compareDocumentPosition\n    let start = 0;\n    let end = this.landmarks.length - 1;\n    while (start <= end) {\n      let mid = Math.floor((start + end) / 2);\n      let comparedPosition = newLandmark.ref.current.compareDocumentPosition(this.landmarks[mid].ref.current);\n      let isNewAfterExisting = Boolean(comparedPosition & Node.DOCUMENT_POSITION_PRECEDING || comparedPosition & Node.DOCUMENT_POSITION_CONTAINS);\n      if (isNewAfterExisting) start = mid + 1;else end = mid - 1;\n    }\n    this.landmarks.splice(start, 0, newLandmark);\n    this.checkLabels(newLandmark.role);\n  }\n  updateLandmark(landmark) {\n    let index = this.landmarks.findIndex(l => l.ref === landmark.ref);\n    if (index >= 0) {\n      this.landmarks[index] = {\n        ...this.landmarks[index],\n        ...landmark\n      };\n      this.checkLabels(this.landmarks[index].role);\n    }\n  }\n  removeLandmark(ref) {\n    this.landmarks = this.landmarks.filter(landmark => landmark.ref !== ref);\n    this.teardownIfNeeded();\n  }\n  /**\n  * Warn if there are 2+ landmarks with the same role but no label.\n  * Labels for landmarks with the same role must also be unique.\n  *\n  * See https://www.w3.org/WAI/ARIA/apg/practices/landmark-regions/.\n  */\n  checkLabels(role) {\n    let landmarksWithRole = this.getLandmarksByRole(role);\n    if (landmarksWithRole.size > 1) {\n      let duplicatesWithoutLabel = [...landmarksWithRole].filter(landmark => !landmark.label);\n      if (duplicatesWithoutLabel.length > 0 && process.env.NODE_ENV !== 'production') console.warn(`Page contains more than one landmark with the '${role}' role. If two or more landmarks on a page share the same role, all must be labeled with an aria-label or aria-labelledby attribute: `, duplicatesWithoutLabel.map(landmark => landmark.ref.current));else if (process.env.NODE_ENV !== 'production') {\n        let labels = [...landmarksWithRole].map(landmark => landmark.label);\n        let duplicateLabels = labels.filter((item, index) => labels.indexOf(item) !== index);\n        duplicateLabels.forEach(label => {\n          console.warn(`Page contains more than one landmark with the '${role}' role and '${label}' label. If two or more landmarks on a page share the same role, they must have unique labels: `, [...landmarksWithRole].filter(landmark => landmark.label === label).map(landmark => landmark.ref.current));\n        });\n      }\n    }\n  }\n  /**\n  * Get the landmark that is the closest parent in the DOM.\n  * Returns undefined if no parent is a landmark.\n  */\n  closestLandmark(element) {\n    let landmarkMap = new Map(this.landmarks.map(l => [l.ref.current, l]));\n    let currentElement = element;\n    while (currentElement && !landmarkMap.has(currentElement) && currentElement !== document.body && currentElement.parentElement) currentElement = currentElement.parentElement;\n    return landmarkMap.get(currentElement);\n  }\n  /**\n  * Gets the next landmark, in DOM focus order, or previous if backwards is specified.\n  * If last landmark, next should be the first landmark.\n  * If not inside a landmark, will return first landmark.\n  * Returns undefined if there are no landmarks.\n  */\n  getNextLandmark(element, {\n    backward: backward\n  }) {\n    var _this_landmarks_nextLandmarkIndex_ref_current;\n    let currentLandmark = this.closestLandmark(element);\n    let nextLandmarkIndex = backward ? this.landmarks.length - 1 : 0;\n    if (currentLandmark) nextLandmarkIndex = this.landmarks.indexOf(currentLandmark) + (backward ? -1 : 1);\n    let wrapIfNeeded = () => {\n      // When we reach the end of the landmark sequence, fire a custom event that can be listened for by applications.\n      // If this event is canceled, we return immediately. This can be used to implement landmark navigation across iframes.\n      if (nextLandmarkIndex < 0) {\n        if (!element.dispatchEvent(new CustomEvent('react-aria-landmark-navigation', {\n          detail: {\n            direction: 'backward'\n          },\n          bubbles: true,\n          cancelable: true\n        }))) return true;\n        nextLandmarkIndex = this.landmarks.length - 1;\n      } else if (nextLandmarkIndex >= this.landmarks.length) {\n        if (!element.dispatchEvent(new CustomEvent('react-aria-landmark-navigation', {\n          detail: {\n            direction: 'forward'\n          },\n          bubbles: true,\n          cancelable: true\n        }))) return true;\n        nextLandmarkIndex = 0;\n      }\n      if (nextLandmarkIndex < 0 || nextLandmarkIndex >= this.landmarks.length) return true;\n      return false;\n    };\n    if (wrapIfNeeded()) return undefined;\n    // Skip over hidden landmarks.\n    let i = nextLandmarkIndex;\n    while ((_this_landmarks_nextLandmarkIndex_ref_current = this.landmarks[nextLandmarkIndex].ref.current) === null || _this_landmarks_nextLandmarkIndex_ref_current === void 0 ? void 0 : _this_landmarks_nextLandmarkIndex_ref_current.closest('[aria-hidden=true]')) {\n      nextLandmarkIndex += backward ? -1 : 1;\n      if (wrapIfNeeded()) return undefined;\n      if (nextLandmarkIndex === i) break;\n    }\n    return this.landmarks[nextLandmarkIndex];\n  }\n  /**\n  * Look at next landmark. If an element was previously focused inside, restore focus there.\n  * If not, focus the landmark itself.\n  * If no landmarks at all, or none with focusable elements, don't move focus.\n  */\n  f6Handler(e) {\n    if (e.key === 'F6') {\n      // If alt key pressed, focus main landmark, otherwise navigate forward or backward based on shift key.\n      let handled = e.altKey ? this.focusMain() : this.navigate(e.target, e.shiftKey);\n      if (handled) {\n        e.preventDefault();\n        e.stopPropagation();\n      }\n    }\n  }\n  focusMain() {\n    let main = this.getLandmarkByRole('main');\n    if (main && main.ref.current && document.contains(main.ref.current)) {\n      this.focusLandmark(main.ref.current, 'forward');\n      return true;\n    }\n    return false;\n  }\n  navigate(from, backward) {\n    let nextLandmark = this.getNextLandmark(from, {\n      backward: backward\n    });\n    if (!nextLandmark) return false;\n    // If something was previously focused in the next landmark, then return focus to it\n    if (nextLandmark.lastFocused) {\n      let lastFocused = nextLandmark.lastFocused;\n      if (document.body.contains(lastFocused)) {\n        lastFocused.focus();\n        return true;\n      }\n    }\n    // Otherwise, focus the landmark itself\n    if (nextLandmark.ref.current && document.contains(nextLandmark.ref.current)) {\n      this.focusLandmark(nextLandmark.ref.current, backward ? 'backward' : 'forward');\n      return true;\n    }\n    return false;\n  }\n  /**\n  * Sets lastFocused for a landmark, if focus is moved within that landmark.\n  * Lets the last focused landmark know it was blurred if something else is focused.\n  */\n  focusinHandler(e) {\n    let currentLandmark = this.closestLandmark(e.target);\n    if (currentLandmark && currentLandmark.ref.current !== e.target) this.updateLandmark({\n      ref: currentLandmark.ref,\n      lastFocused: e.target\n    });\n    let previousFocusedElement = e.relatedTarget;\n    if (previousFocusedElement) {\n      let closestPreviousLandmark = this.closestLandmark(previousFocusedElement);\n      if (closestPreviousLandmark && closestPreviousLandmark.ref.current === previousFocusedElement) closestPreviousLandmark.blur();\n    }\n  }\n  /**\n  * Track if the focus is lost to the body. If it is, do cleanup on the landmark that last had focus.\n  */\n  focusoutHandler(e) {\n    let previousFocusedElement = e.target;\n    let nextFocusedElement = e.relatedTarget;\n    // the === document seems to be a jest thing for focus to go there on generic blur event such as landmark.blur();\n    // browsers appear to send focus instead to document.body and the relatedTarget is null when that happens\n    if (!nextFocusedElement || nextFocusedElement === document) {\n      let closestPreviousLandmark = this.closestLandmark(previousFocusedElement);\n      if (closestPreviousLandmark && closestPreviousLandmark.ref.current === previousFocusedElement) closestPreviousLandmark.blur();\n    }\n  }\n  createLandmarkController() {\n    let instance = this;\n    instance.refCount++;\n    instance.setupIfNeeded();\n    return {\n      navigate(direction, opts) {\n        let element = (opts === null || opts === void 0 ? void 0 : opts.from) || document.activeElement;\n        return instance.navigate(element, direction === 'backward');\n      },\n      focusNext(opts) {\n        let element = (opts === null || opts === void 0 ? void 0 : opts.from) || document.activeElement;\n        return instance.navigate(element, false);\n      },\n      focusPrevious(opts) {\n        let element = (opts === null || opts === void 0 ? void 0 : opts.from) || document.activeElement;\n        return instance.navigate(element, true);\n      },\n      focusMain() {\n        return instance.focusMain();\n      },\n      dispose() {\n        if (instance) {\n          instance.refCount--;\n          instance.teardownIfNeeded();\n          instance = null;\n        }\n      }\n    };\n  }\n  registerLandmark(landmark) {\n    if (this.landmarks.find(l => l.ref === landmark.ref)) this.updateLandmark(landmark);else this.addLandmark(landmark);\n    return () => this.removeLandmark(landmark.ref);\n  }\n  constructor() {\n    this.landmarks = [];\n    this.isListening = false;\n    this.refCount = 0;\n    this.version = $a86207c5d7f7e1fb$var$LANDMARK_API_VERSION;\n    this.f6Handler = this.f6Handler.bind(this);\n    this.focusinHandler = this.focusinHandler.bind(this);\n    this.focusoutHandler = this.focusoutHandler.bind(this);\n  }\n}\nfunction $a86207c5d7f7e1fb$export$a8e2debc6521490c() {\n  // Get the current landmark manager and create a controller using it.\n  let instance = $a86207c5d7f7e1fb$var$getLandmarkManager();\n  let controller = instance === null || instance === void 0 ? void 0 : instance.createLandmarkController();\n  let unsubscribe = $a86207c5d7f7e1fb$var$subscribe(() => {\n    // If the landmark manager changes, dispose the old\n    // controller and create a new one.\n    controller === null || controller === void 0 ? void 0 : controller.dispose();\n    instance = $a86207c5d7f7e1fb$var$getLandmarkManager();\n    controller = instance === null || instance === void 0 ? void 0 : instance.createLandmarkController();\n  });\n  // Return a wrapper that proxies requests to the current controller instance.\n  return {\n    navigate(direction, opts) {\n      return controller.navigate(direction, opts);\n    },\n    focusNext(opts) {\n      return controller.focusNext(opts);\n    },\n    focusPrevious(opts) {\n      return controller.focusPrevious(opts);\n    },\n    focusMain() {\n      return controller.focusMain();\n    },\n    dispose() {\n      controller === null || controller === void 0 ? void 0 : controller.dispose();\n      unsubscribe();\n      controller = undefined;\n      instance = null;\n    }\n  };\n}\nfunction $a86207c5d7f7e1fb$export$4cc632584fd87fae(props, ref) {\n  const {\n    role: role,\n    'aria-label': ariaLabel,\n    'aria-labelledby': ariaLabelledby,\n    focus: focus\n  } = props;\n  let manager = $a86207c5d7f7e1fb$var$useLandmarkManager();\n  let label = ariaLabel || ariaLabelledby;\n  let [isLandmarkFocused, setIsLandmarkFocused] = (0, $3xCwh$useState)(false);\n  let defaultFocus = (0, $3xCwh$useCallback)(() => {\n    setIsLandmarkFocused(true);\n  }, [setIsLandmarkFocused]);\n  let blur = (0, $3xCwh$useCallback)(() => {\n    setIsLandmarkFocused(false);\n  }, [setIsLandmarkFocused]);\n  (0, $3xCwh$useLayoutEffect)(() => {\n    if (manager) return manager.registerLandmark({\n      ref: ref,\n      label: label,\n      role: role,\n      focus: focus || defaultFocus,\n      blur: blur\n    });\n  }, [manager, label, ref, role, focus, defaultFocus, blur]);\n  (0, $3xCwh$useEffect)(() => {\n    var _ref_current;\n    if (isLandmarkFocused) (_ref_current = ref.current) === null || _ref_current === void 0 ? void 0 : _ref_current.focus();\n  }, [isLandmarkFocused, ref]);\n  return {\n    landmarkProps: {\n      role: role,\n      tabIndex: isLandmarkFocused ? -1 : undefined,\n      'aria-label': ariaLabel,\n      'aria-labelledby': ariaLabelledby\n    }\n  };\n}\nexport { $a86207c5d7f7e1fb$export$a8e2debc6521490c as UNSTABLE_createLandmarkController, $a86207c5d7f7e1fb$export$4cc632584fd87fae as useLandmark };","map":{"version":3,"names":["$a86207c5d7f7e1fb$var$LANDMARK_API_VERSION","$a86207c5d7f7e1fb$var$landmarkSymbol","Symbol","for","$a86207c5d7f7e1fb$var$subscribe","fn","document","addEventListener","removeEventListener","$a86207c5d7f7e1fb$var$getLandmarkManager","instance","version","$a86207c5d7f7e1fb$var$LandmarkManager","dispatchEvent","CustomEvent","$a86207c5d7f7e1fb$var$useLandmarkManager","$3xCwh$useSyncExternalStore","setupIfNeeded","isListening","f6Handler","capture","focusinHandler","focusoutHandler","teardownIfNeeded","landmarks","length","refCount","focusLandmark","landmark","direction","_this_landmarks_find_focus","_this_landmarks_find","find","l","ref","current","focus","call","getLandmarksByRole","role","Set","filter","getLandmarkByRole","addLandmark","newLandmark","process","env","NODE_ENV","console","error","checkLabels","start","end","mid","Math","floor","comparedPosition","compareDocumentPosition","isNewAfterExisting","Boolean","Node","DOCUMENT_POSITION_PRECEDING","DOCUMENT_POSITION_CONTAINS","splice","updateLandmark","index","findIndex","removeLandmark","landmarksWithRole","size","duplicatesWithoutLabel","label","warn","map","labels","duplicateLabels","item","indexOf","forEach","closestLandmark","element","landmarkMap","Map","currentElement","has","body","parentElement","get","getNextLandmark","backward","_this_landmarks_nextLandmarkIndex_ref_current","currentLandmark","nextLandmarkIndex","wrapIfNeeded","detail","bubbles","cancelable","undefined","i","closest","e","key","handled","altKey","focusMain","navigate","target","shiftKey","preventDefault","stopPropagation","main","contains","from","nextLandmark","lastFocused","previousFocusedElement","relatedTarget","closestPreviousLandmark","blur","nextFocusedElement","createLandmarkController","opts","activeElement","focusNext","focusPrevious","dispose","registerLandmark","constructor","bind","$a86207c5d7f7e1fb$export$a8e2debc6521490c","controller","unsubscribe","$a86207c5d7f7e1fb$export$4cc632584fd87fae","props","ariaLabel","ariaLabelledby","manager","isLandmarkFocused","setIsLandmarkFocused","$3xCwh$useState","defaultFocus","$3xCwh$useCallback","$3xCwh$useLayoutEffect","$3xCwh$useEffect","_ref_current","landmarkProps","tabIndex"],"sources":["/Users/nathandarma/Documents/App Testing/Diptych/diptych/node_modules/@react-aria/landmark/dist/packages/@react-aria/landmark/src/useLandmark.ts"],"sourcesContent":["/*\n * Copyright 2022 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {AriaLabelingProps, DOMAttributes, FocusableElement, RefObject} from '@react-types/shared';\nimport {useCallback, useEffect, useState} from 'react';\nimport {useLayoutEffect} from '@react-aria/utils';\nimport {useSyncExternalStore} from 'use-sync-external-store/shim/index.js';\n\nexport type AriaLandmarkRole = 'main' | 'region' | 'search' | 'navigation' | 'form' | 'banner' | 'contentinfo' | 'complementary';\n\nexport interface AriaLandmarkProps extends AriaLabelingProps {\n  role: AriaLandmarkRole,\n  focus?: (direction: 'forward' | 'backward') => void\n}\n\nexport interface LandmarkAria {\n  landmarkProps: DOMAttributes\n}\n\n// Increment this version number whenever the\n// LandmarkManagerApi or Landmark interfaces change.\nconst LANDMARK_API_VERSION = 1;\n\n// Minimal API for LandmarkManager that must continue to work between versions.\n// Changes to this interface are considered breaking. New methods/properties are\n// safe to add, but changes or removals are not allowed (same as public APIs).\ninterface LandmarkManagerApi {\n  version: number,\n  createLandmarkController(): LandmarkController,\n  registerLandmark(landmark: Landmark): () => void\n}\n\n// Changes to this interface are considered breaking.\n// New properties MUST be optional so that registering a landmark\n// from an older version of useLandmark against a newer version of\n// LandmarkManager does not crash.\ninterface Landmark {\n  ref: RefObject<FocusableElement | null>,\n  role: AriaLandmarkRole,\n  label?: string,\n  lastFocused?: FocusableElement,\n  focus: (direction: 'forward' | 'backward') => void,\n  blur: () => void\n}\n\nexport interface LandmarkControllerOptions {\n  /**\n   * The element from which to start navigating.\n   * @default document.activeElement\n   */\n  from?: FocusableElement\n}\n\n/** A LandmarkController allows programmatic navigation of landmarks. */\nexport interface LandmarkController {\n  /** Moves focus to the next landmark. */\n  focusNext(opts?: LandmarkControllerOptions): boolean,\n  /** Moves focus to the previous landmark. */\n  focusPrevious(opts?: LandmarkControllerOptions): boolean,\n  /** Moves focus to the main landmark. */\n  focusMain(): boolean,\n  /** Moves focus either forward or backward in the landmark sequence. */\n  navigate(direction: 'forward' | 'backward', opts?: LandmarkControllerOptions): boolean,\n  /**\n   * Disposes the landmark controller. When no landmarks are registered, and no\n   * controllers are active, the landmark keyboard listeners are removed from the page.\n   */\n  dispose(): void\n}\n\n// Symbol under which the singleton landmark manager instance is attached to the document.\nconst landmarkSymbol = Symbol.for('react-aria-landmark-manager');\n\nfunction subscribe(fn: () => void) {\n  document.addEventListener('react-aria-landmark-manager-change', fn);\n  return () => document.removeEventListener('react-aria-landmark-manager-change', fn);\n}\n\nfunction getLandmarkManager(): LandmarkManagerApi | null {\n  if (typeof document === 'undefined') {\n    return null;\n  }\n\n  // Reuse an existing instance if it has the same or greater version.\n  let instance = document[landmarkSymbol];\n  if (instance && instance.version >= LANDMARK_API_VERSION) {\n    return instance;\n  }\n\n  // Otherwise, create a new instance and dispatch an event so anything using the existing\n  // instance updates and re-registers their landmarks with the new one.\n  document[landmarkSymbol] = new LandmarkManager();\n  document.dispatchEvent(new CustomEvent('react-aria-landmark-manager-change'));\n  return document[landmarkSymbol];\n}\n\n// Subscribes a React component to the current landmark manager instance.\nfunction useLandmarkManager(): LandmarkManagerApi | null {\n  return useSyncExternalStore(subscribe, getLandmarkManager, getLandmarkManager);\n}\n\nclass LandmarkManager implements LandmarkManagerApi {\n  private landmarks: Array<Landmark> = [];\n  private isListening = false;\n  private refCount = 0;\n  public version = LANDMARK_API_VERSION;\n\n  constructor() {\n    this.f6Handler = this.f6Handler.bind(this);\n    this.focusinHandler = this.focusinHandler.bind(this);\n    this.focusoutHandler = this.focusoutHandler.bind(this);\n  }\n\n  private setupIfNeeded() {\n    if (this.isListening) {\n      return;\n    }\n    document.addEventListener('keydown', this.f6Handler, {capture: true});\n    document.addEventListener('focusin', this.focusinHandler, {capture: true});\n    document.addEventListener('focusout', this.focusoutHandler, {capture: true});\n    this.isListening = true;\n  }\n\n  private teardownIfNeeded() {\n    if (!this.isListening || this.landmarks.length > 0 || this.refCount > 0) {\n      return;\n    }\n    document.removeEventListener('keydown', this.f6Handler, {capture: true});\n    document.removeEventListener('focusin', this.focusinHandler, {capture: true});\n    document.removeEventListener('focusout', this.focusoutHandler, {capture: true});\n    this.isListening = false;\n  }\n\n  private focusLandmark(landmark: FocusableElement, direction: 'forward' | 'backward') {\n    this.landmarks.find(l => l.ref.current === landmark)?.focus?.(direction);\n  }\n\n  /**\n   * Return set of landmarks with a specific role.\n   */\n  private getLandmarksByRole(role: AriaLandmarkRole) {\n    return new Set(this.landmarks.filter(l => l.role === role));\n  }\n\n  /**\n   * Return first landmark with a specific role.\n   */\n  private getLandmarkByRole(role: AriaLandmarkRole) {\n    return this.landmarks.find(l => l.role === role);\n  }\n\n  private addLandmark(newLandmark: Landmark) {\n    this.setupIfNeeded();\n    if (this.landmarks.find(landmark => landmark.ref === newLandmark.ref) || !newLandmark.ref.current) {\n      return;\n    }\n\n    if (this.landmarks.filter(landmark => landmark.role === 'main').length > 1 && process.env.NODE_ENV !== 'production') {\n      console.error('Page can contain no more than one landmark with the role \"main\".');\n    }\n\n    if (this.landmarks.length === 0) {\n      this.landmarks = [newLandmark];\n      this.checkLabels(newLandmark.role);\n      return;\n    }\n\n\n    // Binary search to insert new landmark based on position in document relative to existing landmarks.\n    // https://developer.mozilla.org/en-US/docs/Web/API/Node/compareDocumentPosition\n    let start = 0;\n    let end = this.landmarks.length - 1;\n    while (start <= end) {\n      let mid = Math.floor((start + end) / 2);\n      let comparedPosition = newLandmark.ref.current.compareDocumentPosition(this.landmarks[mid].ref.current as Node);\n      let isNewAfterExisting = Boolean((comparedPosition & Node.DOCUMENT_POSITION_PRECEDING) || (comparedPosition & Node.DOCUMENT_POSITION_CONTAINS));\n\n      if (isNewAfterExisting) {\n        start = mid + 1;\n      } else {\n        end = mid - 1;\n      }\n    }\n\n    this.landmarks.splice(start, 0, newLandmark);\n    this.checkLabels(newLandmark.role);\n  }\n\n  private updateLandmark(landmark: Pick<Landmark, 'ref'> & Partial<Landmark>) {\n    let index = this.landmarks.findIndex(l => l.ref === landmark.ref);\n    if (index >= 0) {\n      this.landmarks[index] = {...this.landmarks[index], ...landmark};\n      this.checkLabels(this.landmarks[index].role);\n    }\n  }\n\n  private removeLandmark(ref: RefObject<Element | null>) {\n    this.landmarks = this.landmarks.filter(landmark => landmark.ref !== ref);\n    this.teardownIfNeeded();\n  }\n\n  /**\n   * Warn if there are 2+ landmarks with the same role but no label.\n   * Labels for landmarks with the same role must also be unique.\n   *\n   * See https://www.w3.org/WAI/ARIA/apg/practices/landmark-regions/.\n   */\n  private checkLabels(role: AriaLandmarkRole) {\n    let landmarksWithRole = this.getLandmarksByRole(role);\n    if (landmarksWithRole.size > 1) {\n      let duplicatesWithoutLabel = [...landmarksWithRole].filter(landmark => !landmark.label);\n      if (duplicatesWithoutLabel.length > 0 && process.env.NODE_ENV !== 'production') {\n        console.warn(\n          `Page contains more than one landmark with the '${role}' role. If two or more landmarks on a page share the same role, all must be labeled with an aria-label or aria-labelledby attribute: `,\n          duplicatesWithoutLabel.map(landmark => landmark.ref.current)\n        );\n      } else if (process.env.NODE_ENV !== 'production') {\n        let labels = [...landmarksWithRole].map(landmark => landmark.label);\n        let duplicateLabels = labels.filter((item, index) => labels.indexOf(item) !== index);\n\n        duplicateLabels.forEach((label) => {\n          console.warn(\n            `Page contains more than one landmark with the '${role}' role and '${label}' label. If two or more landmarks on a page share the same role, they must have unique labels: `,\n            [...landmarksWithRole].filter(landmark => landmark.label === label).map(landmark => landmark.ref.current)\n          );\n        });\n      }\n    }\n  }\n\n  /**\n   * Get the landmark that is the closest parent in the DOM.\n   * Returns undefined if no parent is a landmark.\n   */\n  private closestLandmark(element: FocusableElement) {\n    let landmarkMap = new Map(this.landmarks.map(l => [l.ref.current, l]));\n    let currentElement = element;\n    while (currentElement && !landmarkMap.has(currentElement) && currentElement !== document.body && currentElement.parentElement) {\n      currentElement = currentElement.parentElement;\n    }\n    return landmarkMap.get(currentElement);\n  }\n\n  /**\n   * Gets the next landmark, in DOM focus order, or previous if backwards is specified.\n   * If last landmark, next should be the first landmark.\n   * If not inside a landmark, will return first landmark.\n   * Returns undefined if there are no landmarks.\n   */\n  private getNextLandmark(element: FocusableElement, {backward}: {backward?: boolean }) {\n    let currentLandmark = this.closestLandmark(element);\n    let nextLandmarkIndex = backward ? this.landmarks.length - 1 : 0;\n    if (currentLandmark) {\n      nextLandmarkIndex = this.landmarks.indexOf(currentLandmark) + (backward ? -1 : 1);\n    }\n\n    let wrapIfNeeded = () => {\n      // When we reach the end of the landmark sequence, fire a custom event that can be listened for by applications.\n      // If this event is canceled, we return immediately. This can be used to implement landmark navigation across iframes.\n      if (nextLandmarkIndex < 0) {\n        if (!element.dispatchEvent(new CustomEvent('react-aria-landmark-navigation', {detail: {direction: 'backward'}, bubbles: true, cancelable: true}))) {\n          return true;\n        }\n\n        nextLandmarkIndex = this.landmarks.length - 1;\n      } else if (nextLandmarkIndex >= this.landmarks.length) {\n        if (!element.dispatchEvent(new CustomEvent('react-aria-landmark-navigation', {detail: {direction: 'forward'}, bubbles: true, cancelable: true}))) {\n          return true;\n        }\n\n        nextLandmarkIndex = 0;\n      }\n\n      if (nextLandmarkIndex < 0 || nextLandmarkIndex >= this.landmarks.length) {\n        return true;\n      }\n\n      return false;\n    };\n\n    if (wrapIfNeeded()) {\n      return undefined;\n    }\n\n    // Skip over hidden landmarks.\n    let i = nextLandmarkIndex;\n    while (this.landmarks[nextLandmarkIndex].ref.current?.closest('[aria-hidden=true]')) {\n      nextLandmarkIndex += backward ? -1 : 1;\n      if (wrapIfNeeded()) {\n        return undefined;\n      }\n\n      if (nextLandmarkIndex === i) {\n        break;\n      }\n    }\n\n    return this.landmarks[nextLandmarkIndex];\n  }\n\n  /**\n   * Look at next landmark. If an element was previously focused inside, restore focus there.\n   * If not, focus the landmark itself.\n   * If no landmarks at all, or none with focusable elements, don't move focus.\n   */\n  private f6Handler(e: KeyboardEvent) {\n    if (e.key === 'F6') {\n      // If alt key pressed, focus main landmark, otherwise navigate forward or backward based on shift key.\n      let handled = e.altKey ? this.focusMain() : this.navigate(e.target as FocusableElement, e.shiftKey);\n      if (handled) {\n        e.preventDefault();\n        e.stopPropagation();\n      }\n    }\n  }\n\n  private focusMain() {\n    let main = this.getLandmarkByRole('main');\n    if (main && main.ref.current && document.contains(main.ref.current)) {\n      this.focusLandmark(main.ref.current, 'forward');\n      return true;\n    }\n\n    return false;\n  }\n\n  private navigate(from: FocusableElement, backward: boolean) {\n    let nextLandmark = this.getNextLandmark(from, {\n      backward\n    });\n\n    if (!nextLandmark) {\n      return false;\n    }\n\n    // If something was previously focused in the next landmark, then return focus to it\n    if (nextLandmark.lastFocused) {\n      let lastFocused = nextLandmark.lastFocused;\n      if (document.body.contains(lastFocused)) {\n        lastFocused.focus();\n        return true;\n      }\n    }\n\n    // Otherwise, focus the landmark itself\n    if (nextLandmark.ref.current && document.contains(nextLandmark.ref.current)) {\n      this.focusLandmark(nextLandmark.ref.current, backward ? 'backward' : 'forward');\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Sets lastFocused for a landmark, if focus is moved within that landmark.\n   * Lets the last focused landmark know it was blurred if something else is focused.\n   */\n  private focusinHandler(e: FocusEvent) {\n    let currentLandmark = this.closestLandmark(e.target as FocusableElement);\n    if (currentLandmark && currentLandmark.ref.current !== e.target) {\n      this.updateLandmark({ref: currentLandmark.ref, lastFocused: e.target as FocusableElement});\n    }\n    let previousFocusedElement = e.relatedTarget as FocusableElement;\n    if (previousFocusedElement) {\n      let closestPreviousLandmark = this.closestLandmark(previousFocusedElement);\n      if (closestPreviousLandmark && closestPreviousLandmark.ref.current === previousFocusedElement) {\n        closestPreviousLandmark.blur();\n      }\n    }\n  }\n\n  /**\n   * Track if the focus is lost to the body. If it is, do cleanup on the landmark that last had focus.\n   */\n  private focusoutHandler(e: FocusEvent) {\n    let previousFocusedElement = e.target as FocusableElement;\n    let nextFocusedElement = e.relatedTarget;\n    // the === document seems to be a jest thing for focus to go there on generic blur event such as landmark.blur();\n    // browsers appear to send focus instead to document.body and the relatedTarget is null when that happens\n    if (!nextFocusedElement || nextFocusedElement === document) {\n      let closestPreviousLandmark = this.closestLandmark(previousFocusedElement);\n      if (closestPreviousLandmark && closestPreviousLandmark.ref.current === previousFocusedElement) {\n        closestPreviousLandmark.blur();\n      }\n    }\n  }\n\n  public createLandmarkController(): LandmarkController {\n    let instance: LandmarkManager | null = this;\n    instance.refCount++;\n    instance.setupIfNeeded();\n    return {\n      navigate(direction, opts) {\n        let element = opts?.from || (document!.activeElement as FocusableElement);\n        return instance!.navigate(element, direction === 'backward');\n      },\n      focusNext(opts) {\n        let element = opts?.from || (document!.activeElement as FocusableElement);\n        return instance!.navigate(element, false);\n      },\n      focusPrevious(opts) {\n        let element = opts?.from || (document!.activeElement as FocusableElement);\n        return instance!.navigate(element, true);\n      },\n      focusMain() {\n        return instance!.focusMain();\n      },\n      dispose() {\n        if (instance) {\n          instance.refCount--;\n          instance.teardownIfNeeded();\n          instance = null;\n        }\n      }\n    };\n  }\n\n  public registerLandmark(landmark: Landmark): () => void {\n    if (this.landmarks.find(l => l.ref === landmark.ref)) {\n      this.updateLandmark(landmark);\n    } else {\n      this.addLandmark(landmark);\n    }\n\n    return () => this.removeLandmark(landmark.ref);\n  }\n}\n\n/** Creates a LandmarkController, which allows programmatic navigation of landmarks. */\nexport function UNSTABLE_createLandmarkController(): LandmarkController {\n  // Get the current landmark manager and create a controller using it.\n  let instance: LandmarkManagerApi | null = getLandmarkManager();\n  let controller = instance?.createLandmarkController();\n\n  let unsubscribe = subscribe(() => {\n    // If the landmark manager changes, dispose the old\n    // controller and create a new one.\n    controller?.dispose();\n    instance = getLandmarkManager();\n    controller = instance?.createLandmarkController();\n  });\n\n  // Return a wrapper that proxies requests to the current controller instance.\n  return {\n    navigate(direction, opts) {\n      return controller!.navigate(direction, opts);\n    },\n    focusNext(opts) {\n      return controller!.focusNext(opts);\n    },\n    focusPrevious(opts) {\n      return controller!.focusPrevious(opts);\n    },\n    focusMain() {\n      return controller!.focusMain();\n    },\n    dispose() {\n      controller?.dispose();\n      unsubscribe();\n      controller = undefined;\n      instance = null;\n    }\n  };\n}\n\n/**\n * Provides landmark navigation in an application. Call this with a role and label to register a landmark navigable with F6.\n * @param props - Props for the landmark.\n * @param ref - Ref to the landmark.\n */\nexport function useLandmark(props: AriaLandmarkProps, ref: RefObject<FocusableElement | null>): LandmarkAria {\n  const {\n    role,\n    'aria-label': ariaLabel,\n    'aria-labelledby': ariaLabelledby,\n    focus\n  } = props;\n  let manager = useLandmarkManager();\n  let label = ariaLabel || ariaLabelledby;\n  let [isLandmarkFocused, setIsLandmarkFocused] = useState(false);\n\n  let defaultFocus = useCallback(() => {\n    setIsLandmarkFocused(true);\n  }, [setIsLandmarkFocused]);\n\n  let blur = useCallback(() => {\n    setIsLandmarkFocused(false);\n  }, [setIsLandmarkFocused]);\n\n  useLayoutEffect(() => {\n    if (manager) {\n      return manager.registerLandmark({ref, label, role, focus: focus || defaultFocus, blur});\n    }\n  }, [manager, label, ref, role, focus, defaultFocus, blur]);\n\n  useEffect(() => {\n    if (isLandmarkFocused) {\n      ref.current?.focus();\n    }\n  }, [isLandmarkFocused, ref]);\n\n  return {\n    landmarkProps: {\n      role,\n      tabIndex: isLandmarkFocused ? -1 : undefined,\n      'aria-label': ariaLabel,\n      'aria-labelledby': ariaLabelledby\n    }\n  };\n}\n"],"mappings":";;;;AAAA;;;;;;;;;;;;AA4BA;AACA;AACA,MAAMA,0CAAA,GAAuB;AAiD7B;AACA,MAAMC,oCAAA,GAAiBC,MAAA,CAAOC,GAAG,CAAC;AAElC,SAASC,gCAAUC,EAAc;EAC/BC,QAAA,CAASC,gBAAgB,CAAC,sCAAsCF,EAAA;EAChE,OAAO,MAAMC,QAAA,CAASE,mBAAmB,CAAC,sCAAsCH,EAAA;AAClF;AAEA,SAASI,yCAAA;EACP,IAAI,OAAOH,QAAA,KAAa,aACtB,OAAO;EAGT;EACA,IAAII,QAAA,GAAWJ,QAAQ,CAACL,oCAAA,CAAe;EACvC,IAAIS,QAAA,IAAYA,QAAA,CAASC,OAAO,IAAIX,0CAAA,EAClC,OAAOU,QAAA;EAGT;EACA;EACAJ,QAAQ,CAACL,oCAAA,CAAe,GAAG,IAAIW,qCAAA;EAC/BN,QAAA,CAASO,aAAa,CAAC,IAAIC,WAAA,CAAY;EACvC,OAAOR,QAAQ,CAACL,oCAAA,CAAe;AACjC;AAEA;AACA,SAASc,yCAAA;EACP,OAAO,IAAAC,2BAAmB,EAAEZ,+BAAA,EAAWK,wCAAA,EAAoBA,wCAAA;AAC7D;AAEA,MAAMG,qCAAA;EAYIK,cAAA,EAAgB;IACtB,IAAI,IAAI,CAACC,WAAW,EAClB;IAEFZ,QAAA,CAASC,gBAAgB,CAAC,WAAW,IAAI,CAACY,SAAS,EAAE;MAACC,OAAA,EAAS;IAAI;IACnEd,QAAA,CAASC,gBAAgB,CAAC,WAAW,IAAI,CAACc,cAAc,EAAE;MAACD,OAAA,EAAS;IAAI;IACxEd,QAAA,CAASC,gBAAgB,CAAC,YAAY,IAAI,CAACe,eAAe,EAAE;MAACF,OAAA,EAAS;IAAI;IAC1E,IAAI,CAACF,WAAW,GAAG;EACrB;EAEQK,iBAAA,EAAmB;IACzB,IAAI,CAAC,IAAI,CAACL,WAAW,IAAI,IAAI,CAACM,SAAS,CAACC,MAAM,GAAG,KAAK,IAAI,CAACC,QAAQ,GAAG,GACpE;IAEFpB,QAAA,CAASE,mBAAmB,CAAC,WAAW,IAAI,CAACW,SAAS,EAAE;MAACC,OAAA,EAAS;IAAI;IACtEd,QAAA,CAASE,mBAAmB,CAAC,WAAW,IAAI,CAACa,cAAc,EAAE;MAACD,OAAA,EAAS;IAAI;IAC3Ed,QAAA,CAASE,mBAAmB,CAAC,YAAY,IAAI,CAACc,eAAe,EAAE;MAACF,OAAA,EAAS;IAAI;IAC7E,IAAI,CAACF,WAAW,GAAG;EACrB;EAEQS,cAAcC,QAA0B,EAAEC,SAAiC,EAAE;QACnFC,0BAAA,EAAAC,oBAAA;KAAAA,oBAAA,OAAI,CAACP,SAAS,CAACQ,IAAI,CAACC,CAAA,IAAKA,CAAA,CAAEC,GAAG,CAACC,OAAO,KAAKP,QAAA,eAA3CG,oBAAA,wBAAAD,0BAAA,GAAAC,oBAAA,CAAsDK,KAAK,cAA3DN,0BAAA,uBAAAA,0BAAA,CAAAO,IAAA,CAAAN,oBAAA,EAA8DF,SAAA;EAChE;EAEA;;;EAGAS,kBAAQA,CAAmBC,IAAsB,EAAE;IACjD,OAAO,IAAIC,GAAA,CAAI,IAAI,CAAChB,SAAS,CAACiB,MAAM,CAACR,CAAA,IAAKA,CAAA,CAAEM,IAAI,KAAKA,IAAA;EACvD;EAEA;;;EAGAG,iBAAQA,CAAkBH,IAAsB,EAAE;IAChD,OAAO,IAAI,CAACf,SAAS,CAACQ,IAAI,CAACC,CAAA,IAAKA,CAAA,CAAEM,IAAI,KAAKA,IAAA;EAC7C;EAEQI,YAAYC,WAAqB,EAAE;IACzC,IAAI,CAAC3B,aAAa;IAClB,IAAI,IAAI,CAACO,SAAS,CAACQ,IAAI,CAACJ,QAAA,IAAYA,QAAA,CAASM,GAAG,KAAKU,WAAA,CAAYV,GAAG,KAAK,CAACU,WAAA,CAAYV,GAAG,CAACC,OAAO,EAC/F;IAGF,IAAI,IAAI,CAACX,SAAS,CAACiB,MAAM,CAACb,QAAA,IAAYA,QAAA,CAASW,IAAI,KAAK,QAAQd,MAAM,GAAG,KAAKoB,OAAA,CAAQC,GAAG,CAACC,QAAQ,KAAK,cACrGC,OAAA,CAAQC,KAAK,CAAC;IAGhB,IAAI,IAAI,CAACzB,SAAS,CAACC,MAAM,KAAK,GAAG;MAC/B,IAAI,CAACD,SAAS,GAAG,CAACoB,WAAA,CAAY;MAC9B,IAAI,CAACM,WAAW,CAACN,WAAA,CAAYL,IAAI;MACjC;IACF;IAGA;IACA;IACA,IAAIY,KAAA,GAAQ;IACZ,IAAIC,GAAA,GAAM,IAAI,CAAC5B,SAAS,CAACC,MAAM,GAAG;IAClC,OAAO0B,KAAA,IAASC,GAAA,EAAK;MACnB,IAAIC,GAAA,GAAMC,IAAA,CAAKC,KAAK,CAAC,CAACJ,KAAA,GAAQC,GAAE,IAAK;MACrC,IAAII,gBAAA,GAAmBZ,WAAA,CAAYV,GAAG,CAACC,OAAO,CAACsB,uBAAuB,CAAC,IAAI,CAACjC,SAAS,CAAC6B,GAAA,CAAI,CAACnB,GAAG,CAACC,OAAO;MACtG,IAAIuB,kBAAA,GAAqBC,OAAA,CAAQH,gBAAC,GAAmBI,IAAA,CAAKC,2BAA2B,IAAML,gBAAA,GAAmBI,IAAA,CAAKE,0BAA0B;MAE7I,IAAIJ,kBAAA,EACFP,KAAA,GAAQE,GAAA,GAAM,OAEdD,GAAA,GAAMC,GAAA,GAAM;IAEhB;IAEA,IAAI,CAAC7B,SAAS,CAACuC,MAAM,CAACZ,KAAA,EAAO,GAAGP,WAAA;IAChC,IAAI,CAACM,WAAW,CAACN,WAAA,CAAYL,IAAI;EACnC;EAEQyB,eAAepC,QAAmD,EAAE;IAC1E,IAAIqC,KAAA,GAAQ,IAAI,CAACzC,SAAS,CAAC0C,SAAS,CAACjC,CAAA,IAAKA,CAAA,CAAEC,GAAG,KAAKN,QAAA,CAASM,GAAG;IAChE,IAAI+B,KAAA,IAAS,GAAG;MACd,IAAI,CAACzC,SAAS,CAACyC,KAAA,CAAM,GAAG;QAAC,GAAG,IAAI,CAACzC,SAAS,CAACyC,KAAA,CAAM;QAAE,GAAGrC;MAAQ;MAC9D,IAAI,CAACsB,WAAW,CAAC,IAAI,CAAC1B,SAAS,CAACyC,KAAA,CAAM,CAAC1B,IAAI;IAC7C;EACF;EAEQ4B,eAAejC,GAA8B,EAAE;IACrD,IAAI,CAACV,SAAS,GAAG,IAAI,CAACA,SAAS,CAACiB,MAAM,CAACb,QAAA,IAAYA,QAAA,CAASM,GAAG,KAAKA,GAAA;IACpE,IAAI,CAACX,gBAAgB;EACvB;EAEA;;;;;;EAMA2B,WAAQA,CAAYX,IAAsB,EAAE;IAC1C,IAAI6B,iBAAA,GAAoB,IAAI,CAAC9B,kBAAkB,CAACC,IAAA;IAChD,IAAI6B,iBAAA,CAAkBC,IAAI,GAAG,GAAG;MAC9B,IAAIC,sBAAA,GAAyB,C,GAAIF,iBAAA,CAAkB,CAAC3B,MAAM,CAACb,QAAA,IAAY,CAACA,QAAA,CAAS2C,KAAK;MACtF,IAAID,sBAAA,CAAuB7C,MAAM,GAAG,KAAKoB,OAAA,CAAQC,GAAG,CAACC,QAAQ,KAAK,cAChEC,OAAA,CAAQwB,IAAI,CACV,kDAAkDjC,IAAA,uIAA2I,EAC7L+B,sBAAA,CAAuBG,GAAG,CAAC7C,QAAA,IAAYA,QAAA,CAASM,GAAG,CAACC,OAAO,QAExD,IAAIU,OAAA,CAAQC,GAAG,CAACC,QAAQ,KAAK,cAAc;QAChD,IAAI2B,MAAA,GAAS,C,GAAIN,iBAAA,CAAkB,CAACK,GAAG,CAAC7C,QAAA,IAAYA,QAAA,CAAS2C,KAAK;QAClE,IAAII,eAAA,GAAkBD,MAAA,CAAOjC,MAAM,CAAC,CAACmC,IAAA,EAAMX,KAAA,KAAUS,MAAA,CAAOG,OAAO,CAACD,IAAA,MAAUX,KAAA;QAE9EU,eAAA,CAAgBG,OAAO,CAAEP,KAAA;UACvBvB,OAAA,CAAQwB,IAAI,CACV,kDAAkDjC,IAAA,eAAmBgC,KAAA,iGAAsG,EAC3K,C,GAAIH,iBAAA,CAAkB,CAAC3B,MAAM,CAACb,QAAA,IAAYA,QAAA,CAAS2C,KAAK,KAAKA,KAAA,EAAOE,GAAG,CAAC7C,QAAA,IAAYA,QAAA,CAASM,GAAG,CAACC,OAAO;QAE5G;MACF;IACF;EACF;EAEA;;;;EAIA4C,eAAQA,CAAgBC,OAAyB,EAAE;IACjD,IAAIC,WAAA,GAAc,IAAIC,GAAA,CAAI,IAAI,CAAC1D,SAAS,CAACiD,GAAG,CAACxC,CAAA,IAAK,CAACA,CAAA,CAAEC,GAAG,CAACC,OAAO,EAAEF,CAAA,CAAE;IACpE,IAAIkD,cAAA,GAAiBH,OAAA;IACrB,OAAOG,cAAA,IAAkB,CAACF,WAAA,CAAYG,GAAG,CAACD,cAAA,KAAmBA,cAAA,KAAmB7E,QAAA,CAAS+E,IAAI,IAAIF,cAAA,CAAeG,aAAa,EAC3HH,cAAA,GAAiBA,cAAA,CAAeG,aAAa;IAE/C,OAAOL,WAAA,CAAYM,GAAG,CAACJ,cAAA;EACzB;EAEA;;;;;;EAMAK,eAAQA,CAAgBR,OAAyB,EAAE;IAAAS,QAAA,EAACA;EAAQ,CAAwB,EAAE;QAqC7EC,6CAAA;IApCP,IAAIC,eAAA,GAAkB,IAAI,CAACZ,eAAe,CAACC,OAAA;IAC3C,IAAIY,iBAAA,GAAoBH,QAAA,GAAW,IAAI,CAACjE,SAAS,CAACC,MAAM,GAAG,IAAI;IAC/D,IAAIkE,eAAA,EACFC,iBAAA,GAAoB,IAAI,CAACpE,SAAS,CAACqD,OAAO,CAACc,eAAA,KAAoBF,QAAA,GAAW,KAAK;IAGjF,IAAII,YAAA,GAAeA,CAAA;MACjB;MACA;MACA,IAAID,iBAAA,GAAoB,GAAG;QACzB,IAAI,CAACZ,OAAA,CAAQnE,aAAa,CAAC,IAAIC,WAAA,CAAY,kCAAkC;UAACgF,MAAA,EAAQ;YAACjE,SAAA,EAAW;UAAU;UAAGkE,OAAA,EAAS;UAAMC,UAAA,EAAY;QAAI,KAC5I,OAAO;QAGTJ,iBAAA,GAAoB,IAAI,CAACpE,SAAS,CAACC,MAAM,GAAG;MAC9C,OAAO,IAAImE,iBAAA,IAAqB,IAAI,CAACpE,SAAS,CAACC,MAAM,EAAE;QACrD,IAAI,CAACuD,OAAA,CAAQnE,aAAa,CAAC,IAAIC,WAAA,CAAY,kCAAkC;UAACgF,MAAA,EAAQ;YAACjE,SAAA,EAAW;UAAS;UAAGkE,OAAA,EAAS;UAAMC,UAAA,EAAY;QAAI,KAC3I,OAAO;QAGTJ,iBAAA,GAAoB;MACtB;MAEA,IAAIA,iBAAA,GAAoB,KAAKA,iBAAA,IAAqB,IAAI,CAACpE,SAAS,CAACC,MAAM,EACrE,OAAO;MAGT,OAAO;IACT;IAEA,IAAIoE,YAAA,IACF,OAAOI,SAAA;IAGT;IACA,IAAIC,CAAA,GAAIN,iBAAA;IACR,QAAOF,6CAAA,OAAI,CAAClE,SAAS,CAACoE,iBAAA,CAAkB,CAAC1D,GAAG,CAACC,OAAO,cAA7CuD,6CAAA,uBAAAA,6CAAA,CAA+CS,OAAO,CAAC,uBAAuB;MACnFP,iBAAA,IAAqBH,QAAA,GAAW,KAAK;MACrC,IAAII,YAAA,IACF,OAAOI,SAAA;MAGT,IAAIL,iBAAA,KAAsBM,CAAA,EACxB;IAEJ;IAEA,OAAO,IAAI,CAAC1E,SAAS,CAACoE,iBAAA,CAAkB;EAC1C;EAEA;;;;;EAKAzE,SAAQA,CAAUiF,CAAgB,EAAE;IAClC,IAAIA,CAAA,CAAEC,GAAG,KAAK,MAAM;MAClB;MACA,IAAIC,OAAA,GAAUF,CAAA,CAAEG,MAAM,GAAG,IAAI,CAACC,SAAS,KAAK,IAAI,CAACC,QAAQ,CAACL,CAAA,CAAEM,MAAM,EAAsBN,CAAA,CAAEO,QAAQ;MAClG,IAAIL,OAAA,EAAS;QACXF,CAAA,CAAEQ,cAAc;QAChBR,CAAA,CAAES,eAAe;MACnB;IACF;EACF;EAEQL,UAAA,EAAY;IAClB,IAAIM,IAAA,GAAO,IAAI,CAACpE,iBAAiB,CAAC;IAClC,IAAIoE,IAAA,IAAQA,IAAA,CAAK5E,GAAG,CAACC,OAAO,IAAI7B,QAAA,CAASyG,QAAQ,CAACD,IAAA,CAAK5E,GAAG,CAACC,OAAO,GAAG;MACnE,IAAI,CAACR,aAAa,CAACmF,IAAA,CAAK5E,GAAG,CAACC,OAAO,EAAE;MACrC,OAAO;IACT;IAEA,OAAO;EACT;EAEQsE,SAASO,IAAsB,EAAEvB,QAAiB,EAAE;IAC1D,IAAIwB,YAAA,GAAe,IAAI,CAACzB,eAAe,CAACwB,IAAA,EAAM;gBAC5CvB;IACF;IAEA,IAAI,CAACwB,YAAA,EACH,OAAO;IAGT;IACA,IAAIA,YAAA,CAAaC,WAAW,EAAE;MAC5B,IAAIA,WAAA,GAAcD,YAAA,CAAaC,WAAW;MAC1C,IAAI5G,QAAA,CAAS+E,IAAI,CAAC0B,QAAQ,CAACG,WAAA,GAAc;QACvCA,WAAA,CAAY9E,KAAK;QACjB,OAAO;MACT;IACF;IAEA;IACA,IAAI6E,YAAA,CAAa/E,GAAG,CAACC,OAAO,IAAI7B,QAAA,CAASyG,QAAQ,CAACE,YAAA,CAAa/E,GAAG,CAACC,OAAO,GAAG;MAC3E,IAAI,CAACR,aAAa,CAACsF,YAAA,CAAa/E,GAAG,CAACC,OAAO,EAAEsD,QAAA,GAAW,aAAa;MACrE,OAAO;IACT;IAEA,OAAO;EACT;EAEA;;;;EAIApE,cAAQA,CAAe+E,CAAa,EAAE;IACpC,IAAIT,eAAA,GAAkB,IAAI,CAACZ,eAAe,CAACqB,CAAA,CAAEM,MAAM;IACnD,IAAIf,eAAA,IAAmBA,eAAA,CAAgBzD,GAAG,CAACC,OAAO,KAAKiE,CAAA,CAAEM,MAAM,EAC7D,IAAI,CAAC1C,cAAc,CAAC;MAAC9B,GAAA,EAAKyD,eAAA,CAAgBzD,GAAG;MAAEgF,WAAA,EAAad,CAAA,CAAEM;IAA0B;IAE1F,IAAIS,sBAAA,GAAyBf,CAAA,CAAEgB,aAAa;IAC5C,IAAID,sBAAA,EAAwB;MAC1B,IAAIE,uBAAA,GAA0B,IAAI,CAACtC,eAAe,CAACoC,sBAAA;MACnD,IAAIE,uBAAA,IAA2BA,uBAAA,CAAwBnF,GAAG,CAACC,OAAO,KAAKgF,sBAAA,EACrEE,uBAAA,CAAwBC,IAAI;IAEhC;EACF;EAEA;;;EAGAhG,eAAQA,CAAgB8E,CAAa,EAAE;IACrC,IAAIe,sBAAA,GAAyBf,CAAA,CAAEM,MAAM;IACrC,IAAIa,kBAAA,GAAqBnB,CAAA,CAAEgB,aAAa;IACxC;IACA;IACA,IAAI,CAACG,kBAAA,IAAsBA,kBAAA,KAAuBjH,QAAA,EAAU;MAC1D,IAAI+G,uBAAA,GAA0B,IAAI,CAACtC,eAAe,CAACoC,sBAAA;MACnD,IAAIE,uBAAA,IAA2BA,uBAAA,CAAwBnF,GAAG,CAACC,OAAO,KAAKgF,sBAAA,EACrEE,uBAAA,CAAwBC,IAAI;IAEhC;EACF;EAEOE,yBAAA,EAA+C;IACpD,IAAI9G,QAAA,GAAmC,IAAI;IAC3CA,QAAA,CAASgB,QAAQ;IACjBhB,QAAA,CAASO,aAAa;IACtB,OAAO;MACLwF,SAAS5E,SAAS,EAAE4F,IAAI;QACtB,IAAIzC,OAAA,GAAU,CAAAyC,IAAA,aAAAA,IAAA,uBAAAA,IAAA,CAAMT,IAAI,KAAK1G,QAAA,CAAUoH,aAAa;QACpD,OAAOhH,QAAA,CAAU+F,QAAQ,CAACzB,OAAA,EAASnD,SAAA,KAAc;MACnD;MACA8F,UAAUF,IAAI;QACZ,IAAIzC,OAAA,GAAU,CAAAyC,IAAA,aAAAA,IAAA,uBAAAA,IAAA,CAAMT,IAAI,KAAK1G,QAAA,CAAUoH,aAAa;QACpD,OAAOhH,QAAA,CAAU+F,QAAQ,CAACzB,OAAA,EAAS;MACrC;MACA4C,cAAcH,IAAI;QAChB,IAAIzC,OAAA,GAAU,CAAAyC,IAAA,aAAAA,IAAA,uBAAAA,IAAA,CAAMT,IAAI,KAAK1G,QAAA,CAAUoH,aAAa;QACpD,OAAOhH,QAAA,CAAU+F,QAAQ,CAACzB,OAAA,EAAS;MACrC;MACAwB,UAAA;QACE,OAAO9F,QAAA,CAAU8F,SAAS;MAC5B;MACAqB,QAAA;QACE,IAAInH,QAAA,EAAU;UACZA,QAAA,CAASgB,QAAQ;UACjBhB,QAAA,CAASa,gBAAgB;UACzBb,QAAA,GAAW;QACb;MACF;IACF;EACF;EAEOoH,iBAAiBlG,QAAkB,EAAc;IACtD,IAAI,IAAI,CAACJ,SAAS,CAACQ,IAAI,CAACC,CAAA,IAAKA,CAAA,CAAEC,GAAG,KAAKN,QAAA,CAASM,GAAG,GACjD,IAAI,CAAC8B,cAAc,CAACpC,QAAA,OAEpB,IAAI,CAACe,WAAW,CAACf,QAAA;IAGnB,OAAO,MAAM,IAAI,CAACuC,cAAc,CAACvC,QAAA,CAASM,GAAG;EAC/C;EA9TA6F,YAAA,EAAc;SALNvG,SAAA,GAA6B,EAAE;SAC/BN,WAAA,GAAc;SACdQ,QAAA,GAAW;SACZf,OAAA,GAAUX,0CAAA;IAGf,IAAI,CAACmB,SAAS,GAAG,IAAI,CAACA,SAAS,CAAC6G,IAAI,CAAC,IAAI;IACzC,IAAI,CAAC3G,cAAc,GAAG,IAAI,CAACA,cAAc,CAAC2G,IAAI,CAAC,IAAI;IACnD,IAAI,CAAC1G,eAAe,GAAG,IAAI,CAACA,eAAe,CAAC0G,IAAI,CAAC,IAAI;EACvD;AA2TF;AAGO,SAASC,0CAAA;EACd;EACA,IAAIvH,QAAA,GAAsCD,wCAAA;EAC1C,IAAIyH,UAAA,GAAaxH,QAAA,aAAAA,QAAA,uBAAAA,QAAA,CAAU8G,wBAAwB;EAEnD,IAAIW,WAAA,GAAc/H,+BAAA,CAAU;IAC1B;IACA;IACA8H,UAAA,aAAAA,UAAA,uBAAAA,UAAA,CAAYL,OAAO;IACnBnH,QAAA,GAAWD,wCAAA;IACXyH,UAAA,GAAaxH,QAAA,aAAAA,QAAA,uBAAAA,QAAA,CAAU8G,wBAAwB;EACjD;EAEA;EACA,OAAO;IACLf,SAAS5E,SAAS,EAAE4F,IAAI;MACtB,OAAOS,UAAA,CAAYzB,QAAQ,CAAC5E,SAAA,EAAW4F,IAAA;IACzC;IACAE,UAAUF,IAAI;MACZ,OAAOS,UAAA,CAAYP,SAAS,CAACF,IAAA;IAC/B;IACAG,cAAcH,IAAI;MAChB,OAAOS,UAAA,CAAYN,aAAa,CAACH,IAAA;IACnC;IACAjB,UAAA;MACE,OAAO0B,UAAA,CAAY1B,SAAS;IAC9B;IACAqB,QAAA;MACEK,UAAA,aAAAA,UAAA,uBAAAA,UAAA,CAAYL,OAAO;MACnBM,WAAA;MACAD,UAAA,GAAajC,SAAA;MACbvF,QAAA,GAAW;IACb;EACF;AACF;AAOO,SAAS0H,0CAAYC,KAAwB,EAAEnG,GAAuC;EAC3F,MAAM;IAAAK,IAAA,EACJA,IAAI;IACJ,cAAc+F,SAAS;IACvB,mBAAmBC,cAAc;IAAAnG,KAAA,EACjCA;EAAK,CACN,GAAGiG,KAAA;EACJ,IAAIG,OAAA,GAAUzH,wCAAA;EACd,IAAIwD,KAAA,GAAQ+D,SAAA,IAAaC,cAAA;EACzB,IAAI,CAACE,iBAAA,EAAmBC,oBAAA,CAAqB,GAAG,IAAAC,eAAO,EAAE;EAEzD,IAAIC,YAAA,GAAe,IAAAC,kBAAU,EAAE;IAC7BH,oBAAA,CAAqB;EACvB,GAAG,CAACA,oBAAA,CAAqB;EAEzB,IAAIpB,IAAA,GAAO,IAAAuB,kBAAU,EAAE;IACrBH,oBAAA,CAAqB;EACvB,GAAG,CAACA,oBAAA,CAAqB;EAEzB,IAAAI,sBAAc,EAAE;IACd,IAAIN,OAAA,EACF,OAAOA,OAAA,CAAQV,gBAAgB,CAAC;WAAC5F,GAAA;aAAKqC,KAAA;YAAOhC,IAAA;MAAMH,KAAA,EAAOA,KAAA,IAASwG,YAAA;YAActB;IAAI;EAEzF,GAAG,CAACkB,OAAA,EAASjE,KAAA,EAAOrC,GAAA,EAAKK,IAAA,EAAMH,KAAA,EAAOwG,YAAA,EAActB,IAAA,CAAK;EAEzD,IAAAyB,gBAAQ,EAAE;QAENC,YAAA;IADF,IAAIP,iBAAA,GACFO,YAAA,GAAA9G,GAAA,CAAIC,OAAO,cAAX6G,YAAA,uBAAAA,YAAA,CAAa5G,KAAK;EAEtB,GAAG,CAACqG,iBAAA,EAAmBvG,GAAA,CAAI;EAE3B,OAAO;IACL+G,aAAA,EAAe;YACb1G,IAAA;MACA2G,QAAA,EAAUT,iBAAA,GAAoB,KAAKxC,SAAA;MACnC,cAAcqC,SAAA;MACd,mBAAmBC;IACrB;EACF;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}