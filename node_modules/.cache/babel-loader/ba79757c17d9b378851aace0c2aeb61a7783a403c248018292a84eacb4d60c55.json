{"ast":null,"code":"/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */class $16805b1b18093c5f$export$de3fdf6493c353d {\n  *[Symbol.iterator]() {\n    yield* [...this.rows];\n  }\n  get size() {\n    return [...this.rows].length;\n  }\n  getKeys() {\n    return this.keyMap.keys();\n  }\n  getKeyBefore(key) {\n    let node = this.keyMap.get(key);\n    var _node_prevKey;\n    return node ? (_node_prevKey = node.prevKey) !== null && _node_prevKey !== void 0 ? _node_prevKey : null : null;\n  }\n  getKeyAfter(key) {\n    let node = this.keyMap.get(key);\n    var _node_nextKey;\n    return node ? (_node_nextKey = node.nextKey) !== null && _node_nextKey !== void 0 ? _node_nextKey : null : null;\n  }\n  getFirstKey() {\n    var _;\n    return (_ = [...this.rows][0]) === null || _ === void 0 ? void 0 : _.key;\n  }\n  getLastKey() {\n    var _rows_;\n    let rows = [...this.rows];\n    return (_rows_ = rows[rows.length - 1]) === null || _rows_ === void 0 ? void 0 : _rows_.key;\n  }\n  getItem(key) {\n    var _this_keyMap_get;\n    return (_this_keyMap_get = this.keyMap.get(key)) !== null && _this_keyMap_get !== void 0 ? _this_keyMap_get : null;\n  }\n  at(idx) {\n    const keys = [...this.getKeys()];\n    return this.getItem(keys[idx]);\n  }\n  getChildren(key) {\n    let node = this.keyMap.get(key);\n    return (node === null || node === void 0 ? void 0 : node.childNodes) || [];\n  }\n  constructor(opts) {\n    this.keyMap = new Map();\n    this.keyMap = new Map();\n    this.columnCount = opts === null || opts === void 0 ? void 0 : opts.columnCount;\n    this.rows = [];\n    let visit = node => {\n      // If the node is the same object as the previous node for the same key,\n      // we can skip this node and its children. We always visit columns though,\n      // because we depend on order to build the columns array.\n      let prevNode = this.keyMap.get(node.key);\n      if (opts.visitNode) node = opts.visitNode(node);\n      this.keyMap.set(node.key, node);\n      let childKeys = new Set();\n      let last = null;\n      let rowHasCellWithColSpan = false;\n      if (node.type === 'item') {\n        var _child_props;\n        for (let child of node.childNodes) if (((_child_props = child.props) === null || _child_props === void 0 ? void 0 : _child_props.colSpan) !== undefined) {\n          rowHasCellWithColSpan = true;\n          break;\n        }\n      }\n      for (let child of node.childNodes) {\n        if (child.type === 'cell' && rowHasCellWithColSpan) {\n          var _child_props1, _child_props2;\n          child.colspan = (_child_props1 = child.props) === null || _child_props1 === void 0 ? void 0 : _child_props1.colSpan;\n          child.colSpan = (_child_props2 = child.props) === null || _child_props2 === void 0 ? void 0 : _child_props2.colSpan;\n          var _last_colIndex, _last_colSpan;\n          child.colIndex = !last ? child.index : ((_last_colIndex = last.colIndex) !== null && _last_colIndex !== void 0 ? _last_colIndex : last.index) + ((_last_colSpan = last.colSpan) !== null && _last_colSpan !== void 0 ? _last_colSpan : 1);\n        }\n        if (child.type === 'cell' && child.parentKey == null)\n          // if child is a cell parent key isn't already established by the collection, match child node to parent row\n          child.parentKey = node.key;\n        childKeys.add(child.key);\n        if (last) {\n          last.nextKey = child.key;\n          child.prevKey = last.key;\n        } else child.prevKey = null;\n        visit(child);\n        last = child;\n      }\n      if (last) last.nextKey = null;\n      // Remove deleted nodes and their children from the key map\n      if (prevNode) {\n        for (let child of prevNode.childNodes) if (!childKeys.has(child.key)) remove(child);\n      }\n    };\n    let remove = node => {\n      this.keyMap.delete(node.key);\n      for (let child of node.childNodes) if (this.keyMap.get(child.key) === child) remove(child);\n    };\n    let last = null;\n    for (let [i, node] of opts.items.entries()) {\n      var _node_level, _node_key, _node_type, _node_value, _node_textValue, _node_index;\n      let rowNode = {\n        ...node,\n        level: (_node_level = node.level) !== null && _node_level !== void 0 ? _node_level : 0,\n        key: (_node_key = node.key) !== null && _node_key !== void 0 ? _node_key : 'row-' + i,\n        type: (_node_type = node.type) !== null && _node_type !== void 0 ? _node_type : 'row',\n        value: (_node_value = node.value) !== null && _node_value !== void 0 ? _node_value : null,\n        hasChildNodes: true,\n        childNodes: [...node.childNodes],\n        rendered: node.rendered,\n        textValue: (_node_textValue = node.textValue) !== null && _node_textValue !== void 0 ? _node_textValue : '',\n        index: (_node_index = node.index) !== null && _node_index !== void 0 ? _node_index : i\n      };\n      if (last) {\n        last.nextKey = rowNode.key;\n        rowNode.prevKey = last.key;\n      } else rowNode.prevKey = null;\n      this.rows.push(rowNode);\n      visit(rowNode);\n      last = rowNode;\n    }\n    if (last) last.nextKey = null;\n  }\n}\nexport { $16805b1b18093c5f$export$de3fdf6493c353d as GridCollection };","map":{"version":3,"names":["$16805b1b18093c5f$export$de3fdf6493c353d","Symbol","iterator","rows","size","length","getKeys","keyMap","keys","getKeyBefore","key","node","get","_node_prevKey","prevKey","getKeyAfter","_node_nextKey","nextKey","getFirstKey","_","getLastKey","_rows_","getItem","_this_keyMap_get","at","idx","getChildren","childNodes","constructor","opts","Map","columnCount","visit","prevNode","visitNode","set","childKeys","Set","last","rowHasCellWithColSpan","type","_child_props","child","props","colSpan","undefined","_child_props1","_child_props2","colspan","_last_colIndex","_last_colSpan","colIndex","index","parentKey","add","has","remove","delete","i","items","entries","_node_level","_node_key","_node_type","_node_value","_node_textValue","_node_index","rowNode","level","value","hasChildNodes","rendered","textValue","push"],"sources":["/Users/nathandarma/Documents/App Testing/Diptych/diptych/node_modules/@react-stately/grid/dist/packages/@react-stately/grid/src/GridCollection.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {GridNode, GridRow, GridCollection as IGridCollection} from '@react-types/grid';\nimport {Key} from '@react-types/shared';\n\ninterface GridCollectionOptions<T> {\n  columnCount: number,\n  items: GridRow<T>[],\n  visitNode?: (cell: GridNode<T>) => GridNode<T>\n}\n\nexport class GridCollection<T> implements IGridCollection<T> {\n  keyMap: Map<Key, GridNode<T>> = new Map();\n  columnCount: number;\n  rows: GridNode<T>[];\n\n  constructor(opts: GridCollectionOptions<T>) {\n    this.keyMap = new Map();\n    this.columnCount = opts?.columnCount;\n    this.rows = [];\n\n    let visit = (node: GridNode<T>) => {\n      // If the node is the same object as the previous node for the same key,\n      // we can skip this node and its children. We always visit columns though,\n      // because we depend on order to build the columns array.\n      let prevNode = this.keyMap.get(node.key);\n      if (opts.visitNode) {\n        node = opts.visitNode(node);\n      }\n\n      this.keyMap.set(node.key, node);\n\n      let childKeys = new Set();\n      let last: GridNode<T> | null = null;\n      let rowHasCellWithColSpan = false;\n\n      if (node.type === 'item') {\n        for (let child of node.childNodes) {\n          if (child.props?.colSpan !== undefined) {\n            rowHasCellWithColSpan = true;\n            break;\n          }\n        }\n      }\n\n      for (let child of node.childNodes as Iterable<GridNode<T>>) {\n        if (child.type === 'cell' && rowHasCellWithColSpan) {\n          child.colspan = child.props?.colSpan;\n          child.colSpan = child.props?.colSpan;\n          child.colIndex = !last ? child.index : (last.colIndex ?? last.index) + (last.colSpan ?? 1);\n        }\n\n        if (child.type === 'cell' && child.parentKey == null) {\n          // if child is a cell parent key isn't already established by the collection, match child node to parent row\n          child.parentKey = node.key;\n        }\n        childKeys.add(child.key);\n\n        if (last) {\n          last.nextKey = child.key;\n          child.prevKey = last.key;\n        } else {\n          child.prevKey = null;\n        }\n\n        visit(child);\n        last = child;\n      }\n\n      if (last) {\n        last.nextKey = null;\n      }\n\n      // Remove deleted nodes and their children from the key map\n      if (prevNode) {\n        for (let child of prevNode.childNodes) {\n          if (!childKeys.has(child.key)) {\n            remove(child);\n          }\n        }\n      }\n    };\n\n    let remove = (node: GridNode<T>) => {\n      this.keyMap.delete(node.key);\n      for (let child of node.childNodes) {\n        if (this.keyMap.get(child.key) === child) {\n          remove(child);\n        }\n      }\n    };\n\n    let last: GridNode<T> | null = null;\n    for (let [i, node] of opts.items.entries()) {\n      let rowNode: GridNode<T> = {\n        ...node,\n        level: node.level ?? 0,\n        key: node.key ?? 'row-' + i,\n        type: node.type ?? 'row',\n        value: node.value ?? null,\n        hasChildNodes: true,\n        childNodes: [...node.childNodes],\n        rendered: node.rendered,\n        textValue: node.textValue ?? '',\n        index: node.index ?? i\n      };\n\n      if (last) {\n        last.nextKey = rowNode.key;\n        rowNode.prevKey = last.key;\n      } else {\n        rowNode.prevKey = null;\n      }\n\n      this.rows.push(rowNode);\n      visit(rowNode);\n\n      last = rowNode;\n    }\n\n    if (last) {\n      last.nextKey = null;\n    }\n  }\n\n  *[Symbol.iterator](): IterableIterator<GridNode<T>> {\n    yield* [...this.rows];\n  }\n\n  get size(): number {\n    return [...this.rows].length;\n  }\n\n  getKeys(): IterableIterator<Key> {\n    return this.keyMap.keys();\n  }\n\n  getKeyBefore(key: Key): Key | null {\n    let node = this.keyMap.get(key);\n    return node ? node.prevKey ?? null : null;\n  }\n\n  getKeyAfter(key: Key): Key | null {\n    let node = this.keyMap.get(key);\n    return node ? node.nextKey ?? null : null;\n  }\n\n  getFirstKey(): Key | null {\n    return [...this.rows][0]?.key;\n  }\n\n  getLastKey(): Key | null {\n    let rows = [...this.rows];\n    return rows[rows.length - 1]?.key;\n  }\n\n  getItem(key: Key): GridNode<T> | null {\n    return this.keyMap.get(key) ?? null;\n  }\n\n  at(idx: number): GridNode<T> | null {\n    const keys = [...this.getKeys()];\n    return this.getItem(keys[idx]);\n  }\n\n  getChildren(key: Key): Iterable<GridNode<T>> {\n    let node = this.keyMap.get(key);\n    return node?.childNodes || [];\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}