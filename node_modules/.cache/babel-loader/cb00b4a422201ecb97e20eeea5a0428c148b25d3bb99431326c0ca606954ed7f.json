{"ast":null,"code":"import $3HATx$intlStringsmodulejs from \"./intlStrings.mjs\";\nimport { isSameDay as $3HATx$isSameDay, startOfMonth as $3HATx$startOfMonth, endOfMonth as $3HATx$endOfMonth } from \"@internationalized/date\";\nimport { useLocalizedStringFormatter as $3HATx$useLocalizedStringFormatter, useDateFormatter as $3HATx$useDateFormatter } from \"@react-aria/i18n\";\nimport { useMemo as $3HATx$useMemo } from \"react\";\nfunction $parcel$interopDefault(a) {\n  return a && a.__esModule ? a.default : a;\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nconst $a074e1e2d0f0a665$export$653eddfc964b0f8a = new WeakMap();\nfunction $a074e1e2d0f0a665$export$134cbb7fb09a9522(date) {\n  return (date === null || date === void 0 ? void 0 : date.calendar.identifier) === 'gregory' && date.era === 'BC' ? 'short' : undefined;\n}\nfunction $a074e1e2d0f0a665$export$b6df97c887c38e1a(state) {\n  let stringFormatter = (0, $3HATx$useLocalizedStringFormatter)((0, $parcel$interopDefault($3HATx$intlStringsmodulejs)), '@react-aria/calendar');\n  let start, end;\n  var _state_value;\n  if ('highlightedRange' in state) ({\n    start: start,\n    end: end\n  } = state.highlightedRange || {});else start = end = (_state_value = state.value) !== null && _state_value !== void 0 ? _state_value : undefined;\n  let dateFormatter = (0, $3HATx$useDateFormatter)({\n    weekday: 'long',\n    month: 'long',\n    year: 'numeric',\n    day: 'numeric',\n    era: $a074e1e2d0f0a665$export$134cbb7fb09a9522(start) || $a074e1e2d0f0a665$export$134cbb7fb09a9522(end),\n    timeZone: state.timeZone\n  });\n  let anchorDate = 'anchorDate' in state ? state.anchorDate : null;\n  return (0, $3HATx$useMemo)(() => {\n    // No message if currently selecting a range, or there is nothing highlighted.\n    if (!anchorDate && start && end) {\n      // Use a single date message if the start and end dates are the same day,\n      // otherwise include both dates.\n      if ((0, $3HATx$isSameDay)(start, end)) {\n        let date = dateFormatter.format(start.toDate(state.timeZone));\n        return stringFormatter.format('selectedDateDescription', {\n          date: date\n        });\n      } else {\n        let dateRange = $a074e1e2d0f0a665$var$formatRange(dateFormatter, stringFormatter, start, end, state.timeZone);\n        return stringFormatter.format('selectedRangeDescription', {\n          dateRange: dateRange\n        });\n      }\n    }\n    return '';\n  }, [start, end, anchorDate, state.timeZone, stringFormatter, dateFormatter]);\n}\nfunction $a074e1e2d0f0a665$export$31afe65d91ef6e8(startDate, endDate, timeZone, isAria) {\n  let stringFormatter = (0, $3HATx$useLocalizedStringFormatter)((0, $parcel$interopDefault($3HATx$intlStringsmodulejs)), '@react-aria/calendar');\n  let era = $a074e1e2d0f0a665$export$134cbb7fb09a9522(startDate) || $a074e1e2d0f0a665$export$134cbb7fb09a9522(endDate);\n  let monthFormatter = (0, $3HATx$useDateFormatter)({\n    month: 'long',\n    year: 'numeric',\n    era: era,\n    calendar: startDate.calendar.identifier,\n    timeZone: timeZone\n  });\n  let dateFormatter = (0, $3HATx$useDateFormatter)({\n    month: 'long',\n    year: 'numeric',\n    day: 'numeric',\n    era: era,\n    calendar: startDate.calendar.identifier,\n    timeZone: timeZone\n  });\n  return (0, $3HATx$useMemo)(() => {\n    // Special case for month granularity. Format as a single month if only a\n    // single month is visible, otherwise format as a range of months.\n    if ((0, $3HATx$isSameDay)(startDate, (0, $3HATx$startOfMonth)(startDate))) {\n      let startMonth = startDate;\n      let endMonth = endDate;\n      if (startDate.calendar.getFormattableMonth) startMonth = startDate.calendar.getFormattableMonth(startDate);\n      if (endDate.calendar.getFormattableMonth) endMonth = endDate.calendar.getFormattableMonth(endDate);\n      if ((0, $3HATx$isSameDay)(endDate, (0, $3HATx$endOfMonth)(startDate))) return monthFormatter.format(startMonth.toDate(timeZone));else if ((0, $3HATx$isSameDay)(endDate, (0, $3HATx$endOfMonth)(endDate))) return isAria ? $a074e1e2d0f0a665$var$formatRange(monthFormatter, stringFormatter, startMonth, endMonth, timeZone) : monthFormatter.formatRange(startMonth.toDate(timeZone), endMonth.toDate(timeZone));\n    }\n    return isAria ? $a074e1e2d0f0a665$var$formatRange(dateFormatter, stringFormatter, startDate, endDate, timeZone) : dateFormatter.formatRange(startDate.toDate(timeZone), endDate.toDate(timeZone));\n  }, [startDate, endDate, monthFormatter, dateFormatter, stringFormatter, timeZone, isAria]);\n}\nfunction $a074e1e2d0f0a665$var$formatRange(dateFormatter, stringFormatter, start, end, timeZone) {\n  let parts = dateFormatter.formatRangeToParts(start.toDate(timeZone), end.toDate(timeZone));\n  // Find the separator between the start and end date. This is determined\n  // by finding the last shared literal before the end range.\n  let separatorIndex = -1;\n  for (let i = 0; i < parts.length; i++) {\n    let part = parts[i];\n    if (part.source === 'shared' && part.type === 'literal') separatorIndex = i;else if (part.source === 'endRange') break;\n  }\n  // Now we can combine the parts into start and end strings.\n  let startValue = '';\n  let endValue = '';\n  for (let i = 0; i < parts.length; i++) {\n    if (i < separatorIndex) startValue += parts[i].value;else if (i > separatorIndex) endValue += parts[i].value;\n  }\n  return stringFormatter.format('dateRange', {\n    startDate: startValue,\n    endDate: endValue\n  });\n}\nexport { $a074e1e2d0f0a665$export$653eddfc964b0f8a as hookData, $a074e1e2d0f0a665$export$134cbb7fb09a9522 as getEraFormat, $a074e1e2d0f0a665$export$b6df97c887c38e1a as useSelectedDateDescription, $a074e1e2d0f0a665$export$31afe65d91ef6e8 as useVisibleRangeDescription };","map":{"version":3,"names":["$a074e1e2d0f0a665$export$653eddfc964b0f8a","WeakMap","$a074e1e2d0f0a665$export$134cbb7fb09a9522","date","calendar","identifier","era","undefined","$a074e1e2d0f0a665$export$b6df97c887c38e1a","state","stringFormatter","$3HATx$useLocalizedStringFormatter","$parcel$interopDefault","$3HATx$intlStringsmodulejs","start","end","_state_value","highlightedRange","value","dateFormatter","$3HATx$useDateFormatter","weekday","month","year","day","timeZone","anchorDate","$3HATx$useMemo","$3HATx$isSameDay","format","toDate","dateRange","$a074e1e2d0f0a665$var$formatRange","$a074e1e2d0f0a665$export$31afe65d91ef6e8","startDate","endDate","isAria","monthFormatter","$3HATx$startOfMonth","startMonth","endMonth","getFormattableMonth","$3HATx$endOfMonth","formatRange","parts","formatRangeToParts","separatorIndex","i","length","part","source","type","startValue","endValue"],"sources":["/Users/nathandarma/Documents/App Testing/Diptych/diptych/node_modules/@react-aria/calendar/dist/packages/@react-aria/calendar/src/utils.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {CalendarDate, DateFormatter, endOfMonth, isSameDay, startOfMonth} from '@internationalized/date';\nimport {CalendarState, RangeCalendarState} from '@react-stately/calendar';\n// @ts-ignore\nimport intlMessages from '../intl/*.json';\nimport type {LocalizedStringFormatter} from '@internationalized/string';\nimport {useDateFormatter, useLocalizedStringFormatter} from '@react-aria/i18n';\nimport {useMemo} from 'react';\n\ninterface HookData {\n  ariaLabel?: string,\n  ariaLabelledBy?: string,\n  errorMessageId: string,\n  selectedDateDescription: string\n}\n\nexport const hookData = new WeakMap<CalendarState | RangeCalendarState, HookData>();\n\nexport function getEraFormat(date: CalendarDate | undefined): 'short' | undefined {\n  return date?.calendar.identifier === 'gregory' && date.era === 'BC' ? 'short' : undefined;\n}\n\nexport function useSelectedDateDescription(state: CalendarState | RangeCalendarState): string {\n  let stringFormatter = useLocalizedStringFormatter(intlMessages, '@react-aria/calendar');\n\n  let start: CalendarDate | undefined, end: CalendarDate | undefined;\n  if ('highlightedRange' in state) {\n    ({start, end} = state.highlightedRange || {});\n  } else {\n    start = end = state.value ?? undefined;\n  }\n\n  let dateFormatter = useDateFormatter({\n    weekday: 'long',\n    month: 'long',\n    year: 'numeric',\n    day: 'numeric',\n    era: getEraFormat(start) || getEraFormat(end),\n    timeZone: state.timeZone\n  });\n\n  let anchorDate = 'anchorDate' in state ? state.anchorDate : null;\n  return useMemo(() => {\n    // No message if currently selecting a range, or there is nothing highlighted.\n    if (!anchorDate && start && end) {\n      // Use a single date message if the start and end dates are the same day,\n      // otherwise include both dates.\n      if (isSameDay(start, end)) {\n        let date = dateFormatter.format(start.toDate(state.timeZone));\n        return stringFormatter.format('selectedDateDescription', {date});\n      } else {\n        let dateRange = formatRange(dateFormatter, stringFormatter, start, end, state.timeZone);\n\n        return stringFormatter.format('selectedRangeDescription', {dateRange});\n      }\n    }\n    return '';\n  }, [start, end, anchorDate, state.timeZone, stringFormatter, dateFormatter]);\n}\n\nexport function useVisibleRangeDescription(startDate: CalendarDate, endDate: CalendarDate, timeZone: string, isAria: boolean): string {\n  let stringFormatter = useLocalizedStringFormatter(intlMessages, '@react-aria/calendar');\n  let era: any = getEraFormat(startDate) || getEraFormat(endDate);\n  let monthFormatter = useDateFormatter({\n    month: 'long',\n    year: 'numeric',\n    era,\n    calendar: startDate.calendar.identifier,\n    timeZone\n  });\n\n  let dateFormatter = useDateFormatter({\n    month: 'long',\n    year: 'numeric',\n    day: 'numeric',\n    era,\n    calendar: startDate.calendar.identifier,\n    timeZone\n  });\n\n  return useMemo(() => {\n    // Special case for month granularity. Format as a single month if only a\n    // single month is visible, otherwise format as a range of months.\n    if (isSameDay(startDate, startOfMonth(startDate))) {\n      let startMonth = startDate;\n      let endMonth = endDate;\n      if (startDate.calendar.getFormattableMonth) {\n        startMonth = startDate.calendar.getFormattableMonth(startDate);\n      }\n      if (endDate.calendar.getFormattableMonth) {\n        endMonth = endDate.calendar.getFormattableMonth(endDate);\n      }\n\n      if (isSameDay(endDate, endOfMonth(startDate))) {\n        return monthFormatter.format(startMonth.toDate(timeZone));\n      } else if (isSameDay(endDate, endOfMonth(endDate))) {\n        return isAria\n          ? formatRange(monthFormatter, stringFormatter, startMonth, endMonth, timeZone)\n          : monthFormatter.formatRange(startMonth.toDate(timeZone), endMonth.toDate(timeZone));\n      }\n    }\n\n    return isAria\n      ? formatRange(dateFormatter, stringFormatter, startDate, endDate, timeZone)\n      : dateFormatter.formatRange(startDate.toDate(timeZone), endDate.toDate(timeZone));\n  }, [startDate, endDate, monthFormatter, dateFormatter, stringFormatter, timeZone, isAria]);\n}\n\nfunction formatRange(dateFormatter: DateFormatter, stringFormatter: LocalizedStringFormatter, start: CalendarDate, end: CalendarDate, timeZone: string) {\n  let parts = dateFormatter.formatRangeToParts(start.toDate(timeZone), end.toDate(timeZone));\n\n  // Find the separator between the start and end date. This is determined\n  // by finding the last shared literal before the end range.\n  let separatorIndex = -1;\n  for (let i = 0; i < parts.length; i++) {\n    let part = parts[i];\n    if (part.source === 'shared' && part.type === 'literal') {\n      separatorIndex = i;\n    } else if (part.source === 'endRange') {\n      break;\n    }\n  }\n\n  // Now we can combine the parts into start and end strings.\n  let startValue = '';\n  let endValue = '';\n  for (let i = 0; i < parts.length; i++) {\n    if (i < separatorIndex) {\n      startValue += parts[i].value;\n    } else if (i > separatorIndex) {\n      endValue += parts[i].value;\n    }\n  }\n\n  return stringFormatter.format('dateRange', {startDate: startValue, endDate: endValue});\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}