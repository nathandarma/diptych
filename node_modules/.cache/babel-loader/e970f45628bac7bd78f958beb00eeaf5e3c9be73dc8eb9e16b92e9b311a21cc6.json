{"ast":null,"code":"import { useMemo as $cNx9A$useMemo, useCallback as $cNx9A$useCallback } from \"react\";\nimport { useSyncExternalStore as $cNx9A$useSyncExternalStore } from \"use-sync-external-store/shim/index.js\";\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nfunction $77b352cf12efcf73$export$c7b26b20d3ced9c5(props = {}) {\n  let {\n    maxVisibleToasts = 1,\n    wrapUpdate: wrapUpdate\n  } = props;\n  let queue = (0, $cNx9A$useMemo)(() => new $77b352cf12efcf73$export$f1f8569633bbbec4({\n    maxVisibleToasts: maxVisibleToasts,\n    wrapUpdate: wrapUpdate\n  }), [maxVisibleToasts, wrapUpdate]);\n  return $77b352cf12efcf73$export$84726ef35ca2129a(queue);\n}\nfunction $77b352cf12efcf73$export$84726ef35ca2129a(queue) {\n  let subscribe = (0, $cNx9A$useCallback)(fn => queue.subscribe(fn), [queue]);\n  let getSnapshot = (0, $cNx9A$useCallback)(() => queue.visibleToasts, [queue]);\n  let visibleToasts = (0, $cNx9A$useSyncExternalStore)(subscribe, getSnapshot, getSnapshot);\n  return {\n    visibleToasts: visibleToasts,\n    add: (content, options) => queue.add(content, options),\n    close: key => queue.close(key),\n    pauseAll: () => queue.pauseAll(),\n    resumeAll: () => queue.resumeAll()\n  };\n}\nclass $77b352cf12efcf73$export$f1f8569633bbbec4 {\n  runWithWrapUpdate(fn, action) {\n    if (this.wrapUpdate) this.wrapUpdate(fn, action);else fn();\n  }\n  /** Subscribes to updates to the visible toasts. */\n  subscribe(fn) {\n    this.subscriptions.add(fn);\n    return () => this.subscriptions.delete(fn);\n  }\n  /** Adds a new toast to the queue. */\n  add(content, options = {}) {\n    let toastKey = '_' + Math.random().toString(36).slice(2);\n    let toast = {\n      ...options,\n      content: content,\n      key: toastKey,\n      timer: options.timeout ? new $77b352cf12efcf73$var$Timer(() => this.close(toastKey), options.timeout) : undefined\n    };\n    this.queue.unshift(toast);\n    this.updateVisibleToasts('add');\n    return toastKey;\n  }\n  /**\n  * Closes a toast.\n  */\n  close(key) {\n    let index = this.queue.findIndex(t => t.key === key);\n    if (index >= 0) {\n      var _this_queue_index_onClose, _this_queue_index;\n      (_this_queue_index_onClose = (_this_queue_index = this.queue[index]).onClose) === null || _this_queue_index_onClose === void 0 ? void 0 : _this_queue_index_onClose.call(_this_queue_index);\n      this.queue.splice(index, 1);\n    }\n    this.updateVisibleToasts('remove');\n  }\n  updateVisibleToasts(action) {\n    this.visibleToasts = this.queue.slice(0, this.maxVisibleToasts);\n    this.runWithWrapUpdate(() => {\n      for (let fn of this.subscriptions) fn();\n    }, action);\n  }\n  /** Pauses the timers for all visible toasts. */\n  pauseAll() {\n    for (let toast of this.visibleToasts) if (toast.timer) toast.timer.pause();\n  }\n  /** Resumes the timers for all visible toasts. */\n  resumeAll() {\n    for (let toast of this.visibleToasts) if (toast.timer) toast.timer.resume();\n  }\n  clear() {\n    this.queue = [];\n    this.updateVisibleToasts('clear');\n  }\n  constructor(options) {\n    this.queue = [];\n    this.subscriptions = new Set();\n    /** The currently visible toasts. */\n    this.visibleToasts = [];\n    var _options_maxVisibleToasts;\n    this.maxVisibleToasts = (_options_maxVisibleToasts = options === null || options === void 0 ? void 0 : options.maxVisibleToasts) !== null && _options_maxVisibleToasts !== void 0 ? _options_maxVisibleToasts : Infinity;\n    this.wrapUpdate = options === null || options === void 0 ? void 0 : options.wrapUpdate;\n  }\n}\nclass $77b352cf12efcf73$var$Timer {\n  reset(delay) {\n    this.remaining = delay;\n    this.resume();\n  }\n  pause() {\n    if (this.timerId == null) return;\n    clearTimeout(this.timerId);\n    this.timerId = null;\n    this.remaining -= Date.now() - this.startTime;\n  }\n  resume() {\n    if (this.remaining <= 0) return;\n    this.startTime = Date.now();\n    this.timerId = setTimeout(() => {\n      this.timerId = null;\n      this.remaining = 0;\n      this.callback();\n    }, this.remaining);\n  }\n  constructor(callback, delay) {\n    this.startTime = null;\n    this.remaining = delay;\n    this.callback = callback;\n  }\n}\nexport { $77b352cf12efcf73$export$c7b26b20d3ced9c5 as useToastState, $77b352cf12efcf73$export$f1f8569633bbbec4 as ToastQueue, $77b352cf12efcf73$export$84726ef35ca2129a as useToastQueue };","map":{"version":3,"names":["$77b352cf12efcf73$export$c7b26b20d3ced9c5","props","maxVisibleToasts","wrapUpdate","queue","$cNx9A$useMemo","$77b352cf12efcf73$export$f1f8569633bbbec4","$77b352cf12efcf73$export$84726ef35ca2129a","subscribe","$cNx9A$useCallback","fn","getSnapshot","visibleToasts","$cNx9A$useSyncExternalStore","add","content","options","close","key","pauseAll","resumeAll","runWithWrapUpdate","action","subscriptions","delete","toastKey","Math","random","toString","slice","toast","timer","timeout","$77b352cf12efcf73$var$Timer","undefined","unshift","updateVisibleToasts","index","findIndex","t","_this_queue_index_onClose","_this_queue_index","onClose","call","splice","pause","resume","clear","constructor","Set","_options_maxVisibleToasts","Infinity","reset","delay","remaining","timerId","clearTimeout","Date","now","startTime","setTimeout","callback"],"sources":["/Users/nathandarma/Documents/App Testing/Diptych/diptych/node_modules/@react-stately/toast/dist/packages/@react-stately/toast/src/useToastState.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {useCallback, useMemo} from 'react';\n// Shim to support React 17 and below.\nimport {useSyncExternalStore} from 'use-sync-external-store/shim/index.js';\n\ntype ToastAction = 'add' | 'remove' | 'clear';\nexport interface ToastStateProps {\n  /** The maximum number of toasts to display at a time. */\n  maxVisibleToasts?: number,\n  /** Function to wrap updates in (i.e. document.startViewTransition()). */\n  wrapUpdate?: (fn: () => void, action: ToastAction) => void\n}\n\nexport interface ToastOptions {\n  /** Handler that is called when the toast is closed, either by the user or after a timeout. */\n  onClose?: () => void,\n  /** A timeout to automatically close the toast after, in milliseconds. */\n  timeout?: number\n}\n\nexport interface QueuedToast<T> extends ToastOptions {\n  /** The content of the toast. */\n  content: T,\n  /** A unique key for the toast. */\n  key: string,\n  /** A timer for the toast, if a timeout was set. */\n  timer?: Timer\n}\n\nexport interface ToastState<T> {\n  /** Adds a new toast to the queue. */\n  add(content: T, options?: ToastOptions): string,\n  /**\n   * Closes a toast.\n   */\n  close(key: string): void,\n  /** Pauses the timers for all visible toasts. */\n  pauseAll(): void,\n  /** Resumes the timers for all visible toasts. */\n  resumeAll(): void,\n  /** The visible toasts. */\n  visibleToasts: QueuedToast<T>[]\n}\n\n/**\n * Provides state management for a toast queue. Toasts display brief, temporary notifications\n * of actions, errors, or other events in an application.\n */\nexport function useToastState<T>(props: ToastStateProps = {}): ToastState<T> {\n  let {maxVisibleToasts = 1, wrapUpdate} = props;\n  let queue = useMemo(() => new ToastQueue<T>({maxVisibleToasts, wrapUpdate}), [maxVisibleToasts, wrapUpdate]);\n  return useToastQueue(queue);\n}\n\n/**\n * Subscribes to a provided toast queue and provides methods to update it.\n */\nexport function useToastQueue<T>(queue: ToastQueue<T>): ToastState<T> {\n  let subscribe = useCallback(fn => queue.subscribe(fn), [queue]);\n  let getSnapshot = useCallback(() => queue.visibleToasts, [queue]);\n  let visibleToasts = useSyncExternalStore(subscribe, getSnapshot, getSnapshot);\n\n  return {\n    visibleToasts,\n    add: (content, options) => queue.add(content, options),\n    close: key => queue.close(key),\n    pauseAll: () => queue.pauseAll(),\n    resumeAll: () => queue.resumeAll()\n  };\n}\n\n/**\n * A ToastQueue manages the order of toasts.\n */\nexport class ToastQueue<T> {\n  private queue: QueuedToast<T>[] = [];\n  private subscriptions: Set<() => void> = new Set();\n  private maxVisibleToasts: number;\n  private wrapUpdate?: (fn: () => void, action: ToastAction) => void;\n  /** The currently visible toasts. */\n  visibleToasts: QueuedToast<T>[] = [];\n\n  constructor(options?: ToastStateProps) {\n    this.maxVisibleToasts = options?.maxVisibleToasts ?? Infinity;\n    this.wrapUpdate = options?.wrapUpdate;\n  }\n\n  private runWithWrapUpdate(fn: () => void, action: ToastAction): void {\n    if (this.wrapUpdate) {\n      this.wrapUpdate(fn, action);\n    } else {\n      fn();\n    }\n  }\n\n  /** Subscribes to updates to the visible toasts. */\n  subscribe(fn: () => void): () => void {\n    this.subscriptions.add(fn);\n    return () => this.subscriptions.delete(fn);\n  }\n\n  /** Adds a new toast to the queue. */\n  add(content: T, options: ToastOptions = {}): string {\n    let toastKey = '_' + Math.random().toString(36).slice(2);\n    let toast: QueuedToast<T> = {\n      ...options,\n      content,\n      key: toastKey,\n      timer: options.timeout ? new Timer(() => this.close(toastKey), options.timeout) : undefined\n    };\n\n    this.queue.unshift(toast);\n\n    this.updateVisibleToasts('add');\n    return toastKey;\n  }\n\n  /**\n   * Closes a toast.\n   */\n  close(key: string): void {\n    let index = this.queue.findIndex(t => t.key === key);\n    if (index >= 0) {\n      this.queue[index].onClose?.();\n      this.queue.splice(index, 1);\n    }\n\n    this.updateVisibleToasts('remove');\n  }\n\n  private updateVisibleToasts(action: ToastAction) {\n    this.visibleToasts = this.queue.slice(0, this.maxVisibleToasts);\n\n    this.runWithWrapUpdate(() => {\n      for (let fn of this.subscriptions) {\n        fn();\n      }\n    }, action);\n  }\n\n  /** Pauses the timers for all visible toasts. */\n  pauseAll(): void {\n    for (let toast of this.visibleToasts) {\n      if (toast.timer) {\n        toast.timer.pause();\n      }\n    }\n  }\n\n  /** Resumes the timers for all visible toasts. */\n  resumeAll(): void {\n    for (let toast of this.visibleToasts) {\n      if (toast.timer) {\n        toast.timer.resume();\n      }\n    }\n  }\n\n  clear(): void {\n    this.queue = [];\n    this.updateVisibleToasts('clear');\n  }\n}\n\nclass Timer {\n  private timerId;\n  private startTime: number | null = null;\n  private remaining: number;\n  private callback: () => void;\n\n  constructor(callback: () => void, delay: number) {\n    this.remaining = delay;\n    this.callback = callback;\n  }\n\n  reset(delay: number) {\n    this.remaining = delay;\n    this.resume();\n  }\n\n  pause() {\n    if (this.timerId == null) {\n      return;\n    }\n\n    clearTimeout(this.timerId);\n    this.timerId = null;\n    this.remaining -= Date.now() - this.startTime!;\n  }\n\n  resume() {\n    if (this.remaining <= 0) {\n      return;\n    }\n\n    this.startTime = Date.now();\n    this.timerId = setTimeout(() => {\n      this.timerId = null;\n      this.remaining = 0;\n      this.callback();\n    }, this.remaining);\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}