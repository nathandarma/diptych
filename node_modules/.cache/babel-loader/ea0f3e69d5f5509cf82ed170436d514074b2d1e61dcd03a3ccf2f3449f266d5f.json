{"ast":null,"code":"import { hookData as $16f0b7bb276bc17e$export$653eddfc964b0f8a } from \"./useDateField.mjs\";\nimport { useDisplayNames as $3aeceb3a64eb8358$export$d42c60378c8168f8 } from \"./useDisplayNames.mjs\";\nimport { toCalendar as $4d1jn$toCalendar, CalendarDate as $4d1jn$CalendarDate } from \"@internationalized/date\";\nimport { isMac as $4d1jn$isMac, scrollIntoViewport as $4d1jn$scrollIntoViewport, getScrollParent as $4d1jn$getScrollParent, useEvent as $4d1jn$useEvent, useLayoutEffect as $4d1jn$useLayoutEffect, isIOS as $4d1jn$isIOS, useId as $4d1jn$useId, useLabels as $4d1jn$useLabels, mergeProps as $4d1jn$mergeProps } from \"@react-aria/utils\";\nimport { NumberParser as $4d1jn$NumberParser } from \"@internationalized/number\";\nimport $4d1jn$react, { useRef as $4d1jn$useRef, useMemo as $4d1jn$useMemo } from \"react\";\nimport { useLocale as $4d1jn$useLocale, useDateFormatter as $4d1jn$useDateFormatter, useFilter as $4d1jn$useFilter } from \"@react-aria/i18n\";\nimport { useSpinButton as $4d1jn$useSpinButton } from \"@react-aria/spinbutton\";\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nfunction $32489daedd52963e$export$1315d136e6f7581(segment, state, ref) {\n  let enteredKeys = (0, $4d1jn$useRef)('');\n  let {\n    locale: locale,\n    direction: direction\n  } = (0, $4d1jn$useLocale)();\n  let displayNames = (0, $3aeceb3a64eb8358$export$d42c60378c8168f8)();\n  let {\n    ariaLabel: ariaLabel,\n    ariaLabelledBy: ariaLabelledBy,\n    ariaDescribedBy: ariaDescribedBy,\n    focusManager: focusManager\n  } = (0, $16f0b7bb276bc17e$export$653eddfc964b0f8a).get(state);\n  let textValue = segment.isPlaceholder ? '' : segment.text;\n  let options = (0, $4d1jn$useMemo)(() => state.dateFormatter.resolvedOptions(), [state.dateFormatter]);\n  let monthDateFormatter = (0, $4d1jn$useDateFormatter)({\n    month: 'long',\n    timeZone: options.timeZone\n  });\n  let hourDateFormatter = (0, $4d1jn$useDateFormatter)({\n    hour: 'numeric',\n    hour12: options.hour12,\n    timeZone: options.timeZone\n  });\n  if (segment.type === 'month' && !segment.isPlaceholder) {\n    let monthTextValue = monthDateFormatter.format(state.dateValue);\n    textValue = monthTextValue !== textValue ? `${textValue} \\u{2013} ${monthTextValue}` : monthTextValue;\n  } else if (segment.type === 'hour' && !segment.isPlaceholder) textValue = hourDateFormatter.format(state.dateValue);\n  let {\n    spinButtonProps: spinButtonProps\n  } = (0, $4d1jn$useSpinButton)({\n    // The ARIA spec says aria-valuenow is optional if there's no value, but aXe seems to require it.\n    // This doesn't seem to have any negative effects with real AT since we also use aria-valuetext.\n    // https://github.com/dequelabs/axe-core/issues/3505\n    value: segment.value,\n    textValue: textValue,\n    minValue: segment.minValue,\n    maxValue: segment.maxValue,\n    isDisabled: state.isDisabled,\n    isReadOnly: state.isReadOnly || !segment.isEditable,\n    isRequired: state.isRequired,\n    onIncrement: () => {\n      enteredKeys.current = '';\n      state.increment(segment.type);\n    },\n    onDecrement: () => {\n      enteredKeys.current = '';\n      state.decrement(segment.type);\n    },\n    onIncrementPage: () => {\n      enteredKeys.current = '';\n      state.incrementPage(segment.type);\n    },\n    onDecrementPage: () => {\n      enteredKeys.current = '';\n      state.decrementPage(segment.type);\n    },\n    onIncrementToMax: () => {\n      enteredKeys.current = '';\n      if (segment.maxValue !== undefined) state.setSegment(segment.type, segment.maxValue);\n    },\n    onDecrementToMin: () => {\n      enteredKeys.current = '';\n      if (segment.minValue !== undefined) state.setSegment(segment.type, segment.minValue);\n    }\n  });\n  let parser = (0, $4d1jn$useMemo)(() => new (0, $4d1jn$NumberParser)(locale, {\n    maximumFractionDigits: 0\n  }), [locale]);\n  let backspace = () => {\n    if (segment.text === segment.placeholder) focusManager.focusPrevious();\n    if (parser.isValidPartialNumber(segment.text) && !state.isReadOnly && !segment.isPlaceholder) {\n      let newValue = segment.text.slice(0, -1);\n      let parsed = parser.parse(newValue);\n      newValue = parsed === 0 ? '' : newValue;\n      if (newValue.length === 0 || parsed === 0) state.clearSegment(segment.type);else state.setSegment(segment.type, parsed);\n      enteredKeys.current = newValue;\n    } else if (segment.type === 'dayPeriod') state.clearSegment(segment.type);\n  };\n  let onKeyDown = e => {\n    // Firefox does not fire selectstart for Ctrl/Cmd + A\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=1742153\n    if (e.key === 'a' && ((0, $4d1jn$isMac)() ? e.metaKey : e.ctrlKey)) e.preventDefault();\n    if (e.ctrlKey || e.metaKey || e.shiftKey || e.altKey) return;\n    switch (e.key) {\n      case 'Backspace':\n      case 'Delete':\n        // Safari on iOS does not fire beforeinput for the backspace key because the cursor is at the start.\n        e.preventDefault();\n        e.stopPropagation();\n        backspace();\n        break;\n    }\n  };\n  // Safari dayPeriod option doesn't work...\n  let {\n    startsWith: startsWith\n  } = (0, $4d1jn$useFilter)({\n    sensitivity: 'base'\n  });\n  let amPmFormatter = (0, $4d1jn$useDateFormatter)({\n    hour: 'numeric',\n    hour12: true\n  });\n  let am = (0, $4d1jn$useMemo)(() => {\n    let date = new Date();\n    date.setHours(0);\n    return amPmFormatter.formatToParts(date).find(part => part.type === 'dayPeriod').value;\n  }, [amPmFormatter]);\n  let pm = (0, $4d1jn$useMemo)(() => {\n    let date = new Date();\n    date.setHours(12);\n    return amPmFormatter.formatToParts(date).find(part => part.type === 'dayPeriod').value;\n  }, [amPmFormatter]);\n  // Get a list of formatted era names so users can type the first character to choose one.\n  let eraFormatter = (0, $4d1jn$useDateFormatter)({\n    year: 'numeric',\n    era: 'narrow',\n    timeZone: 'UTC'\n  });\n  let eras = (0, $4d1jn$useMemo)(() => {\n    if (segment.type !== 'era') return [];\n    let date = (0, $4d1jn$toCalendar)(new (0, $4d1jn$CalendarDate)(1, 1, 1), state.calendar);\n    let eras = state.calendar.getEras().map(era => {\n      let eraDate = date.set({\n        year: 1,\n        month: 1,\n        day: 1,\n        era: era\n      }).toDate('UTC');\n      let parts = eraFormatter.formatToParts(eraDate);\n      let formatted = parts.find(p => p.type === 'era').value;\n      return {\n        era: era,\n        formatted: formatted\n      };\n    });\n    // Remove the common prefix from formatted values. This is so that in calendars with eras like\n    // ERA0 and ERA1 (e.g. Ethiopic), users can press \"0\" and \"1\" to select an era. In other cases,\n    // the first letter is used.\n    let prefixLength = $32489daedd52963e$var$commonPrefixLength(eras.map(era => era.formatted));\n    if (prefixLength) for (let era of eras) era.formatted = era.formatted.slice(prefixLength);\n    return eras;\n  }, [eraFormatter, state.calendar, segment.type]);\n  let onInput = key => {\n    if (state.isDisabled || state.isReadOnly) return;\n    let newValue = enteredKeys.current + key;\n    switch (segment.type) {\n      case 'dayPeriod':\n        if (startsWith(am, key)) state.setSegment('dayPeriod', 0);else if (startsWith(pm, key)) state.setSegment('dayPeriod', 12);else break;\n        focusManager.focusNext();\n        break;\n      case 'era':\n        {\n          let matched = eras.find(e => startsWith(e.formatted, key));\n          if (matched) {\n            state.setSegment('era', matched.era);\n            focusManager.focusNext();\n          }\n          break;\n        }\n      case 'day':\n      case 'hour':\n      case 'minute':\n      case 'second':\n      case 'month':\n      case 'year':\n        {\n          if (!parser.isValidPartialNumber(newValue)) return;\n          let numberValue = parser.parse(newValue);\n          let segmentValue = numberValue;\n          let allowsZero = segment.minValue === 0;\n          if (segment.type === 'hour' && state.dateFormatter.resolvedOptions().hour12) {\n            switch (state.dateFormatter.resolvedOptions().hourCycle) {\n              case 'h11':\n                if (numberValue > 11) segmentValue = parser.parse(key);\n                break;\n              case 'h12':\n                allowsZero = false;\n                if (numberValue > 12) segmentValue = parser.parse(key);\n                break;\n            }\n            if (segment.value !== undefined && segment.value >= 12 && numberValue > 1) numberValue += 12;\n          } else if (segment.maxValue !== undefined && numberValue > segment.maxValue) segmentValue = parser.parse(key);\n          if (isNaN(numberValue)) return;\n          let shouldSetValue = segmentValue !== 0 || allowsZero;\n          if (shouldSetValue) state.setSegment(segment.type, segmentValue);\n          if (segment.maxValue !== undefined && (Number(numberValue + '0') > segment.maxValue || newValue.length >= String(segment.maxValue).length)) {\n            enteredKeys.current = '';\n            if (shouldSetValue) focusManager.focusNext();\n          } else enteredKeys.current = newValue;\n          break;\n        }\n    }\n  };\n  let onFocus = () => {\n    enteredKeys.current = '';\n    if (ref.current) (0, $4d1jn$scrollIntoViewport)(ref.current, {\n      containingElement: (0, $4d1jn$getScrollParent)(ref.current)\n    });\n    // Collapse selection to start or Chrome won't fire input events.\n    let selection = window.getSelection();\n    selection === null || selection === void 0 ? void 0 : selection.collapse(ref.current);\n  };\n  let documentRef = (0, $4d1jn$useRef)(typeof document !== 'undefined' ? document : null);\n  (0, $4d1jn$useEvent)(documentRef, 'selectionchange', () => {\n    var _ref_current;\n    // Enforce that the selection is collapsed when inside a date segment.\n    // Otherwise, when tapping on a segment in Android Chrome and then entering text,\n    // composition events will be fired that break the DOM structure and crash the page.\n    let selection = window.getSelection();\n    if ((selection === null || selection === void 0 ? void 0 : selection.anchorNode) && ((_ref_current = ref.current) === null || _ref_current === void 0 ? void 0 : _ref_current.contains(selection === null || selection === void 0 ? void 0 : selection.anchorNode))) selection.collapse(ref.current);\n  });\n  let compositionRef = (0, $4d1jn$useRef)('');\n  (0, $4d1jn$useEvent)(ref, 'beforeinput', e => {\n    if (!ref.current) return;\n    e.preventDefault();\n    switch (e.inputType) {\n      case 'deleteContentBackward':\n      case 'deleteContentForward':\n        if (parser.isValidPartialNumber(segment.text) && !state.isReadOnly) backspace();\n        break;\n      case 'insertCompositionText':\n        // insertCompositionText cannot be canceled.\n        // Record the current state of the element so we can restore it in the `input` event below.\n        compositionRef.current = ref.current.textContent;\n        // Safari gets stuck in a composition state unless we also assign to the value here.\n        // eslint-disable-next-line no-self-assign\n        ref.current.textContent = ref.current.textContent;\n        break;\n      default:\n        if (e.data != null) onInput(e.data);\n        break;\n    }\n  });\n  (0, $4d1jn$useEvent)(ref, 'input', e => {\n    let {\n      inputType: inputType,\n      data: data\n    } = e;\n    switch (inputType) {\n      case 'insertCompositionText':\n        // Reset the DOM to how it was in the beforeinput event.\n        if (ref.current) ref.current.textContent = compositionRef.current;\n        // Android sometimes fires key presses of letters as composition events. Need to handle am/pm keys here too.\n        // Can also happen e.g. with Pinyin keyboard on iOS.\n        if (data != null && (startsWith(am, data) || startsWith(pm, data))) onInput(data);\n        break;\n    }\n  });\n  (0, $4d1jn$useLayoutEffect)(() => {\n    let element = ref.current;\n    return () => {\n      // If the focused segment is removed, focus the previous one, or the next one if there was no previous one.\n      if (document.activeElement === element) {\n        let prev = focusManager.focusPrevious();\n        if (!prev) focusManager.focusNext();\n      }\n    };\n  }, [ref, focusManager]);\n  // spinbuttons cannot be focused with VoiceOver on iOS.\n  let touchPropOverrides = (0, $4d1jn$isIOS)() || segment.type === 'timeZoneName' ? {\n    role: 'textbox',\n    'aria-valuemax': null,\n    'aria-valuemin': null,\n    'aria-valuetext': null,\n    'aria-valuenow': null\n  } : {};\n  // Only apply aria-describedby to the first segment, unless the field is invalid. This avoids it being\n  // read every time the user navigates to a new segment.\n  let firstSegment = (0, $4d1jn$useMemo)(() => state.segments.find(s => s.isEditable), [state.segments]);\n  if (segment !== firstSegment && !state.isInvalid) ariaDescribedBy = undefined;\n  let id = (0, $4d1jn$useId)();\n  let isEditable = !state.isDisabled && !state.isReadOnly && segment.isEditable;\n  // Prepend the label passed from the field to each segment name.\n  // This is needed because VoiceOver on iOS does not announce groups.\n  let name = segment.type === 'literal' ? '' : displayNames.of(segment.type);\n  let labelProps = (0, $4d1jn$useLabels)({\n    'aria-label': `${name}${ariaLabel ? `, ${ariaLabel}` : ''}${ariaLabelledBy ? ', ' : ''}`,\n    'aria-labelledby': ariaLabelledBy\n  });\n  // Literal segments should not be visible to screen readers. We don't really need any of the above,\n  // but the rules of hooks mean hooks cannot be conditional so we have to put this condition here.\n  if (segment.type === 'literal') return {\n    segmentProps: {\n      'aria-hidden': true\n    }\n  };\n  let segmentStyle = {\n    caretColor: 'transparent'\n  };\n  if (direction === 'rtl') {\n    // While the bidirectional algorithm seems to work properly on inline elements with actual values, it returns different results for placeholder strings. \n    // To ensure placeholder render in correct format, we apply the CSS equivalent of LRE (left-to-right embedding). See https://www.unicode.org/reports/tr9/#Explicit_Directional_Embeddings.\n    // However, we apply this to both placeholders and date segments with an actual value because the date segments will shift around when deleting otherwise. \n    segmentStyle.unicodeBidi = 'embed';\n    let format = options[segment.type];\n    if (format === 'numeric' || format === '2-digit') segmentStyle.direction = 'ltr';\n  }\n  return {\n    segmentProps: (0, $4d1jn$mergeProps)(spinButtonProps, labelProps, {\n      id: id,\n      ...touchPropOverrides,\n      'aria-invalid': state.isInvalid ? 'true' : undefined,\n      'aria-describedby': ariaDescribedBy,\n      'aria-readonly': state.isReadOnly || !segment.isEditable ? 'true' : undefined,\n      'data-placeholder': segment.isPlaceholder || undefined,\n      contentEditable: isEditable,\n      suppressContentEditableWarning: isEditable,\n      spellCheck: isEditable ? 'false' : undefined,\n      autoCorrect: isEditable ? 'off' : undefined,\n      // Capitalization was changed in React 17...\n      [parseInt((0, $4d1jn$react).version, 10) >= 17 ? 'enterKeyHint' : 'enterkeyhint']: isEditable ? 'next' : undefined,\n      inputMode: state.isDisabled || segment.type === 'dayPeriod' || segment.type === 'era' || !isEditable ? undefined : 'numeric',\n      tabIndex: state.isDisabled ? undefined : 0,\n      onKeyDown: onKeyDown,\n      onFocus: onFocus,\n      style: segmentStyle,\n      // Prevent pointer events from reaching useDatePickerGroup, and allow native browser behavior to focus the segment.\n      onPointerDown(e) {\n        e.stopPropagation();\n      },\n      onMouseDown(e) {\n        e.stopPropagation();\n      }\n    })\n  };\n}\nfunction $32489daedd52963e$var$commonPrefixLength(strings) {\n  // Sort the strings, and compare the characters in the first and last to find the common prefix.\n  strings.sort();\n  let first = strings[0];\n  let last = strings[strings.length - 1];\n  for (let i = 0; i < first.length; i++) {\n    if (first[i] !== last[i]) return i;\n  }\n  return 0;\n}\nexport { $32489daedd52963e$export$1315d136e6f7581 as useDateSegment };","map":{"version":3,"names":["$32489daedd52963e$export$1315d136e6f7581","segment","state","ref","enteredKeys","$4d1jn$useRef","locale","direction","$4d1jn$useLocale","displayNames","$3aeceb3a64eb8358$export$d42c60378c8168f8","ariaLabel","ariaLabelledBy","ariaDescribedBy","focusManager","$16f0b7bb276bc17e$export$653eddfc964b0f8a","get","textValue","isPlaceholder","text","options","$4d1jn$useMemo","dateFormatter","resolvedOptions","monthDateFormatter","$4d1jn$useDateFormatter","month","timeZone","hourDateFormatter","hour","hour12","type","monthTextValue","format","dateValue","spinButtonProps","$4d1jn$useSpinButton","value","minValue","maxValue","isDisabled","isReadOnly","isEditable","isRequired","onIncrement","current","increment","onDecrement","decrement","onIncrementPage","incrementPage","onDecrementPage","decrementPage","onIncrementToMax","undefined","setSegment","onDecrementToMin","parser","$4d1jn$NumberParser","maximumFractionDigits","backspace","placeholder","focusPrevious","isValidPartialNumber","newValue","slice","parsed","parse","length","clearSegment","onKeyDown","e","key","$4d1jn$isMac","metaKey","ctrlKey","preventDefault","shiftKey","altKey","stopPropagation","startsWith","$4d1jn$useFilter","sensitivity","amPmFormatter","am","date","Date","setHours","formatToParts","find","part","pm","eraFormatter","year","era","eras","$4d1jn$toCalendar","$4d1jn$CalendarDate","calendar","getEras","map","eraDate","set","day","toDate","parts","formatted","p","prefixLength","$32489daedd52963e$var$commonPrefixLength","onInput","focusNext","matched","numberValue","segmentValue","allowsZero","hourCycle","isNaN","shouldSetValue","Number","String","onFocus","$4d1jn$scrollIntoViewport","containingElement","$4d1jn$getScrollParent","selection","window","getSelection","collapse","documentRef","document","$4d1jn$useEvent","_ref_current","anchorNode","contains","compositionRef","inputType","textContent","data","$4d1jn$useLayoutEffect","element","activeElement","prev","touchPropOverrides","$4d1jn$isIOS","role","firstSegment","segments","s","isInvalid","id","$4d1jn$useId","name","of","labelProps","$4d1jn$useLabels","segmentProps","segmentStyle","caretColor","unicodeBidi","$4d1jn$mergeProps","contentEditable","suppressContentEditableWarning","spellCheck","autoCorrect","parseInt","$4d1jn$react","version","inputMode","tabIndex","style","onPointerDown","onMouseDown","strings","sort","first","last","i"],"sources":["/Users/nathandarma/Documents/App Testing/Diptych/diptych/node_modules/@react-aria/datepicker/dist/packages/@react-aria/datepicker/src/useDateSegment.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {CalendarDate, toCalendar} from '@internationalized/date';\nimport {DateFieldState, DateSegment} from '@react-stately/datepicker';\nimport {getScrollParent, isIOS, isMac, mergeProps, scrollIntoViewport, useEvent, useId, useLabels, useLayoutEffect} from '@react-aria/utils';\nimport {hookData} from './useDateField';\nimport {NumberParser} from '@internationalized/number';\nimport React, {CSSProperties, useMemo, useRef} from 'react';\nimport {RefObject} from '@react-types/shared';\nimport {useDateFormatter, useFilter, useLocale} from '@react-aria/i18n';\nimport {useDisplayNames} from './useDisplayNames';\nimport {useSpinButton} from '@react-aria/spinbutton';\n\nexport interface DateSegmentAria {\n  /** Props for the segment element. */\n  segmentProps: React.HTMLAttributes<HTMLDivElement>\n}\n\n/**\n * Provides the behavior and accessibility implementation for a segment in a date field.\n * A date segment displays an individual unit of a date and time, and allows users to edit\n * the value by typing or using the arrow keys to increment and decrement.\n */\nexport function useDateSegment(segment: DateSegment, state: DateFieldState, ref: RefObject<HTMLElement | null>): DateSegmentAria {\n  let enteredKeys = useRef('');\n  let {locale, direction} = useLocale();\n  let displayNames = useDisplayNames();\n  let {ariaLabel, ariaLabelledBy, ariaDescribedBy, focusManager} = hookData.get(state)!;\n\n  let textValue = segment.isPlaceholder ? '' : segment.text;\n  let options = useMemo(() => state.dateFormatter.resolvedOptions(), [state.dateFormatter]);\n  let monthDateFormatter = useDateFormatter({month: 'long', timeZone: options.timeZone});\n  let hourDateFormatter = useDateFormatter({\n    hour: 'numeric',\n    hour12: options.hour12,\n    timeZone: options.timeZone\n  });\n\n  if (segment.type === 'month' && !segment.isPlaceholder) {\n    let monthTextValue = monthDateFormatter.format(state.dateValue);\n    textValue = monthTextValue !== textValue ? `${textValue} – ${monthTextValue}` : monthTextValue;\n  } else if (segment.type === 'hour' && !segment.isPlaceholder) {\n    textValue = hourDateFormatter.format(state.dateValue);\n  }\n\n  let {spinButtonProps} = useSpinButton({\n    // The ARIA spec says aria-valuenow is optional if there's no value, but aXe seems to require it.\n    // This doesn't seem to have any negative effects with real AT since we also use aria-valuetext.\n    // https://github.com/dequelabs/axe-core/issues/3505\n    value: segment.value,\n    textValue,\n    minValue: segment.minValue,\n    maxValue: segment.maxValue,\n    isDisabled: state.isDisabled,\n    isReadOnly: state.isReadOnly || !segment.isEditable,\n    isRequired: state.isRequired,\n    onIncrement: () => {\n      enteredKeys.current = '';\n      state.increment(segment.type);\n    },\n    onDecrement: () => {\n      enteredKeys.current = '';\n      state.decrement(segment.type);\n    },\n    onIncrementPage: () => {\n      enteredKeys.current = '';\n      state.incrementPage(segment.type);\n    },\n    onDecrementPage: () => {\n      enteredKeys.current = '';\n      state.decrementPage(segment.type);\n    },\n    onIncrementToMax: () => {\n      enteredKeys.current = '';\n      if (segment.maxValue !== undefined) {\n        state.setSegment(segment.type, segment.maxValue);\n      }\n    },\n    onDecrementToMin: () => {\n      enteredKeys.current = '';\n      if (segment.minValue !== undefined) {\n        state.setSegment(segment.type, segment.minValue);\n      }\n    }\n  });\n\n  let parser = useMemo(() => new NumberParser(locale, {maximumFractionDigits: 0}), [locale]);\n\n  let backspace = () => {\n    if (segment.text === segment.placeholder) {\n      focusManager.focusPrevious();\n    }\n    if (parser.isValidPartialNumber(segment.text) && !state.isReadOnly && !segment.isPlaceholder) {\n      let newValue = segment.text.slice(0, -1);\n      let parsed = parser.parse(newValue);\n      newValue = parsed === 0 ? '' : newValue;\n      if (newValue.length === 0 || parsed === 0) {\n        state.clearSegment(segment.type);\n      } else {\n        state.setSegment(segment.type, parsed);\n      }\n      enteredKeys.current = newValue;\n    } else if (segment.type === 'dayPeriod') {\n      state.clearSegment(segment.type);\n    }\n  };\n\n  let onKeyDown = (e) => {\n    // Firefox does not fire selectstart for Ctrl/Cmd + A\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=1742153\n    if (e.key === 'a' && (isMac() ? e.metaKey : e.ctrlKey)) {\n      e.preventDefault();\n    }\n\n    if (e.ctrlKey || e.metaKey || e.shiftKey || e.altKey) {\n      return;\n    }\n\n    switch (e.key) {\n      case 'Backspace':\n      case 'Delete': {\n        // Safari on iOS does not fire beforeinput for the backspace key because the cursor is at the start.\n        e.preventDefault();\n        e.stopPropagation();\n        backspace();\n        break;\n      }\n    }\n  };\n\n  // Safari dayPeriod option doesn't work...\n  let {startsWith} = useFilter({sensitivity: 'base'});\n  let amPmFormatter = useDateFormatter({hour: 'numeric', hour12: true});\n  let am = useMemo(() => {\n    let date = new Date();\n    date.setHours(0);\n    return amPmFormatter.formatToParts(date).find(part => part.type === 'dayPeriod')!.value;\n  }, [amPmFormatter]);\n\n  let pm = useMemo(() => {\n    let date = new Date();\n    date.setHours(12);\n    return amPmFormatter.formatToParts(date).find(part => part.type === 'dayPeriod')!.value;\n  }, [amPmFormatter]);\n\n  // Get a list of formatted era names so users can type the first character to choose one.\n  let eraFormatter = useDateFormatter({year: 'numeric', era: 'narrow', timeZone: 'UTC'});\n  let eras = useMemo(() => {\n    if (segment.type !== 'era') {\n      return [];\n    }\n\n    let date = toCalendar(new CalendarDate(1, 1, 1), state.calendar);\n    let eras = state.calendar.getEras().map(era => {\n      let eraDate = date.set({year: 1, month: 1, day: 1, era}).toDate('UTC');\n      let parts = eraFormatter.formatToParts(eraDate);\n      let formatted = parts.find(p => p.type === 'era')!.value;\n      return {era, formatted};\n    });\n\n    // Remove the common prefix from formatted values. This is so that in calendars with eras like\n    // ERA0 and ERA1 (e.g. Ethiopic), users can press \"0\" and \"1\" to select an era. In other cases,\n    // the first letter is used.\n    let prefixLength = commonPrefixLength(eras.map(era => era.formatted));\n    if (prefixLength) {\n      for (let era of eras) {\n        era.formatted = era.formatted.slice(prefixLength);\n      }\n    }\n\n    return eras;\n  }, [eraFormatter, state.calendar, segment.type]);\n\n  let onInput = (key: string) => {\n    if (state.isDisabled || state.isReadOnly) {\n      return;\n    }\n\n    let newValue = enteredKeys.current + key;\n\n    switch (segment.type) {\n      case 'dayPeriod':\n        if (startsWith(am, key)) {\n          state.setSegment('dayPeriod', 0);\n        } else if (startsWith(pm, key)) {\n          state.setSegment('dayPeriod', 12);\n        } else {\n          break;\n        }\n        focusManager.focusNext();\n        break;\n      case 'era': {\n        let matched = eras.find(e => startsWith(e.formatted, key));\n        if (matched) {\n          state.setSegment('era', matched.era);\n          focusManager.focusNext();\n        }\n        break;\n      }\n      case 'day':\n      case 'hour':\n      case 'minute':\n      case 'second':\n      case 'month':\n      case 'year': {\n        if (!parser.isValidPartialNumber(newValue)) {\n          return;\n        }\n\n        let numberValue = parser.parse(newValue);\n        let segmentValue = numberValue;\n        let allowsZero = segment.minValue === 0;\n        if (segment.type === 'hour' && state.dateFormatter.resolvedOptions().hour12) {\n          switch (state.dateFormatter.resolvedOptions().hourCycle) {\n            case 'h11':\n              if (numberValue > 11) {\n                segmentValue = parser.parse(key);\n              }\n              break;\n            case 'h12':\n              allowsZero = false;\n              if (numberValue > 12) {\n                segmentValue = parser.parse(key);\n              }\n              break;\n          }\n\n          if (segment.value !== undefined && segment.value >= 12 && numberValue > 1) {\n            numberValue += 12;\n          }\n        } else if (segment.maxValue !== undefined && numberValue > segment.maxValue) {\n          segmentValue = parser.parse(key);\n        }\n\n        if (isNaN(numberValue)) {\n          return;\n        }\n\n        let shouldSetValue = segmentValue !== 0 || allowsZero;\n        if (shouldSetValue) {\n          state.setSegment(segment.type, segmentValue);\n        }\n\n        if (segment.maxValue !== undefined && (Number(numberValue + '0') > segment.maxValue || newValue.length >= String(segment.maxValue).length)) {\n          enteredKeys.current = '';\n          if (shouldSetValue) {\n            focusManager.focusNext();\n          }\n        } else {\n          enteredKeys.current = newValue;\n        }\n        break;\n      }\n    }\n  };\n\n  let onFocus = () => {\n    enteredKeys.current = '';\n    if (ref.current) {\n      scrollIntoViewport(ref.current, {containingElement: getScrollParent(ref.current)});\n    }\n\n    // Collapse selection to start or Chrome won't fire input events.\n    let selection = window.getSelection();\n    selection?.collapse(ref.current);\n  };\n\n  let documentRef = useRef(typeof document !== 'undefined' ? document : null);\n  useEvent(documentRef, 'selectionchange', () => {\n    // Enforce that the selection is collapsed when inside a date segment.\n    // Otherwise, when tapping on a segment in Android Chrome and then entering text,\n    // composition events will be fired that break the DOM structure and crash the page.\n    let selection = window.getSelection();\n    if (selection?.anchorNode && ref.current?.contains(selection?.anchorNode)) {\n      selection.collapse(ref.current);\n    }\n  });\n\n  let compositionRef = useRef<string | null>('');\n  useEvent(ref, 'beforeinput', e => {\n    if (!ref.current) {\n      return;\n    }\n    e.preventDefault();\n\n    switch (e.inputType) {\n      case 'deleteContentBackward':\n      case 'deleteContentForward':\n        if (parser.isValidPartialNumber(segment.text) && !state.isReadOnly) {\n          backspace();\n        }\n        break;\n      case 'insertCompositionText':\n        // insertCompositionText cannot be canceled.\n        // Record the current state of the element so we can restore it in the `input` event below.\n        compositionRef.current = ref.current.textContent;\n\n        // Safari gets stuck in a composition state unless we also assign to the value here.\n        // eslint-disable-next-line no-self-assign\n        ref.current.textContent = ref.current.textContent;\n        break;\n      default:\n        if (e.data != null) {\n          onInput(e.data);\n        }\n        break;\n    }\n  });\n\n  useEvent(ref, 'input', e => {\n    let {inputType, data} = e as InputEvent;\n    switch (inputType) {\n      case 'insertCompositionText':\n        // Reset the DOM to how it was in the beforeinput event.\n        if (ref.current) {\n          ref.current.textContent = compositionRef.current;\n        }\n\n        // Android sometimes fires key presses of letters as composition events. Need to handle am/pm keys here too.\n        // Can also happen e.g. with Pinyin keyboard on iOS.\n        if (data != null && (startsWith(am, data) || startsWith(pm, data))) {\n          onInput(data);\n        }\n        break;\n    }\n  });\n\n  useLayoutEffect(() => {\n    let element = ref.current;\n    return () => {\n      // If the focused segment is removed, focus the previous one, or the next one if there was no previous one.\n      if (document.activeElement === element) {\n        let prev = focusManager.focusPrevious();\n        if (!prev) {\n          focusManager.focusNext();\n        }\n      }\n    };\n  }, [ref, focusManager]);\n\n  // spinbuttons cannot be focused with VoiceOver on iOS.\n  let touchPropOverrides = isIOS() || segment.type === 'timeZoneName' ? {\n    role: 'textbox',\n    'aria-valuemax': null,\n    'aria-valuemin': null,\n    'aria-valuetext': null,\n    'aria-valuenow': null\n  } : {};\n\n  // Only apply aria-describedby to the first segment, unless the field is invalid. This avoids it being\n  // read every time the user navigates to a new segment.\n  let firstSegment = useMemo(() => state.segments.find(s => s.isEditable), [state.segments]);\n  if (segment !== firstSegment && !state.isInvalid) {\n    ariaDescribedBy = undefined;\n  }\n\n  let id = useId();\n  let isEditable = !state.isDisabled && !state.isReadOnly && segment.isEditable;\n\n  // Prepend the label passed from the field to each segment name.\n  // This is needed because VoiceOver on iOS does not announce groups.\n  let name = segment.type === 'literal' ? '' : displayNames.of(segment.type);\n  let labelProps = useLabels({\n    'aria-label': `${name}${ariaLabel ? `, ${ariaLabel}` : ''}${ariaLabelledBy ? ', ' : ''}`,\n    'aria-labelledby': ariaLabelledBy\n  });\n\n  // Literal segments should not be visible to screen readers. We don't really need any of the above,\n  // but the rules of hooks mean hooks cannot be conditional so we have to put this condition here.\n  if (segment.type === 'literal') {\n    return {\n      segmentProps: {\n        'aria-hidden': true\n      }\n    };\n  }\n\n  let segmentStyle: CSSProperties = {caretColor: 'transparent'};\n  if (direction === 'rtl') {\n    // While the bidirectional algorithm seems to work properly on inline elements with actual values, it returns different results for placeholder strings. \n    // To ensure placeholder render in correct format, we apply the CSS equivalent of LRE (left-to-right embedding). See https://www.unicode.org/reports/tr9/#Explicit_Directional_Embeddings.\n    // However, we apply this to both placeholders and date segments with an actual value because the date segments will shift around when deleting otherwise. \n    segmentStyle.unicodeBidi = 'embed';\n    let format = options[segment.type];\n    if (format === 'numeric' || format === '2-digit') {\n      segmentStyle.direction = 'ltr';\n    }\n  }\n\n  return {\n    segmentProps: mergeProps(spinButtonProps, labelProps, {\n      id,\n      ...touchPropOverrides,\n      'aria-invalid': state.isInvalid ? 'true' : undefined,\n      'aria-describedby': ariaDescribedBy,\n      'aria-readonly': state.isReadOnly || !segment.isEditable ? 'true' : undefined,\n      'data-placeholder': segment.isPlaceholder || undefined,\n      contentEditable: isEditable,\n      suppressContentEditableWarning: isEditable,\n      spellCheck: isEditable ? 'false' : undefined,\n      autoCorrect: isEditable ? 'off' : undefined,\n      // Capitalization was changed in React 17...\n      [parseInt(React.version, 10) >= 17 ? 'enterKeyHint' : 'enterkeyhint']: isEditable ? 'next' : undefined,\n      inputMode: state.isDisabled || segment.type === 'dayPeriod' || segment.type === 'era' || !isEditable ? undefined : 'numeric',\n      tabIndex: state.isDisabled ? undefined : 0,\n      onKeyDown,\n      onFocus,\n      style: segmentStyle,\n      // Prevent pointer events from reaching useDatePickerGroup, and allow native browser behavior to focus the segment.\n      onPointerDown(e) {\n        e.stopPropagation();\n      },\n      onMouseDown(e) {\n        e.stopPropagation();\n      }\n    })\n  };\n}\n\nfunction commonPrefixLength(strings: string[]): number {\n  // Sort the strings, and compare the characters in the first and last to find the common prefix.\n  strings.sort();\n  let first = strings[0];\n  let last = strings[strings.length - 1];\n  for (let i = 0; i < first.length; i++) {\n    if (first[i] !== last[i]) {\n      return i;\n    }\n  }\n  return 0;\n}\n"],"mappings":";;;;;;;;;AAAA;;;;;;;;;;;;AAiCO,SAASA,yCAAeC,OAAoB,EAAEC,KAAqB,EAAEC,GAAkC;EAC5G,IAAIC,WAAA,GAAc,IAAAC,aAAK,EAAE;EACzB,IAAI;IAAAC,MAAA,EAACA,MAAM;IAAAC,SAAA,EAAEA;EAAS,CAAC,GAAG,IAAAC,gBAAQ;EAClC,IAAIC,YAAA,GAAe,IAAAC,yCAAc;EACjC,IAAI;IAAAC,SAAA,EAACA,SAAS;IAAAC,cAAA,EAAEA,cAAc;IAAAC,eAAA,EAAEA,eAAe;IAAAC,YAAA,EAAEA;EAAY,CAAC,GAAG,IAAAC,yCAAO,EAAEC,GAAG,CAACd,KAAA;EAE9E,IAAIe,SAAA,GAAYhB,OAAA,CAAQiB,aAAa,GAAG,KAAKjB,OAAA,CAAQkB,IAAI;EACzD,IAAIC,OAAA,GAAU,IAAAC,cAAM,EAAE,MAAMnB,KAAA,CAAMoB,aAAa,CAACC,eAAe,IAAI,CAACrB,KAAA,CAAMoB,aAAa,CAAC;EACxF,IAAIE,kBAAA,GAAqB,IAAAC,uBAAe,EAAE;IAACC,KAAA,EAAO;IAAQC,QAAA,EAAUP,OAAA,CAAQO;EAAQ;EACpF,IAAIC,iBAAA,GAAoB,IAAAH,uBAAe,EAAE;IACvCI,IAAA,EAAM;IACNC,MAAA,EAAQV,OAAA,CAAQU,MAAM;IACtBH,QAAA,EAAUP,OAAA,CAAQO;EACpB;EAEA,IAAI1B,OAAA,CAAQ8B,IAAI,KAAK,WAAW,CAAC9B,OAAA,CAAQiB,aAAa,EAAE;IACtD,IAAIc,cAAA,GAAiBR,kBAAA,CAAmBS,MAAM,CAAC/B,KAAA,CAAMgC,SAAS;IAC9DjB,SAAA,GAAYe,cAAA,KAAmBf,SAAA,GAAY,GAAGA,SAAA,aAAee,cAAA,EAAgB,GAAGA,cAAA;EAClF,OAAO,IAAI/B,OAAA,CAAQ8B,IAAI,KAAK,UAAU,CAAC9B,OAAA,CAAQiB,aAAa,EAC1DD,SAAA,GAAYW,iBAAA,CAAkBK,MAAM,CAAC/B,KAAA,CAAMgC,SAAS;EAGtD,IAAI;IAAAC,eAAA,EAACA;EAAe,CAAC,GAAG,IAAAC,oBAAY,EAAE;IACpC;IACA;IACA;IACAC,KAAA,EAAOpC,OAAA,CAAQoC,KAAK;eACpBpB,SAAA;IACAqB,QAAA,EAAUrC,OAAA,CAAQqC,QAAQ;IAC1BC,QAAA,EAAUtC,OAAA,CAAQsC,QAAQ;IAC1BC,UAAA,EAAYtC,KAAA,CAAMsC,UAAU;IAC5BC,UAAA,EAAYvC,KAAA,CAAMuC,UAAU,IAAI,CAACxC,OAAA,CAAQyC,UAAU;IACnDC,UAAA,EAAYzC,KAAA,CAAMyC,UAAU;IAC5BC,WAAA,EAAaA,CAAA;MACXxC,WAAA,CAAYyC,OAAO,GAAG;MACtB3C,KAAA,CAAM4C,SAAS,CAAC7C,OAAA,CAAQ8B,IAAI;IAC9B;IACAgB,WAAA,EAAaA,CAAA;MACX3C,WAAA,CAAYyC,OAAO,GAAG;MACtB3C,KAAA,CAAM8C,SAAS,CAAC/C,OAAA,CAAQ8B,IAAI;IAC9B;IACAkB,eAAA,EAAiBA,CAAA;MACf7C,WAAA,CAAYyC,OAAO,GAAG;MACtB3C,KAAA,CAAMgD,aAAa,CAACjD,OAAA,CAAQ8B,IAAI;IAClC;IACAoB,eAAA,EAAiBA,CAAA;MACf/C,WAAA,CAAYyC,OAAO,GAAG;MACtB3C,KAAA,CAAMkD,aAAa,CAACnD,OAAA,CAAQ8B,IAAI;IAClC;IACAsB,gBAAA,EAAkBA,CAAA;MAChBjD,WAAA,CAAYyC,OAAO,GAAG;MACtB,IAAI5C,OAAA,CAAQsC,QAAQ,KAAKe,SAAA,EACvBpD,KAAA,CAAMqD,UAAU,CAACtD,OAAA,CAAQ8B,IAAI,EAAE9B,OAAA,CAAQsC,QAAQ;IAEnD;IACAiB,gBAAA,EAAkBA,CAAA;MAChBpD,WAAA,CAAYyC,OAAO,GAAG;MACtB,IAAI5C,OAAA,CAAQqC,QAAQ,KAAKgB,SAAA,EACvBpD,KAAA,CAAMqD,UAAU,CAACtD,OAAA,CAAQ8B,IAAI,EAAE9B,OAAA,CAAQqC,QAAQ;IAEnD;EACF;EAEA,IAAImB,MAAA,GAAS,IAAApC,cAAM,EAAE,MAAM,KAAI,GAAAqC,mBAAW,EAAEpD,MAAA,EAAQ;IAACqD,qBAAA,EAAuB;EAAC,IAAI,CAACrD,MAAA,CAAO;EAEzF,IAAIsD,SAAA,GAAYA,CAAA;IACd,IAAI3D,OAAA,CAAQkB,IAAI,KAAKlB,OAAA,CAAQ4D,WAAW,EACtC/C,YAAA,CAAagD,aAAa;IAE5B,IAAIL,MAAA,CAAOM,oBAAoB,CAAC9D,OAAA,CAAQkB,IAAI,KAAK,CAACjB,KAAA,CAAMuC,UAAU,IAAI,CAACxC,OAAA,CAAQiB,aAAa,EAAE;MAC5F,IAAI8C,QAAA,GAAW/D,OAAA,CAAQkB,IAAI,CAAC8C,KAAK,CAAC,GAAG;MACrC,IAAIC,MAAA,GAAST,MAAA,CAAOU,KAAK,CAACH,QAAA;MAC1BA,QAAA,GAAWE,MAAA,KAAW,IAAI,KAAKF,QAAA;MAC/B,IAAIA,QAAA,CAASI,MAAM,KAAK,KAAKF,MAAA,KAAW,GACtChE,KAAA,CAAMmE,YAAY,CAACpE,OAAA,CAAQ8B,IAAI,OAE/B7B,KAAA,CAAMqD,UAAU,CAACtD,OAAA,CAAQ8B,IAAI,EAAEmC,MAAA;MAEjC9D,WAAA,CAAYyC,OAAO,GAAGmB,QAAA;IACxB,OAAO,IAAI/D,OAAA,CAAQ8B,IAAI,KAAK,aAC1B7B,KAAA,CAAMmE,YAAY,CAACpE,OAAA,CAAQ8B,IAAI;EAEnC;EAEA,IAAIuC,SAAA,GAAaC,CAAA;IACf;IACA;IACA,IAAIA,CAAA,CAAEC,GAAG,KAAK,QAAQ,IAAAC,YAAI,MAAMF,CAAA,CAAEG,OAAO,GAAGH,CAAA,CAAEI,OAAO,CAAD,EAClDJ,CAAA,CAAEK,cAAc;IAGlB,IAAIL,CAAA,CAAEI,OAAO,IAAIJ,CAAA,CAAEG,OAAO,IAAIH,CAAA,CAAEM,QAAQ,IAAIN,CAAA,CAAEO,MAAM,EAClD;IAGF,QAAQP,CAAA,CAAEC,GAAG;MACX,KAAK;MACL,KAAK;QACH;QACAD,CAAA,CAAEK,cAAc;QAChBL,CAAA,CAAEQ,eAAe;QACjBnB,SAAA;QACA;IAEJ;EACF;EAEA;EACA,IAAI;IAAAoB,UAAA,EAACA;EAAU,CAAC,GAAG,IAAAC,gBAAQ,EAAE;IAACC,WAAA,EAAa;EAAM;EACjD,IAAIC,aAAA,GAAgB,IAAA1D,uBAAe,EAAE;IAACI,IAAA,EAAM;IAAWC,MAAA,EAAQ;EAAI;EACnE,IAAIsD,EAAA,GAAK,IAAA/D,cAAM,EAAE;IACf,IAAIgE,IAAA,GAAO,IAAIC,IAAA;IACfD,IAAA,CAAKE,QAAQ,CAAC;IACd,OAAOJ,aAAA,CAAcK,aAAa,CAACH,IAAA,EAAMI,IAAI,CAACC,IAAA,IAAQA,IAAA,CAAK3D,IAAI,KAAK,aAAcM,KAAK;EACzF,GAAG,CAAC8C,aAAA,CAAc;EAElB,IAAIQ,EAAA,GAAK,IAAAtE,cAAM,EAAE;IACf,IAAIgE,IAAA,GAAO,IAAIC,IAAA;IACfD,IAAA,CAAKE,QAAQ,CAAC;IACd,OAAOJ,aAAA,CAAcK,aAAa,CAACH,IAAA,EAAMI,IAAI,CAACC,IAAA,IAAQA,IAAA,CAAK3D,IAAI,KAAK,aAAcM,KAAK;EACzF,GAAG,CAAC8C,aAAA,CAAc;EAElB;EACA,IAAIS,YAAA,GAAe,IAAAnE,uBAAe,EAAE;IAACoE,IAAA,EAAM;IAAWC,GAAA,EAAK;IAAUnE,QAAA,EAAU;EAAK;EACpF,IAAIoE,IAAA,GAAO,IAAA1E,cAAM,EAAE;IACjB,IAAIpB,OAAA,CAAQ8B,IAAI,KAAK,OACnB,OAAO,EAAE;IAGX,IAAIsD,IAAA,GAAO,IAAAW,iBAAS,EAAE,KAAI,GAAAC,mBAAW,EAAE,GAAG,GAAG,IAAI/F,KAAA,CAAMgG,QAAQ;IAC/D,IAAIH,IAAA,GAAO7F,KAAA,CAAMgG,QAAQ,CAACC,OAAO,GAAGC,GAAG,CAACN,GAAA;MACtC,IAAIO,OAAA,GAAUhB,IAAA,CAAKiB,GAAG,CAAC;QAACT,IAAA,EAAM;QAAGnE,KAAA,EAAO;QAAG6E,GAAA,EAAK;aAAGT;MAAG,GAAGU,MAAM,CAAC;MAChE,IAAIC,KAAA,GAAQb,YAAA,CAAaJ,aAAa,CAACa,OAAA;MACvC,IAAIK,SAAA,GAAYD,KAAA,CAAMhB,IAAI,CAACkB,CAAA,IAAKA,CAAA,CAAE5E,IAAI,KAAK,OAAQM,KAAK;MACxD,OAAO;aAACyD,GAAA;mBAAKY;MAAS;IACxB;IAEA;IACA;IACA;IACA,IAAIE,YAAA,GAAeC,wCAAA,CAAmBd,IAAA,CAAKK,GAAG,CAACN,GAAA,IAAOA,GAAA,CAAIY,SAAS;IACnE,IAAIE,YAAA,EACF,KAAK,IAAId,GAAA,IAAOC,IAAA,EACdD,GAAA,CAAIY,SAAS,GAAGZ,GAAA,CAAIY,SAAS,CAACzC,KAAK,CAAC2C,YAAA;IAIxC,OAAOb,IAAA;EACT,GAAG,CAACH,YAAA,EAAc1F,KAAA,CAAMgG,QAAQ,EAAEjG,OAAA,CAAQ8B,IAAI,CAAC;EAE/C,IAAI+E,OAAA,GAAWtC,GAAA;IACb,IAAItE,KAAA,CAAMsC,UAAU,IAAItC,KAAA,CAAMuC,UAAU,EACtC;IAGF,IAAIuB,QAAA,GAAW5D,WAAA,CAAYyC,OAAO,GAAG2B,GAAA;IAErC,QAAQvE,OAAA,CAAQ8B,IAAI;MAClB,KAAK;QACH,IAAIiD,UAAA,CAAWI,EAAA,EAAIZ,GAAA,GACjBtE,KAAA,CAAMqD,UAAU,CAAC,aAAa,QACzB,IAAIyB,UAAA,CAAWW,EAAA,EAAInB,GAAA,GACxBtE,KAAA,CAAMqD,UAAU,CAAC,aAAa,SAE9B;QAEFzC,YAAA,CAAaiG,SAAS;QACtB;MACF,KAAK;QAAO;UACV,IAAIC,OAAA,GAAUjB,IAAA,CAAKN,IAAI,CAAClB,CAAA,IAAKS,UAAA,CAAWT,CAAA,CAAEmC,SAAS,EAAElC,GAAA;UACrD,IAAIwC,OAAA,EAAS;YACX9G,KAAA,CAAMqD,UAAU,CAAC,OAAOyD,OAAA,CAAQlB,GAAG;YACnChF,YAAA,CAAaiG,SAAS;UACxB;UACA;QACF;MACA,KAAK;MACL,KAAK;MACL,KAAK;MACL,KAAK;MACL,KAAK;MACL,KAAK;QAAQ;UACX,IAAI,CAACtD,MAAA,CAAOM,oBAAoB,CAACC,QAAA,GAC/B;UAGF,IAAIiD,WAAA,GAAcxD,MAAA,CAAOU,KAAK,CAACH,QAAA;UAC/B,IAAIkD,YAAA,GAAeD,WAAA;UACnB,IAAIE,UAAA,GAAalH,OAAA,CAAQqC,QAAQ,KAAK;UACtC,IAAIrC,OAAA,CAAQ8B,IAAI,KAAK,UAAU7B,KAAA,CAAMoB,aAAa,CAACC,eAAe,GAAGO,MAAM,EAAE;YAC3E,QAAQ5B,KAAA,CAAMoB,aAAa,CAACC,eAAe,GAAG6F,SAAS;cACrD,KAAK;gBACH,IAAIH,WAAA,GAAc,IAChBC,YAAA,GAAezD,MAAA,CAAOU,KAAK,CAACK,GAAA;gBAE9B;cACF,KAAK;gBACH2C,UAAA,GAAa;gBACb,IAAIF,WAAA,GAAc,IAChBC,YAAA,GAAezD,MAAA,CAAOU,KAAK,CAACK,GAAA;gBAE9B;YACJ;YAEA,IAAIvE,OAAA,CAAQoC,KAAK,KAAKiB,SAAA,IAAarD,OAAA,CAAQoC,KAAK,IAAI,MAAM4E,WAAA,GAAc,GACtEA,WAAA,IAAe;UAEnB,OAAO,IAAIhH,OAAA,CAAQsC,QAAQ,KAAKe,SAAA,IAAa2D,WAAA,GAAchH,OAAA,CAAQsC,QAAQ,EACzE2E,YAAA,GAAezD,MAAA,CAAOU,KAAK,CAACK,GAAA;UAG9B,IAAI6C,KAAA,CAAMJ,WAAA,GACR;UAGF,IAAIK,cAAA,GAAiBJ,YAAA,KAAiB,KAAKC,UAAA;UAC3C,IAAIG,cAAA,EACFpH,KAAA,CAAMqD,UAAU,CAACtD,OAAA,CAAQ8B,IAAI,EAAEmF,YAAA;UAGjC,IAAIjH,OAAA,CAAQsC,QAAQ,KAAKe,SAAA,KAAciE,MAAA,CAAON,WAAA,GAAc,OAAOhH,OAAA,CAAQsC,QAAQ,IAAIyB,QAAA,CAASI,MAAM,IAAIoD,MAAA,CAAOvH,OAAA,CAAQsC,QAAQ,EAAE6B,MAAM,CAAD,EAAI;YAC1IhE,WAAA,CAAYyC,OAAO,GAAG;YACtB,IAAIyE,cAAA,EACFxG,YAAA,CAAaiG,SAAS;UAE1B,OACE3G,WAAA,CAAYyC,OAAO,GAAGmB,QAAA;UAExB;QACF;IACF;EACF;EAEA,IAAIyD,OAAA,GAAUA,CAAA;IACZrH,WAAA,CAAYyC,OAAO,GAAG;IACtB,IAAI1C,GAAA,CAAI0C,OAAO,EACb,IAAA6E,yBAAiB,EAAEvH,GAAA,CAAI0C,OAAO,EAAE;MAAC8E,iBAAA,EAAmB,IAAAC,sBAAc,EAAEzH,GAAA,CAAI0C,OAAO;IAAC;IAGlF;IACA,IAAIgF,SAAA,GAAYC,MAAA,CAAOC,YAAY;IACnCF,SAAA,aAAAA,SAAA,uBAAAA,SAAA,CAAWG,QAAQ,CAAC7H,GAAA,CAAI0C,OAAO;EACjC;EAEA,IAAIoF,WAAA,GAAc,IAAA5H,aAAK,EAAE,OAAO6H,QAAA,KAAa,cAAcA,QAAA,GAAW;EACtE,IAAAC,eAAO,EAAEF,WAAA,EAAa,mBAAmB;QAKVG,YAAA;IAJ7B;IACA;IACA;IACA,IAAIP,SAAA,GAAYC,MAAA,CAAOC,YAAY;IACnC,IAAI,CAAAF,SAAA,aAAAA,SAAA,uBAAAA,SAAA,CAAWQ,UAAU,OAAID,YAAA,GAAAjI,GAAA,CAAI0C,OAAO,cAAXuF,YAAA,uBAAAA,YAAA,CAAaE,QAAQ,CAACT,SAAA,aAAAA,SAAA,uBAAAA,SAAA,CAAWQ,UAAU,IACtER,SAAA,CAAUG,QAAQ,CAAC7H,GAAA,CAAI0C,OAAO;EAElC;EAEA,IAAI0F,cAAA,GAAiB,IAAAlI,aAAK,EAAiB;EAC3C,IAAA8H,eAAO,EAAEhI,GAAA,EAAK,eAAeoE,CAAA;IAC3B,IAAI,CAACpE,GAAA,CAAI0C,OAAO,EACd;IAEF0B,CAAA,CAAEK,cAAc;IAEhB,QAAQL,CAAA,CAAEiE,SAAS;MACjB,KAAK;MACL,KAAK;QACH,IAAI/E,MAAA,CAAOM,oBAAoB,CAAC9D,OAAA,CAAQkB,IAAI,KAAK,CAACjB,KAAA,CAAMuC,UAAU,EAChEmB,SAAA;QAEF;MACF,KAAK;QACH;QACA;QACA2E,cAAA,CAAe1F,OAAO,GAAG1C,GAAA,CAAI0C,OAAO,CAAC4F,WAAW;QAEhD;QACA;QACAtI,GAAA,CAAI0C,OAAO,CAAC4F,WAAW,GAAGtI,GAAA,CAAI0C,OAAO,CAAC4F,WAAW;QACjD;MACF;QACE,IAAIlE,CAAA,CAAEmE,IAAI,IAAI,MACZ5B,OAAA,CAAQvC,CAAA,CAAEmE,IAAI;QAEhB;IACJ;EACF;EAEA,IAAAP,eAAO,EAAEhI,GAAA,EAAK,SAASoE,CAAA;IACrB,IAAI;MAAAiE,SAAA,EAACA,SAAS;MAAAE,IAAA,EAAEA;IAAI,CAAC,GAAGnE,CAAA;IACxB,QAAQiE,SAAA;MACN,KAAK;QACH;QACA,IAAIrI,GAAA,CAAI0C,OAAO,EACb1C,GAAA,CAAI0C,OAAO,CAAC4F,WAAW,GAAGF,cAAA,CAAe1F,OAAO;QAGlD;QACA;QACA,IAAI6F,IAAA,IAAQ,SAAS1D,UAAA,CAAWI,EAAA,EAAIsD,IAAA,KAAS1D,UAAA,CAAWW,EAAA,EAAI+C,IAAA,CAAI,GAC9D5B,OAAA,CAAQ4B,IAAA;QAEV;IACJ;EACF;EAEA,IAAAC,sBAAc,EAAE;IACd,IAAIC,OAAA,GAAUzI,GAAA,CAAI0C,OAAO;IACzB,OAAO;MACL;MACA,IAAIqF,QAAA,CAASW,aAAa,KAAKD,OAAA,EAAS;QACtC,IAAIE,IAAA,GAAOhI,YAAA,CAAagD,aAAa;QACrC,IAAI,CAACgF,IAAA,EACHhI,YAAA,CAAaiG,SAAS;MAE1B;IACF;EACF,GAAG,CAAC5G,GAAA,EAAKW,YAAA,CAAa;EAEtB;EACA,IAAIiI,kBAAA,GAAqB,IAAAC,YAAI,OAAO/I,OAAA,CAAQ8B,IAAI,KAAK,iBAAiB;IACpEkH,IAAA,EAAM;IACN,iBAAiB;IACjB,iBAAiB;IACjB,kBAAkB;IAClB,iBAAiB;EACnB,IAAI,CAAC;EAEL;EACA;EACA,IAAIC,YAAA,GAAe,IAAA7H,cAAM,EAAE,MAAMnB,KAAA,CAAMiJ,QAAQ,CAAC1D,IAAI,CAAC2D,CAAA,IAAKA,CAAA,CAAE1G,UAAU,GAAG,CAACxC,KAAA,CAAMiJ,QAAQ,CAAC;EACzF,IAAIlJ,OAAA,KAAYiJ,YAAA,IAAgB,CAAChJ,KAAA,CAAMmJ,SAAS,EAC9CxI,eAAA,GAAkByC,SAAA;EAGpB,IAAIgG,EAAA,GAAK,IAAAC,YAAI;EACb,IAAI7G,UAAA,GAAa,CAACxC,KAAA,CAAMsC,UAAU,IAAI,CAACtC,KAAA,CAAMuC,UAAU,IAAIxC,OAAA,CAAQyC,UAAU;EAE7E;EACA;EACA,IAAI8G,IAAA,GAAOvJ,OAAA,CAAQ8B,IAAI,KAAK,YAAY,KAAKtB,YAAA,CAAagJ,EAAE,CAACxJ,OAAA,CAAQ8B,IAAI;EACzE,IAAI2H,UAAA,GAAa,IAAAC,gBAAQ,EAAE;IACzB,cAAc,GAAGH,IAAA,GAAO7I,SAAA,GAAY,KAAKA,SAAA,EAAW,GAAG,KAAKC,cAAA,GAAiB,OAAO,IAAI;IACxF,mBAAmBA;EACrB;EAEA;EACA;EACA,IAAIX,OAAA,CAAQ8B,IAAI,KAAK,WACnB,OAAO;IACL6H,YAAA,EAAc;MACZ,eAAe;IACjB;EACF;EAGF,IAAIC,YAAA,GAA8B;IAACC,UAAA,EAAY;EAAa;EAC5D,IAAIvJ,SAAA,KAAc,OAAO;IACvB;IACA;IACA;IACAsJ,YAAA,CAAaE,WAAW,GAAG;IAC3B,IAAI9H,MAAA,GAASb,OAAO,CAACnB,OAAA,CAAQ8B,IAAI,CAAC;IAClC,IAAIE,MAAA,KAAW,aAAaA,MAAA,KAAW,WACrC4H,YAAA,CAAatJ,SAAS,GAAG;EAE7B;EAEA,OAAO;IACLqJ,YAAA,EAAc,IAAAI,iBAAS,EAAE7H,eAAA,EAAiBuH,UAAA,EAAY;UACpDJ,EAAA;MACA,GAAGP,kBAAkB;MACrB,gBAAgB7I,KAAA,CAAMmJ,SAAS,GAAG,SAAS/F,SAAA;MAC3C,oBAAoBzC,eAAA;MACpB,iBAAiBX,KAAA,CAAMuC,UAAU,IAAI,CAACxC,OAAA,CAAQyC,UAAU,GAAG,SAASY,SAAA;MACpE,oBAAoBrD,OAAA,CAAQiB,aAAa,IAAIoC,SAAA;MAC7C2G,eAAA,EAAiBvH,UAAA;MACjBwH,8BAAA,EAAgCxH,UAAA;MAChCyH,UAAA,EAAYzH,UAAA,GAAa,UAAUY,SAAA;MACnC8G,WAAA,EAAa1H,UAAA,GAAa,QAAQY,SAAA;MAClC;MACA,CAAC+G,QAAA,CAAS,IAAAC,YAAI,EAAEC,OAAO,EAAE,OAAO,KAAK,iBAAiB,iBAAiB7H,UAAA,GAAa,SAASY,SAAA;MAC7FkH,SAAA,EAAWtK,KAAA,CAAMsC,UAAU,IAAIvC,OAAA,CAAQ8B,IAAI,KAAK,eAAe9B,OAAA,CAAQ8B,IAAI,KAAK,SAAS,CAACW,UAAA,GAAaY,SAAA,GAAY;MACnHmH,QAAA,EAAUvK,KAAA,CAAMsC,UAAU,GAAGc,SAAA,GAAY;iBACzCgB,SAAA;eACAmD,OAAA;MACAiD,KAAA,EAAOb,YAAA;MACP;MACAc,cAAcpG,CAAC;QACbA,CAAA,CAAEQ,eAAe;MACnB;MACA6F,YAAYrG,CAAC;QACXA,CAAA,CAAEQ,eAAe;MACnB;IACF;EACF;AACF;AAEA,SAAS8B,yCAAmBgE,OAAiB;EAC3C;EACAA,OAAA,CAAQC,IAAI;EACZ,IAAIC,KAAA,GAAQF,OAAO,CAAC,EAAE;EACtB,IAAIG,IAAA,GAAOH,OAAO,CAACA,OAAA,CAAQzG,MAAM,GAAG,EAAE;EACtC,KAAK,IAAI6G,CAAA,GAAI,GAAGA,CAAA,GAAIF,KAAA,CAAM3G,MAAM,EAAE6G,CAAA,IAAK;IACrC,IAAIF,KAAK,CAACE,CAAA,CAAE,KAAKD,IAAI,CAACC,CAAA,CAAE,EACtB,OAAOA,CAAA;EAEX;EACA,OAAO;AACT","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}