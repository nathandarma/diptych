{"ast":null,"code":"import { createFocusManager as $7CEvq$createFocusManager, getFocusableTreeWalker as $7CEvq$getFocusableTreeWalker } from \"@react-aria/focus\";\nimport { mergeProps as $7CEvq$mergeProps } from \"@react-aria/utils\";\nimport { useLocale as $7CEvq$useLocale } from \"@react-aria/i18n\";\nimport { useMemo as $7CEvq$useMemo } from \"react\";\nimport { usePress as $7CEvq$usePress } from \"@react-aria/interactions\";\nfunction $3dfb0f96be0d6a08$export$4a931266a3838b86(state, ref, disableArrowNavigation) {\n  let {\n    direction: direction\n  } = (0, $7CEvq$useLocale)();\n  let focusManager = (0, $7CEvq$useMemo)(() => (0, $7CEvq$createFocusManager)(ref), [ref]);\n  // Open the popover on alt + arrow down\n  let onKeyDown = e => {\n    if (!e.currentTarget.contains(e.target)) return;\n    if (e.altKey && (e.key === 'ArrowDown' || e.key === 'ArrowUp') && 'setOpen' in state) {\n      e.preventDefault();\n      e.stopPropagation();\n      state.setOpen(true);\n    }\n    if (disableArrowNavigation) return;\n    switch (e.key) {\n      case 'ArrowLeft':\n        e.preventDefault();\n        e.stopPropagation();\n        if (direction === 'rtl') {\n          if (ref.current) {\n            let target = e.target;\n            let prev = $3dfb0f96be0d6a08$var$findNextSegment(ref.current, target.getBoundingClientRect().left, -1);\n            if (prev) prev.focus();\n          }\n        } else focusManager.focusPrevious();\n        break;\n      case 'ArrowRight':\n        e.preventDefault();\n        e.stopPropagation();\n        if (direction === 'rtl') {\n          if (ref.current) {\n            let target = e.target;\n            let next = $3dfb0f96be0d6a08$var$findNextSegment(ref.current, target.getBoundingClientRect().left, 1);\n            if (next) next.focus();\n          }\n        } else focusManager.focusNext();\n        break;\n    }\n  };\n  // Focus the first placeholder segment from the end on mouse down/touch up in the field.\n  let focusLast = () => {\n    var _window_event;\n    if (!ref.current) return;\n    // Try to find the segment prior to the element that was clicked on.\n    let target = (_window_event = window.event) === null || _window_event === void 0 ? void 0 : _window_event.target;\n    let walker = (0, $7CEvq$getFocusableTreeWalker)(ref.current, {\n      tabbable: true\n    });\n    if (target) {\n      walker.currentNode = target;\n      target = walker.previousNode();\n    }\n    // If no target found, find the last element from the end.\n    if (!target) {\n      let last;\n      do {\n        last = walker.lastChild();\n        if (last) target = last;\n      } while (last);\n    }\n    // Now go backwards until we find an element that is not a placeholder.\n    while (target === null || target === void 0 ? void 0 : target.hasAttribute('data-placeholder')) {\n      let prev = walker.previousNode();\n      if (prev && prev.hasAttribute('data-placeholder')) target = prev;else break;\n    }\n    if (target) target.focus();\n  };\n  let {\n    pressProps: pressProps\n  } = (0, $7CEvq$usePress)({\n    preventFocusOnPress: true,\n    allowTextSelectionOnPress: true,\n    onPressStart(e) {\n      if (e.pointerType === 'mouse') focusLast();\n    },\n    onPress(e) {\n      if (e.pointerType !== 'mouse') focusLast();\n    }\n  });\n  return (0, $7CEvq$mergeProps)(pressProps, {\n    onKeyDown: onKeyDown\n  });\n}\nfunction $3dfb0f96be0d6a08$var$findNextSegment(group, fromX, direction) {\n  let walker = (0, $7CEvq$getFocusableTreeWalker)(group, {\n    tabbable: true\n  });\n  let node = walker.nextNode();\n  let closest = null;\n  let closestDistance = Infinity;\n  while (node) {\n    let x = node.getBoundingClientRect().left;\n    let distance = x - fromX;\n    let absoluteDistance = Math.abs(distance);\n    if (Math.sign(distance) === direction && absoluteDistance < closestDistance) {\n      closest = node;\n      closestDistance = absoluteDistance;\n    }\n    node = walker.nextNode();\n  }\n  return closest;\n}\nexport { $3dfb0f96be0d6a08$export$4a931266a3838b86 as useDatePickerGroup };","map":{"version":3,"names":["$3dfb0f96be0d6a08$export$4a931266a3838b86","state","ref","disableArrowNavigation","direction","$7CEvq$useLocale","focusManager","$7CEvq$useMemo","$7CEvq$createFocusManager","onKeyDown","e","currentTarget","contains","target","altKey","key","preventDefault","stopPropagation","setOpen","current","prev","$3dfb0f96be0d6a08$var$findNextSegment","getBoundingClientRect","left","focus","focusPrevious","next","focusNext","focusLast","_window_event","window","event","walker","$7CEvq$getFocusableTreeWalker","tabbable","currentNode","previousNode","last","lastChild","hasAttribute","pressProps","$7CEvq$usePress","preventFocusOnPress","allowTextSelectionOnPress","onPressStart","pointerType","onPress","$7CEvq$mergeProps","group","fromX","node","nextNode","closest","closestDistance","Infinity","x","distance","absoluteDistance","Math","abs","sign"],"sources":["/Users/nathandarma/Documents/App Testing/Diptych/diptych/node_modules/@react-aria/datepicker/dist/packages/@react-aria/datepicker/src/useDatePickerGroup.ts"],"sourcesContent":["import {createFocusManager, getFocusableTreeWalker} from '@react-aria/focus';\nimport {DateFieldState, DatePickerState, DateRangePickerState} from '@react-stately/datepicker';\nimport {DOMAttributes, FocusableElement, KeyboardEvent, RefObject} from '@react-types/shared';\nimport {mergeProps} from '@react-aria/utils';\nimport {useLocale} from '@react-aria/i18n';\nimport {useMemo} from 'react';\nimport {usePress} from '@react-aria/interactions';\n\nexport function useDatePickerGroup(state: DatePickerState | DateRangePickerState | DateFieldState, ref: RefObject<Element | null>, disableArrowNavigation?: boolean): DOMAttributes<FocusableElement> {\n  let {direction} = useLocale();\n  let focusManager = useMemo(() => createFocusManager(ref), [ref]);\n\n  // Open the popover on alt + arrow down\n  let onKeyDown = (e: KeyboardEvent) => {\n    if (!e.currentTarget.contains(e.target)) {\n      return;\n    }\n\n    if (e.altKey && (e.key === 'ArrowDown' || e.key === 'ArrowUp') && 'setOpen' in state) {\n      e.preventDefault();\n      e.stopPropagation();\n      state.setOpen(true);\n    }\n\n    if (disableArrowNavigation) {\n      return;\n    }\n\n    switch (e.key) {\n      case 'ArrowLeft':\n        e.preventDefault();\n        e.stopPropagation();\n        if (direction === 'rtl') {\n          if (ref.current) {\n            let target = e.target as FocusableElement;\n            let prev = findNextSegment(ref.current, target.getBoundingClientRect().left, -1);\n\n            if (prev) {\n              prev.focus();\n            }\n          }\n        } else {\n          focusManager.focusPrevious();\n        }\n        break;\n      case 'ArrowRight':\n        e.preventDefault();\n        e.stopPropagation();\n        if (direction === 'rtl') {\n          if (ref.current) {\n            let target = e.target as FocusableElement;\n            let next = findNextSegment(ref.current, target.getBoundingClientRect().left, 1);\n\n            if (next) {\n              next.focus();\n            }\n          }\n        } else {\n          focusManager.focusNext();\n        }\n        break;\n    }\n  };\n\n  // Focus the first placeholder segment from the end on mouse down/touch up in the field.\n  let focusLast = () => {\n    if (!ref.current) {\n      return;\n    }\n    // Try to find the segment prior to the element that was clicked on.\n    let target = window.event?.target as FocusableElement;\n    let walker = getFocusableTreeWalker(ref.current, {tabbable: true});\n    if (target) {\n      walker.currentNode = target;\n      target = walker.previousNode() as FocusableElement;\n    }\n\n    // If no target found, find the last element from the end.\n    if (!target) {\n      let last: FocusableElement;\n      do {\n        last = walker.lastChild() as FocusableElement;\n        if (last) {\n          target = last;\n        }\n      } while (last);\n    }\n\n    // Now go backwards until we find an element that is not a placeholder.\n    while (target?.hasAttribute('data-placeholder')) {\n      let prev = walker.previousNode() as FocusableElement;\n      if (prev && prev.hasAttribute('data-placeholder')) {\n        target = prev;\n      } else {\n        break;\n      }\n    }\n\n    if (target) {\n      target.focus();\n    }\n  };\n\n  let {pressProps} = usePress({\n    preventFocusOnPress: true,\n    allowTextSelectionOnPress: true,\n    onPressStart(e) {\n      if (e.pointerType === 'mouse') {\n        focusLast();\n      }\n    },\n    onPress(e) {\n      if (e.pointerType !== 'mouse') {\n        focusLast();\n      }\n    }\n  });\n\n  return mergeProps(pressProps, {onKeyDown});\n}\n\nfunction findNextSegment(group: Element, fromX: number, direction: number) {\n  let walker = getFocusableTreeWalker(group, {tabbable: true});\n  let node = walker.nextNode();\n  let closest: FocusableElement | null = null;\n  let closestDistance = Infinity;\n  while (node) {\n    let x = (node as Element).getBoundingClientRect().left;\n    let distance = x - fromX;\n    let absoluteDistance = Math.abs(distance);\n    if (Math.sign(distance) === direction && absoluteDistance < closestDistance) {\n      closest = node as FocusableElement;\n      closestDistance = absoluteDistance;\n    }\n    node = walker.nextNode();\n  }\n  return closest;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}