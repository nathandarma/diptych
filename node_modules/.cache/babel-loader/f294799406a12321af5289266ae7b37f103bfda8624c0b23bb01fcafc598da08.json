{"ast":null,"code":"import { getEraFormat as $a074e1e2d0f0a665$export$134cbb7fb09a9522, hookData as $a074e1e2d0f0a665$export$653eddfc964b0f8a } from \"./utils.mjs\";\nimport $dm6hl$intlStringsmodulejs from \"./intlStrings.mjs\";\nimport { isSameDay as $dm6hl$isSameDay, isEqualDay as $dm6hl$isEqualDay, isToday as $dm6hl$isToday } from \"@internationalized/date\";\nimport { useDeepMemo as $dm6hl$useDeepMemo, useDescription as $dm6hl$useDescription, focusWithoutScrolling as $dm6hl$focusWithoutScrolling, scrollIntoViewport as $dm6hl$scrollIntoViewport, getScrollParent as $dm6hl$getScrollParent, mergeProps as $dm6hl$mergeProps } from \"@react-aria/utils\";\nimport { usePress as $dm6hl$usePress, getInteractionModality as $dm6hl$getInteractionModality } from \"@react-aria/interactions\";\nimport { useLocalizedStringFormatter as $dm6hl$useLocalizedStringFormatter, useDateFormatter as $dm6hl$useDateFormatter } from \"@react-aria/i18n\";\nimport { useMemo as $dm6hl$useMemo, useRef as $dm6hl$useRef, useEffect as $dm6hl$useEffect } from \"react\";\nfunction $parcel$interopDefault(a) {\n  return a && a.__esModule ? a.default : a;\n}\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nfunction $36a0ac60f04457c5$export$136073280381448e(props, state, ref) {\n  let {\n    date: date,\n    isDisabled: isDisabled\n  } = props;\n  let {\n    errorMessageId: errorMessageId,\n    selectedDateDescription: selectedDateDescription\n  } = (0, $a074e1e2d0f0a665$export$653eddfc964b0f8a).get(state);\n  let stringFormatter = (0, $dm6hl$useLocalizedStringFormatter)((0, $parcel$interopDefault($dm6hl$intlStringsmodulejs)), '@react-aria/calendar');\n  let dateFormatter = (0, $dm6hl$useDateFormatter)({\n    weekday: 'long',\n    day: 'numeric',\n    month: 'long',\n    year: 'numeric',\n    era: (0, $a074e1e2d0f0a665$export$134cbb7fb09a9522)(date),\n    timeZone: state.timeZone\n  });\n  let isSelected = state.isSelected(date);\n  let isFocused = state.isCellFocused(date);\n  isDisabled = isDisabled || state.isCellDisabled(date);\n  let isUnavailable = state.isCellUnavailable(date);\n  let isSelectable = !isDisabled && !isUnavailable;\n  let isInvalid = state.isValueInvalid && Boolean('highlightedRange' in state ? !state.anchorDate && state.highlightedRange && date.compare(state.highlightedRange.start) >= 0 && date.compare(state.highlightedRange.end) <= 0 : state.value && (0, $dm6hl$isSameDay)(state.value, date));\n  if (isInvalid) isSelected = true;\n  // For performance, reuse the same date object as before if the new date prop is the same.\n  // This allows subsequent useMemo results to be reused.\n  date = (0, $dm6hl$useDeepMemo)(date, (0, $dm6hl$isEqualDay));\n  let nativeDate = (0, $dm6hl$useMemo)(() => date.toDate(state.timeZone), [date, state.timeZone]);\n  // aria-label should be localize Day of week, Month, Day and Year without Time.\n  let isDateToday = (0, $dm6hl$isToday)(date, state.timeZone);\n  let label = (0, $dm6hl$useMemo)(() => {\n    let label = '';\n    // If this is a range calendar, add a description of the full selected range\n    // to the first and last selected date.\n    if ('highlightedRange' in state && state.value && !state.anchorDate && ((0, $dm6hl$isSameDay)(date, state.value.start) || (0, $dm6hl$isSameDay)(date, state.value.end))) label = selectedDateDescription + ', ';\n    label += dateFormatter.format(nativeDate);\n    if (isDateToday)\n      // If date is today, set appropriate string depending on selected state:\n      label = stringFormatter.format(isSelected ? 'todayDateSelected' : 'todayDate', {\n        date: label\n      });else if (isSelected)\n      // If date is selected but not today:\n      label = stringFormatter.format('dateSelected', {\n        date: label\n      });\n    if (state.minValue && (0, $dm6hl$isSameDay)(date, state.minValue)) label += ', ' + stringFormatter.format('minimumDate');else if (state.maxValue && (0, $dm6hl$isSameDay)(date, state.maxValue)) label += ', ' + stringFormatter.format('maximumDate');\n    return label;\n  }, [dateFormatter, nativeDate, stringFormatter, isSelected, isDateToday, date, state, selectedDateDescription]);\n  // When a cell is focused and this is a range calendar, add a prompt to help\n  // screenreader users know that they are in a range selection mode.\n  let rangeSelectionPrompt = '';\n  if ('anchorDate' in state && isFocused && !state.isReadOnly && isSelectable) {\n    // If selection has started add \"click to finish selecting range\"\n    if (state.anchorDate) rangeSelectionPrompt = stringFormatter.format('finishRangeSelectionPrompt');else rangeSelectionPrompt = stringFormatter.format('startRangeSelectionPrompt');\n  }\n  let descriptionProps = (0, $dm6hl$useDescription)(rangeSelectionPrompt);\n  let isAnchorPressed = (0, $dm6hl$useRef)(false);\n  let isRangeBoundaryPressed = (0, $dm6hl$useRef)(false);\n  let touchDragTimerRef = (0, $dm6hl$useRef)(undefined);\n  let {\n    pressProps: pressProps,\n    isPressed: isPressed\n  } = (0, $dm6hl$usePress)({\n    // When dragging to select a range, we don't want dragging over the original anchor\n    // again to trigger onPressStart. Cancel presses immediately when the pointer exits.\n    shouldCancelOnPointerExit: 'anchorDate' in state && !!state.anchorDate,\n    preventFocusOnPress: true,\n    isDisabled: !isSelectable || state.isReadOnly,\n    onPressStart(e) {\n      if (state.isReadOnly) {\n        state.setFocusedDate(date);\n        return;\n      }\n      if ('highlightedRange' in state && !state.anchorDate && (e.pointerType === 'mouse' || e.pointerType === 'touch')) {\n        // Allow dragging the start or end date of a range to modify it\n        // rather than starting a new selection.\n        // Don't allow dragging when invalid, or weird jumping behavior may occur as date ranges\n        // are constrained to available dates. The user will need to select a new range in this case.\n        if (state.highlightedRange && !isInvalid) {\n          if ((0, $dm6hl$isSameDay)(date, state.highlightedRange.start)) {\n            state.setAnchorDate(state.highlightedRange.end);\n            state.setFocusedDate(date);\n            state.setDragging(true);\n            isRangeBoundaryPressed.current = true;\n            return;\n          } else if ((0, $dm6hl$isSameDay)(date, state.highlightedRange.end)) {\n            state.setAnchorDate(state.highlightedRange.start);\n            state.setFocusedDate(date);\n            state.setDragging(true);\n            isRangeBoundaryPressed.current = true;\n            return;\n          }\n        }\n        let startDragging = () => {\n          state.setDragging(true);\n          touchDragTimerRef.current = undefined;\n          state.selectDate(date);\n          state.setFocusedDate(date);\n          isAnchorPressed.current = true;\n        };\n        // Start selection on mouse/touch down so users can drag to select a range.\n        // On touch, delay dragging to determine if the user really meant to scroll.\n        if (e.pointerType === 'touch') touchDragTimerRef.current = setTimeout(startDragging, 200);else startDragging();\n      }\n    },\n    onPressEnd() {\n      isRangeBoundaryPressed.current = false;\n      isAnchorPressed.current = false;\n      clearTimeout(touchDragTimerRef.current);\n      touchDragTimerRef.current = undefined;\n    },\n    onPress() {\n      // For non-range selection, always select on press up.\n      if (!('anchorDate' in state) && !state.isReadOnly) {\n        state.selectDate(date);\n        state.setFocusedDate(date);\n      }\n    },\n    onPressUp(e) {\n      if (state.isReadOnly) return;\n      // If the user tapped quickly, the date won't be selected yet and the\n      // timer will still be in progress. In this case, select the date on touch up.\n      // Timer is cleared in onPressEnd.\n      if ('anchorDate' in state && touchDragTimerRef.current) {\n        state.selectDate(date);\n        state.setFocusedDate(date);\n      }\n      if ('anchorDate' in state) {\n        if (isRangeBoundaryPressed.current)\n          // When clicking on the start or end date of an already selected range,\n          // start a new selection on press up to also allow dragging the date to\n          // change the existing range.\n          state.setAnchorDate(date);else if (state.anchorDate && !isAnchorPressed.current) {\n          // When releasing a drag or pressing the end date of a range, select it.\n          state.selectDate(date);\n          state.setFocusedDate(date);\n        } else if (e.pointerType === 'keyboard' && !state.anchorDate) {\n          // For range selection, auto-advance the focused date by one if using keyboard.\n          // This gives an indication that you're selecting a range rather than a single date.\n          // For mouse, this is unnecessary because users will see the indication on hover. For screen readers,\n          // there will be an announcement to \"click to finish selecting range\" (above).\n          state.selectDate(date);\n          let nextDay = date.add({\n            days: 1\n          });\n          if (state.isInvalid(nextDay)) nextDay = date.subtract({\n            days: 1\n          });\n          if (!state.isInvalid(nextDay)) state.setFocusedDate(nextDay);\n        } else if (e.pointerType === 'virtual') {\n          // For screen readers, just select the date on click.\n          state.selectDate(date);\n          state.setFocusedDate(date);\n        }\n      }\n    }\n  });\n  let tabIndex = undefined;\n  if (!isDisabled) tabIndex = (0, $dm6hl$isSameDay)(date, state.focusedDate) ? 0 : -1;\n  // Focus the button in the DOM when the state updates.\n  (0, $dm6hl$useEffect)(() => {\n    if (isFocused && ref.current) {\n      (0, $dm6hl$focusWithoutScrolling)(ref.current);\n      // Scroll into view if navigating with a keyboard, otherwise\n      // try not to shift the view under the user's mouse/finger.\n      // If in a overlay, scrollIntoViewport will only cause scrolling\n      // up to the overlay scroll body to prevent overlay shifting.\n      // Also only scroll into view if the cell actually got focused.\n      // There are some cases where the cell might be disabled or inside,\n      // an inert container and we don't want to scroll then.\n      if ((0, $dm6hl$getInteractionModality)() !== 'pointer' && document.activeElement === ref.current) (0, $dm6hl$scrollIntoViewport)(ref.current, {\n        containingElement: (0, $dm6hl$getScrollParent)(ref.current)\n      });\n    }\n  }, [isFocused, ref]);\n  let cellDateFormatter = (0, $dm6hl$useDateFormatter)({\n    day: 'numeric',\n    timeZone: state.timeZone,\n    calendar: date.calendar.identifier\n  });\n  let formattedDate = (0, $dm6hl$useMemo)(() => cellDateFormatter.formatToParts(nativeDate).find(part => part.type === 'day').value, [cellDateFormatter, nativeDate]);\n  return {\n    cellProps: {\n      role: 'gridcell',\n      'aria-disabled': !isSelectable || undefined,\n      'aria-selected': isSelected || undefined,\n      'aria-invalid': isInvalid || undefined\n    },\n    buttonProps: (0, $dm6hl$mergeProps)(pressProps, {\n      onFocus() {\n        if (!isDisabled) state.setFocusedDate(date);\n      },\n      tabIndex: tabIndex,\n      role: 'button',\n      'aria-disabled': !isSelectable || undefined,\n      'aria-label': label,\n      'aria-invalid': isInvalid || undefined,\n      'aria-describedby': [isInvalid ? errorMessageId : undefined, descriptionProps['aria-describedby']].filter(Boolean).join(' ') || undefined,\n      onPointerEnter(e) {\n        // Highlight the date on hover or drag over a date when selecting a range.\n        if ('highlightDate' in state && (e.pointerType !== 'touch' || state.isDragging) && isSelectable) state.highlightDate(date);\n      },\n      onPointerDown(e) {\n        // This is necessary on touch devices to allow dragging\n        // outside the original pressed element.\n        // (JSDOM does not support this)\n        if ('releasePointerCapture' in e.target) e.target.releasePointerCapture(e.pointerId);\n      },\n      onContextMenu(e) {\n        // Prevent context menu on long press.\n        e.preventDefault();\n      }\n    }),\n    isPressed: isPressed,\n    isFocused: isFocused,\n    isSelected: isSelected,\n    isDisabled: isDisabled,\n    isUnavailable: isUnavailable,\n    isOutsideVisibleRange: date.compare(state.visibleRange.start) < 0 || date.compare(state.visibleRange.end) > 0,\n    isInvalid: isInvalid,\n    formattedDate: formattedDate\n  };\n}\nexport { $36a0ac60f04457c5$export$136073280381448e as useCalendarCell };","map":{"version":3,"names":["$36a0ac60f04457c5$export$136073280381448e","props","state","ref","date","isDisabled","errorMessageId","selectedDateDescription","$a074e1e2d0f0a665$export$653eddfc964b0f8a","get","stringFormatter","$dm6hl$useLocalizedStringFormatter","$parcel$interopDefault","$dm6hl$intlStringsmodulejs","dateFormatter","$dm6hl$useDateFormatter","weekday","day","month","year","era","$a074e1e2d0f0a665$export$134cbb7fb09a9522","timeZone","isSelected","isFocused","isCellFocused","isCellDisabled","isUnavailable","isCellUnavailable","isSelectable","isInvalid","isValueInvalid","Boolean","anchorDate","highlightedRange","compare","start","end","value","$dm6hl$isSameDay","$dm6hl$useDeepMemo","$dm6hl$isEqualDay","nativeDate","$dm6hl$useMemo","toDate","isDateToday","$dm6hl$isToday","label","format","minValue","maxValue","rangeSelectionPrompt","isReadOnly","descriptionProps","$dm6hl$useDescription","isAnchorPressed","$dm6hl$useRef","isRangeBoundaryPressed","touchDragTimerRef","undefined","pressProps","isPressed","$dm6hl$usePress","shouldCancelOnPointerExit","preventFocusOnPress","onPressStart","e","setFocusedDate","pointerType","setAnchorDate","setDragging","current","startDragging","selectDate","setTimeout","onPressEnd","clearTimeout","onPress","onPressUp","nextDay","add","days","subtract","tabIndex","focusedDate","$dm6hl$useEffect","$dm6hl$focusWithoutScrolling","$dm6hl$getInteractionModality","document","activeElement","$dm6hl$scrollIntoViewport","containingElement","$dm6hl$getScrollParent","cellDateFormatter","calendar","identifier","formattedDate","formatToParts","find","part","type","cellProps","role","buttonProps","$dm6hl$mergeProps","onFocus","filter","join","onPointerEnter","isDragging","highlightDate","onPointerDown","target","releasePointerCapture","pointerId","onContextMenu","preventDefault","isOutsideVisibleRange","visibleRange"],"sources":["/Users/nathandarma/Documents/App Testing/Diptych/diptych/node_modules/@react-aria/calendar/dist/packages/@react-aria/calendar/src/useCalendarCell.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {CalendarDate, isEqualDay, isSameDay, isToday} from '@internationalized/date';\nimport {CalendarState, RangeCalendarState} from '@react-stately/calendar';\nimport {DOMAttributes, RefObject} from '@react-types/shared';\nimport {focusWithoutScrolling, getScrollParent, mergeProps, scrollIntoViewport, useDeepMemo, useDescription} from '@react-aria/utils';\nimport {getEraFormat, hookData} from './utils';\nimport {getInteractionModality, usePress} from '@react-aria/interactions';\n// @ts-ignore\nimport intlMessages from '../intl/*.json';\nimport {useDateFormatter, useLocalizedStringFormatter} from '@react-aria/i18n';\nimport {useEffect, useMemo, useRef} from 'react';\n\nexport interface AriaCalendarCellProps {\n  /** The date that this cell represents. */\n  date: CalendarDate,\n  /**\n   * Whether the cell is disabled. By default, this is determined by the\n   * Calendar's `minValue`, `maxValue`, and `isDisabled` props.\n   */\n  isDisabled?: boolean\n}\n\nexport interface CalendarCellAria {\n  /** Props for the grid cell element (e.g. `<td>`). */\n  cellProps: DOMAttributes,\n  /** Props for the button element within the cell. */\n  buttonProps: DOMAttributes,\n  /** Whether the cell is currently being pressed. */\n  isPressed: boolean,\n  /** Whether the cell is selected. */\n  isSelected: boolean,\n  /** Whether the cell is focused. */\n  isFocused: boolean,\n  /**\n   * Whether the cell is disabled, according to the calendar's `minValue`, `maxValue`, and `isDisabled` props.\n   * Disabled dates are not focusable, and cannot be selected by the user. They are typically\n   * displayed with a dimmed appearance.\n   */\n  isDisabled: boolean,\n  /**\n   * Whether the cell is unavailable, according to the calendar's `isDateUnavailable` prop. Unavailable dates remain\n   * focusable, but cannot be selected by the user. They should be displayed with a visual affordance to indicate they\n   * are unavailable, such as a different color or a strikethrough.\n   *\n   * Note that because they are focusable, unavailable dates must meet a 4.5:1 color contrast ratio,\n   * [as defined by WCAG](https://www.w3.org/WAI/WCAG21/Understanding/contrast-minimum.html).\n   */\n  isUnavailable: boolean,\n  /**\n   * Whether the cell is outside the visible range of the calendar.\n   * For example, dates before the first day of a month in the same week.\n   */\n  isOutsideVisibleRange: boolean,\n  /** Whether the cell is part of an invalid selection. */\n  isInvalid: boolean,\n  /** The day number formatted according to the current locale. */\n  formattedDate: string\n}\n\n/**\n * Provides the behavior and accessibility implementation for a calendar cell component.\n * A calendar cell displays a date cell within a calendar grid which can be selected by the user.\n */\nexport function useCalendarCell(props: AriaCalendarCellProps, state: CalendarState | RangeCalendarState, ref: RefObject<HTMLElement | null>): CalendarCellAria {\n  let {date, isDisabled} = props;\n  let {errorMessageId, selectedDateDescription} = hookData.get(state)!;\n  let stringFormatter = useLocalizedStringFormatter(intlMessages, '@react-aria/calendar');\n  let dateFormatter = useDateFormatter({\n    weekday: 'long',\n    day: 'numeric',\n    month: 'long',\n    year: 'numeric',\n    era: getEraFormat(date),\n    timeZone: state.timeZone\n  });\n  let isSelected = state.isSelected(date);\n  let isFocused = state.isCellFocused(date);\n  isDisabled = isDisabled || state.isCellDisabled(date);\n  let isUnavailable = state.isCellUnavailable(date);\n  let isSelectable = !isDisabled && !isUnavailable;\n  let isInvalid = state.isValueInvalid && Boolean(\n    'highlightedRange' in state\n      ? !state.anchorDate && state.highlightedRange && date.compare(state.highlightedRange.start) >= 0 && date.compare(state.highlightedRange.end) <= 0\n      : state.value && isSameDay(state.value, date)\n  );\n\n  if (isInvalid) {\n    isSelected = true;\n  }\n\n  // For performance, reuse the same date object as before if the new date prop is the same.\n  // This allows subsequent useMemo results to be reused.\n  date = useDeepMemo<CalendarDate>(date, isEqualDay);\n  let nativeDate = useMemo(() => date.toDate(state.timeZone), [date, state.timeZone]);\n\n  // aria-label should be localize Day of week, Month, Day and Year without Time.\n  let isDateToday = isToday(date, state.timeZone);\n  let label = useMemo(() => {\n    let label = '';\n\n    // If this is a range calendar, add a description of the full selected range\n    // to the first and last selected date.\n    if (\n      'highlightedRange' in state &&\n      state.value &&\n      !state.anchorDate &&\n      (isSameDay(date, state.value.start) || isSameDay(date, state.value.end))\n    ) {\n      label = selectedDateDescription + ', ';\n    }\n\n    label += dateFormatter.format(nativeDate);\n    if (isDateToday) {\n      // If date is today, set appropriate string depending on selected state:\n      label = stringFormatter.format(isSelected ? 'todayDateSelected' : 'todayDate', {\n        date: label\n      });\n    } else if (isSelected) {\n      // If date is selected but not today:\n      label = stringFormatter.format('dateSelected', {\n        date: label\n      });\n    }\n\n    if (state.minValue && isSameDay(date, state.minValue)) {\n      label += ', ' + stringFormatter.format('minimumDate');\n    } else if (state.maxValue && isSameDay(date, state.maxValue)) {\n      label += ', ' + stringFormatter.format('maximumDate');\n    }\n\n    return label;\n  }, [dateFormatter, nativeDate, stringFormatter, isSelected, isDateToday, date, state, selectedDateDescription]);\n\n  // When a cell is focused and this is a range calendar, add a prompt to help\n  // screenreader users know that they are in a range selection mode.\n  let rangeSelectionPrompt = '';\n  if ('anchorDate' in state && isFocused && !state.isReadOnly && isSelectable) {\n    // If selection has started add \"click to finish selecting range\"\n    if (state.anchorDate) {\n      rangeSelectionPrompt = stringFormatter.format('finishRangeSelectionPrompt');\n    // Otherwise, add \"click to start selecting range\" prompt\n    } else {\n      rangeSelectionPrompt = stringFormatter.format('startRangeSelectionPrompt');\n    }\n  }\n\n  let descriptionProps = useDescription(rangeSelectionPrompt);\n\n  let isAnchorPressed = useRef(false);\n  let isRangeBoundaryPressed = useRef(false);\n  let touchDragTimerRef = useRef<ReturnType<typeof setTimeout> | undefined>(undefined);\n  let {pressProps, isPressed} = usePress({\n    // When dragging to select a range, we don't want dragging over the original anchor\n    // again to trigger onPressStart. Cancel presses immediately when the pointer exits.\n    shouldCancelOnPointerExit: 'anchorDate' in state && !!state.anchorDate,\n    preventFocusOnPress: true,\n    isDisabled: !isSelectable || state.isReadOnly,\n    onPressStart(e) {\n      if (state.isReadOnly) {\n        state.setFocusedDate(date);\n        return;\n      }\n\n      if ('highlightedRange' in state && !state.anchorDate && (e.pointerType === 'mouse' || e.pointerType === 'touch')) {\n        // Allow dragging the start or end date of a range to modify it\n        // rather than starting a new selection.\n        // Don't allow dragging when invalid, or weird jumping behavior may occur as date ranges\n        // are constrained to available dates. The user will need to select a new range in this case.\n        if (state.highlightedRange && !isInvalid) {\n          if (isSameDay(date, state.highlightedRange.start)) {\n            state.setAnchorDate(state.highlightedRange.end);\n            state.setFocusedDate(date);\n            state.setDragging(true);\n            isRangeBoundaryPressed.current = true;\n            return;\n          } else if (isSameDay(date, state.highlightedRange.end)) {\n            state.setAnchorDate(state.highlightedRange.start);\n            state.setFocusedDate(date);\n            state.setDragging(true);\n            isRangeBoundaryPressed.current = true;\n            return;\n          }\n        }\n\n        let startDragging = () => {\n          state.setDragging(true);\n          touchDragTimerRef.current = undefined;\n\n          state.selectDate(date);\n          state.setFocusedDate(date);\n          isAnchorPressed.current = true;\n        };\n\n        // Start selection on mouse/touch down so users can drag to select a range.\n        // On touch, delay dragging to determine if the user really meant to scroll.\n        if (e.pointerType === 'touch') {\n          touchDragTimerRef.current = setTimeout(startDragging, 200);\n        } else {\n          startDragging();\n        }\n      }\n    },\n    onPressEnd() {\n      isRangeBoundaryPressed.current = false;\n      isAnchorPressed.current = false;\n      clearTimeout(touchDragTimerRef.current);\n      touchDragTimerRef.current = undefined;\n    },\n    onPress() {\n      // For non-range selection, always select on press up.\n      if (!('anchorDate' in state) && !state.isReadOnly) {\n        state.selectDate(date);\n        state.setFocusedDate(date);\n      }\n    },\n    onPressUp(e) {\n      if (state.isReadOnly) {\n        return;\n      }\n\n      // If the user tapped quickly, the date won't be selected yet and the\n      // timer will still be in progress. In this case, select the date on touch up.\n      // Timer is cleared in onPressEnd.\n      if ('anchorDate' in state && touchDragTimerRef.current) {\n        state.selectDate(date);\n        state.setFocusedDate(date);\n      }\n\n      if ('anchorDate' in state) {\n        if (isRangeBoundaryPressed.current) {\n          // When clicking on the start or end date of an already selected range,\n          // start a new selection on press up to also allow dragging the date to\n          // change the existing range.\n          state.setAnchorDate(date);\n        } else if (state.anchorDate && !isAnchorPressed.current) {\n          // When releasing a drag or pressing the end date of a range, select it.\n          state.selectDate(date);\n          state.setFocusedDate(date);\n        } else if (e.pointerType === 'keyboard' && !state.anchorDate) {\n          // For range selection, auto-advance the focused date by one if using keyboard.\n          // This gives an indication that you're selecting a range rather than a single date.\n          // For mouse, this is unnecessary because users will see the indication on hover. For screen readers,\n          // there will be an announcement to \"click to finish selecting range\" (above).\n          state.selectDate(date);\n          let nextDay = date.add({days: 1});\n          if (state.isInvalid(nextDay)) {\n            nextDay = date.subtract({days: 1});\n          }\n          if (!state.isInvalid(nextDay)) {\n            state.setFocusedDate(nextDay);\n          }\n        } else if (e.pointerType === 'virtual') {\n          // For screen readers, just select the date on click.\n          state.selectDate(date);\n          state.setFocusedDate(date);\n        }\n      }\n    }\n  });\n\n  let tabIndex: number | undefined = undefined;\n  if (!isDisabled) {\n    tabIndex = isSameDay(date, state.focusedDate) ? 0 : -1;\n  }\n\n  // Focus the button in the DOM when the state updates.\n  useEffect(() => {\n    if (isFocused && ref.current) {\n      focusWithoutScrolling(ref.current);\n\n      // Scroll into view if navigating with a keyboard, otherwise\n      // try not to shift the view under the user's mouse/finger.\n      // If in a overlay, scrollIntoViewport will only cause scrolling\n      // up to the overlay scroll body to prevent overlay shifting.\n      // Also only scroll into view if the cell actually got focused.\n      // There are some cases where the cell might be disabled or inside,\n      // an inert container and we don't want to scroll then.\n      if (getInteractionModality() !== 'pointer' && document.activeElement === ref.current) {\n        scrollIntoViewport(ref.current, {containingElement: getScrollParent(ref.current)});\n      }\n    }\n  }, [isFocused, ref]);\n\n  let cellDateFormatter = useDateFormatter({\n    day: 'numeric',\n    timeZone: state.timeZone,\n    calendar: date.calendar.identifier\n  });\n\n  let formattedDate = useMemo(() => cellDateFormatter.formatToParts(nativeDate).find(part => part.type === 'day')!.value, [cellDateFormatter, nativeDate]);\n\n  return {\n    cellProps: {\n      role: 'gridcell',\n      'aria-disabled': !isSelectable || undefined,\n      'aria-selected': isSelected || undefined,\n      'aria-invalid': isInvalid || undefined\n    },\n    buttonProps: mergeProps(pressProps, {\n      onFocus() {\n        if (!isDisabled) {\n          state.setFocusedDate(date);\n        }\n      },\n      tabIndex,\n      role: 'button',\n      'aria-disabled': !isSelectable || undefined,\n      'aria-label': label,\n      'aria-invalid': isInvalid || undefined,\n      'aria-describedby': [\n        isInvalid ? errorMessageId : undefined,\n        descriptionProps['aria-describedby']\n      ].filter(Boolean).join(' ') || undefined,\n      onPointerEnter(e) {\n        // Highlight the date on hover or drag over a date when selecting a range.\n        if ('highlightDate' in state && (e.pointerType !== 'touch' || state.isDragging) && isSelectable) {\n          state.highlightDate(date);\n        }\n      },\n      onPointerDown(e) {\n        // This is necessary on touch devices to allow dragging\n        // outside the original pressed element.\n        // (JSDOM does not support this)\n        if ('releasePointerCapture' in e.target) {\n          e.target.releasePointerCapture(e.pointerId);\n        }\n      },\n      onContextMenu(e) {\n        // Prevent context menu on long press.\n        e.preventDefault();\n      }\n    }),\n    isPressed,\n    isFocused,\n    isSelected,\n    isDisabled,\n    isUnavailable,\n    isOutsideVisibleRange: date.compare(state.visibleRange.start) < 0 || date.compare(state.visibleRange.end) > 0,\n    isInvalid,\n    formattedDate\n  };\n}\n"],"mappings":";;;;;;;;;;AAAA;;;;;;;;;;;;AA0EO,SAASA,0CAAgBC,KAA4B,EAAEC,KAAyC,EAAEC,GAAkC;EACzI,IAAI;IAAAC,IAAA,EAACA,IAAI;IAAAC,UAAA,EAAEA;EAAU,CAAC,GAAGJ,KAAA;EACzB,IAAI;IAAAK,cAAA,EAACA,cAAc;IAAAC,uBAAA,EAAEA;EAAuB,CAAC,GAAG,IAAAC,yCAAO,EAAEC,GAAG,CAACP,KAAA;EAC7D,IAAIQ,eAAA,GAAkB,IAAAC,kCAA0B,GAAE,GAAAC,sBAAA,CAAAC,0BAAA,CAAW,GAAG;EAChE,IAAIC,aAAA,GAAgB,IAAAC,uBAAe,EAAE;IACnCC,OAAA,EAAS;IACTC,GAAA,EAAK;IACLC,KAAA,EAAO;IACPC,IAAA,EAAM;IACNC,GAAA,EAAK,IAAAC,yCAAW,EAAEjB,IAAA;IAClBkB,QAAA,EAAUpB,KAAA,CAAMoB;EAClB;EACA,IAAIC,UAAA,GAAarB,KAAA,CAAMqB,UAAU,CAACnB,IAAA;EAClC,IAAIoB,SAAA,GAAYtB,KAAA,CAAMuB,aAAa,CAACrB,IAAA;EACpCC,UAAA,GAAaA,UAAA,IAAcH,KAAA,CAAMwB,cAAc,CAACtB,IAAA;EAChD,IAAIuB,aAAA,GAAgBzB,KAAA,CAAM0B,iBAAiB,CAACxB,IAAA;EAC5C,IAAIyB,YAAA,GAAe,CAACxB,UAAA,IAAc,CAACsB,aAAA;EACnC,IAAIG,SAAA,GAAY5B,KAAA,CAAM6B,cAAc,IAAIC,OAAA,CACtC,sBAAsB9B,KAAA,GAClB,CAACA,KAAA,CAAM+B,UAAU,IAAI/B,KAAA,CAAMgC,gBAAgB,IAAI9B,IAAA,CAAK+B,OAAO,CAACjC,KAAA,CAAMgC,gBAAgB,CAACE,KAAK,KAAK,KAAKhC,IAAA,CAAK+B,OAAO,CAACjC,KAAA,CAAMgC,gBAAgB,CAACG,GAAG,KAAK,IAC9InC,KAAA,CAAMoC,KAAK,IAAI,IAAAC,gBAAQ,EAAErC,KAAA,CAAMoC,KAAK,EAAElC,IAAA;EAG5C,IAAI0B,SAAA,EACFP,UAAA,GAAa;EAGf;EACA;EACAnB,IAAA,GAAO,IAAAoC,kBAAU,EAAgBpC,IAAA,GAAM,GAAAqC,iBAAS;EAChD,IAAIC,UAAA,GAAa,IAAAC,cAAM,EAAE,MAAMvC,IAAA,CAAKwC,MAAM,CAAC1C,KAAA,CAAMoB,QAAQ,GAAG,CAAClB,IAAA,EAAMF,KAAA,CAAMoB,QAAQ,CAAC;EAElF;EACA,IAAIuB,WAAA,GAAc,IAAAC,cAAM,EAAE1C,IAAA,EAAMF,KAAA,CAAMoB,QAAQ;EAC9C,IAAIyB,KAAA,GAAQ,IAAAJ,cAAM,EAAE;IAClB,IAAII,KAAA,GAAQ;IAEZ;IACA;IACA,IACE,sBAAsB7C,KAAA,IACtBA,KAAA,CAAMoC,KAAK,IACX,CAACpC,KAAA,CAAM+B,UAAU,KAChB,IAAAM,gBAAQ,EAAEnC,IAAA,EAAMF,KAAA,CAAMoC,KAAK,CAACF,KAAK,KAAK,IAAAG,gBAAQ,EAAEnC,IAAA,EAAMF,KAAA,CAAMoC,KAAK,CAACD,GAAG,IAEtEU,KAAA,GAAQxC,uBAAA,GAA0B;IAGpCwC,KAAA,IAASjC,aAAA,CAAckC,MAAM,CAACN,UAAA;IAC9B,IAAIG,WAAA;MACF;MACAE,KAAA,GAAQrC,eAAA,CAAgBsC,MAAM,CAACzB,UAAA,GAAa,sBAAsB,aAAa;QAC7EnB,IAAA,EAAM2C;MACR,QACK,IAAIxB,UAAA;MACT;MACAwB,KAAA,GAAQrC,eAAA,CAAgBsC,MAAM,CAAC,gBAAgB;QAC7C5C,IAAA,EAAM2C;MACR;IAGF,IAAI7C,KAAA,CAAM+C,QAAQ,IAAI,IAAAV,gBAAQ,EAAEnC,IAAA,EAAMF,KAAA,CAAM+C,QAAQ,GAClDF,KAAA,IAAS,OAAOrC,eAAA,CAAgBsC,MAAM,CAAC,oBAClC,IAAI9C,KAAA,CAAMgD,QAAQ,IAAI,IAAAX,gBAAQ,EAAEnC,IAAA,EAAMF,KAAA,CAAMgD,QAAQ,GACzDH,KAAA,IAAS,OAAOrC,eAAA,CAAgBsC,MAAM,CAAC;IAGzC,OAAOD,KAAA;EACT,GAAG,CAACjC,aAAA,EAAe4B,UAAA,EAAYhC,eAAA,EAAiBa,UAAA,EAAYsB,WAAA,EAAazC,IAAA,EAAMF,KAAA,EAAOK,uBAAA,CAAwB;EAE9G;EACA;EACA,IAAI4C,oBAAA,GAAuB;EAC3B,IAAI,gBAAgBjD,KAAA,IAASsB,SAAA,IAAa,CAACtB,KAAA,CAAMkD,UAAU,IAAIvB,YAAA;IAC7D;IACA,IAAI3B,KAAA,CAAM+B,UAAU,EAClBkB,oBAAA,GAAuBzC,eAAA,CAAgBsC,MAAM,CAAC,mCAG9CG,oBAAA,GAAuBzC,eAAA,CAAgBsC,MAAM,CAAC;;EAIlD,IAAIK,gBAAA,GAAmB,IAAAC,qBAAa,EAAEH,oBAAA;EAEtC,IAAII,eAAA,GAAkB,IAAAC,aAAK,EAAE;EAC7B,IAAIC,sBAAA,GAAyB,IAAAD,aAAK,EAAE;EACpC,IAAIE,iBAAA,GAAoB,IAAAF,aAAK,EAA6CG,SAAA;EAC1E,IAAI;IAAAC,UAAA,EAACA,UAAU;IAAAC,SAAA,EAAEA;EAAS,CAAC,GAAG,IAAAC,eAAO,EAAE;IACrC;IACA;IACAC,yBAAA,EAA2B,gBAAgB7D,KAAA,IAAS,CAAC,CAACA,KAAA,CAAM+B,UAAU;IACtE+B,mBAAA,EAAqB;IACrB3D,UAAA,EAAY,CAACwB,YAAA,IAAgB3B,KAAA,CAAMkD,UAAU;IAC7Ca,aAAaC,CAAC;MACZ,IAAIhE,KAAA,CAAMkD,UAAU,EAAE;QACpBlD,KAAA,CAAMiE,cAAc,CAAC/D,IAAA;QACrB;MACF;MAEA,IAAI,sBAAsBF,KAAA,IAAS,CAACA,KAAA,CAAM+B,UAAU,KAAKiC,CAAA,CAAEE,WAAW,KAAK,WAAWF,CAAA,CAAEE,WAAW,KAAK,OAAM,GAAI;QAChH;QACA;QACA;QACA;QACA,IAAIlE,KAAA,CAAMgC,gBAAgB,IAAI,CAACJ,SAAA,EAAW;UACxC,IAAI,IAAAS,gBAAQ,EAAEnC,IAAA,EAAMF,KAAA,CAAMgC,gBAAgB,CAACE,KAAK,GAAG;YACjDlC,KAAA,CAAMmE,aAAa,CAACnE,KAAA,CAAMgC,gBAAgB,CAACG,GAAG;YAC9CnC,KAAA,CAAMiE,cAAc,CAAC/D,IAAA;YACrBF,KAAA,CAAMoE,WAAW,CAAC;YAClBb,sBAAA,CAAuBc,OAAO,GAAG;YACjC;UACF,OAAO,IAAI,IAAAhC,gBAAQ,EAAEnC,IAAA,EAAMF,KAAA,CAAMgC,gBAAgB,CAACG,GAAG,GAAG;YACtDnC,KAAA,CAAMmE,aAAa,CAACnE,KAAA,CAAMgC,gBAAgB,CAACE,KAAK;YAChDlC,KAAA,CAAMiE,cAAc,CAAC/D,IAAA;YACrBF,KAAA,CAAMoE,WAAW,CAAC;YAClBb,sBAAA,CAAuBc,OAAO,GAAG;YACjC;UACF;QACF;QAEA,IAAIC,aAAA,GAAgBA,CAAA;UAClBtE,KAAA,CAAMoE,WAAW,CAAC;UAClBZ,iBAAA,CAAkBa,OAAO,GAAGZ,SAAA;UAE5BzD,KAAA,CAAMuE,UAAU,CAACrE,IAAA;UACjBF,KAAA,CAAMiE,cAAc,CAAC/D,IAAA;UACrBmD,eAAA,CAAgBgB,OAAO,GAAG;QAC5B;QAEA;QACA;QACA,IAAIL,CAAA,CAAEE,WAAW,KAAK,SACpBV,iBAAA,CAAkBa,OAAO,GAAGG,UAAA,CAAWF,aAAA,EAAe,UAEtDA,aAAA;MAEJ;IACF;IACAG,WAAA;MACElB,sBAAA,CAAuBc,OAAO,GAAG;MACjChB,eAAA,CAAgBgB,OAAO,GAAG;MAC1BK,YAAA,CAAalB,iBAAA,CAAkBa,OAAO;MACtCb,iBAAA,CAAkBa,OAAO,GAAGZ,SAAA;IAC9B;IACAkB,QAAA;MACE;MACA,IAAI,EAAE,gBAAgB3E,KAAI,KAAM,CAACA,KAAA,CAAMkD,UAAU,EAAE;QACjDlD,KAAA,CAAMuE,UAAU,CAACrE,IAAA;QACjBF,KAAA,CAAMiE,cAAc,CAAC/D,IAAA;MACvB;IACF;IACA0E,UAAUZ,CAAC;MACT,IAAIhE,KAAA,CAAMkD,UAAU,EAClB;MAGF;MACA;MACA;MACA,IAAI,gBAAgBlD,KAAA,IAASwD,iBAAA,CAAkBa,OAAO,EAAE;QACtDrE,KAAA,CAAMuE,UAAU,CAACrE,IAAA;QACjBF,KAAA,CAAMiE,cAAc,CAAC/D,IAAA;MACvB;MAEA,IAAI,gBAAgBF,KAAA,EAAO;QACzB,IAAIuD,sBAAA,CAAuBc,OAAO;UAChC;UACA;UACA;UACArE,KAAA,CAAMmE,aAAa,CAACjE,IAAA,OACf,IAAIF,KAAA,CAAM+B,UAAU,IAAI,CAACsB,eAAA,CAAgBgB,OAAO,EAAE;UACvD;UACArE,KAAA,CAAMuE,UAAU,CAACrE,IAAA;UACjBF,KAAA,CAAMiE,cAAc,CAAC/D,IAAA;QACvB,OAAO,IAAI8D,CAAA,CAAEE,WAAW,KAAK,cAAc,CAAClE,KAAA,CAAM+B,UAAU,EAAE;UAC5D;UACA;UACA;UACA;UACA/B,KAAA,CAAMuE,UAAU,CAACrE,IAAA;UACjB,IAAI2E,OAAA,GAAU3E,IAAA,CAAK4E,GAAG,CAAC;YAACC,IAAA,EAAM;UAAC;UAC/B,IAAI/E,KAAA,CAAM4B,SAAS,CAACiD,OAAA,GAClBA,OAAA,GAAU3E,IAAA,CAAK8E,QAAQ,CAAC;YAACD,IAAA,EAAM;UAAC;UAElC,IAAI,CAAC/E,KAAA,CAAM4B,SAAS,CAACiD,OAAA,GACnB7E,KAAA,CAAMiE,cAAc,CAACY,OAAA;QAEzB,OAAO,IAAIb,CAAA,CAAEE,WAAW,KAAK,WAAW;UACtC;UACAlE,KAAA,CAAMuE,UAAU,CAACrE,IAAA;UACjBF,KAAA,CAAMiE,cAAc,CAAC/D,IAAA;QACvB;MACF;IACF;EACF;EAEA,IAAI+E,QAAA,GAA+BxB,SAAA;EACnC,IAAI,CAACtD,UAAA,EACH8E,QAAA,GAAW,IAAA5C,gBAAQ,EAAEnC,IAAA,EAAMF,KAAA,CAAMkF,WAAW,IAAI,IAAI;EAGtD;EACA,IAAAC,gBAAQ,EAAE;IACR,IAAI7D,SAAA,IAAarB,GAAA,CAAIoE,OAAO,EAAE;MAC5B,IAAAe,4BAAoB,EAAEnF,GAAA,CAAIoE,OAAO;MAEjC;MACA;MACA;MACA;MACA;MACA;MACA;MACA,IAAI,IAAAgB,6BAAqB,QAAQ,aAAaC,QAAA,CAASC,aAAa,KAAKtF,GAAA,CAAIoE,OAAO,EAClF,IAAAmB,yBAAiB,EAAEvF,GAAA,CAAIoE,OAAO,EAAE;QAACoB,iBAAA,EAAmB,IAAAC,sBAAc,EAAEzF,GAAA,CAAIoE,OAAO;MAAC;IAEpF;EACF,GAAG,CAAC/C,SAAA,EAAWrB,GAAA,CAAI;EAEnB,IAAI0F,iBAAA,GAAoB,IAAA9E,uBAAe,EAAE;IACvCE,GAAA,EAAK;IACLK,QAAA,EAAUpB,KAAA,CAAMoB,QAAQ;IACxBwE,QAAA,EAAU1F,IAAA,CAAK0F,QAAQ,CAACC;EAC1B;EAEA,IAAIC,aAAA,GAAgB,IAAArD,cAAM,EAAE,MAAMkD,iBAAA,CAAkBI,aAAa,CAACvD,UAAA,EAAYwD,IAAI,CAACC,IAAA,IAAQA,IAAA,CAAKC,IAAI,KAAK,OAAQ9D,KAAK,EAAE,CAACuD,iBAAA,EAAmBnD,UAAA,CAAW;EAEvJ,OAAO;IACL2D,SAAA,EAAW;MACTC,IAAA,EAAM;MACN,iBAAiB,CAACzE,YAAA,IAAgB8B,SAAA;MAClC,iBAAiBpC,UAAA,IAAcoC,SAAA;MAC/B,gBAAgB7B,SAAA,IAAa6B;IAC/B;IACA4C,WAAA,EAAa,IAAAC,iBAAS,EAAE5C,UAAA,EAAY;MAClC6C,QAAA;QACE,IAAI,CAACpG,UAAA,EACHH,KAAA,CAAMiE,cAAc,CAAC/D,IAAA;MAEzB;gBACA+E,QAAA;MACAmB,IAAA,EAAM;MACN,iBAAiB,CAACzE,YAAA,IAAgB8B,SAAA;MAClC,cAAcZ,KAAA;MACd,gBAAgBjB,SAAA,IAAa6B,SAAA;MAC7B,oBAAoB,CAClB7B,SAAA,GAAYxB,cAAA,GAAiBqD,SAAA,EAC7BN,gBAAgB,CAAC,mBAAmB,CACrC,CAACqD,MAAM,CAAC1E,OAAA,EAAS2E,IAAI,CAAC,QAAQhD,SAAA;MAC/BiD,eAAe1C,CAAC;QACd;QACA,IAAI,mBAAmBhE,KAAA,KAAUgE,CAAA,CAAEE,WAAW,KAAK,WAAWlE,KAAA,CAAM2G,UAAU,CAAD,IAAMhF,YAAA,EACjF3B,KAAA,CAAM4G,aAAa,CAAC1G,IAAA;MAExB;MACA2G,cAAc7C,CAAC;QACb;QACA;QACA;QACA,IAAI,2BAA2BA,CAAA,CAAE8C,MAAM,EACrC9C,CAAA,CAAE8C,MAAM,CAACC,qBAAqB,CAAC/C,CAAA,CAAEgD,SAAS;MAE9C;MACAC,cAAcjD,CAAC;QACb;QACAA,CAAA,CAAEkD,cAAc;MAClB;IACF;eACAvD,SAAA;eACArC,SAAA;gBACAD,UAAA;gBACAlB,UAAA;mBACAsB,aAAA;IACA0F,qBAAA,EAAuBjH,IAAA,CAAK+B,OAAO,CAACjC,KAAA,CAAMoH,YAAY,CAAClF,KAAK,IAAI,KAAKhC,IAAA,CAAK+B,OAAO,CAACjC,KAAA,CAAMoH,YAAY,CAACjF,GAAG,IAAI;eAC5GP,SAAA;mBACAkE;EACF;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}