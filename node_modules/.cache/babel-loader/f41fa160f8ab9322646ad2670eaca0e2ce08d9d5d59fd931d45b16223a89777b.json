{"ast":null,"code":"import { getCollectionId as $feb5ffebff200149$export$6aeb1680a0ae8741, isNonContiguousSelectionModifier as $feb5ffebff200149$export$d3e3bd3e26688c04 } from \"./utils.mjs\";\nimport { focusSafely as $581M0$focusSafely, usePress as $581M0$usePress, useLongPress as $581M0$useLongPress } from \"@react-aria/interactions\";\nimport { useRouter as $581M0$useRouter, useId as $581M0$useId, isCtrlKeyPressed as $581M0$isCtrlKeyPressed, mergeProps as $581M0$mergeProps, openLink as $581M0$openLink } from \"@react-aria/utils\";\nimport { moveVirtualFocus as $581M0$moveVirtualFocus } from \"@react-aria/focus\";\nimport { useEffect as $581M0$useEffect, useRef as $581M0$useRef } from \"react\";\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nfunction $880e95eb8b93ba9a$export$ecf600387e221c37(options) {\n  let {\n    id: id,\n    selectionManager: manager,\n    key: key,\n    ref: ref,\n    shouldSelectOnPressUp: shouldSelectOnPressUp,\n    shouldUseVirtualFocus: shouldUseVirtualFocus,\n    focus: focus,\n    isDisabled: isDisabled,\n    onAction: onAction,\n    allowsDifferentPressOrigin: allowsDifferentPressOrigin,\n    linkBehavior = 'action'\n  } = options;\n  let router = (0, $581M0$useRouter)();\n  id = (0, $581M0$useId)(id);\n  let onSelect = e => {\n    if (e.pointerType === 'keyboard' && (0, $feb5ffebff200149$export$d3e3bd3e26688c04)(e)) manager.toggleSelection(key);else {\n      if (manager.selectionMode === 'none') return;\n      if (manager.isLink(key)) {\n        if (linkBehavior === 'selection' && ref.current) {\n          let itemProps = manager.getItemProps(key);\n          router.open(ref.current, e, itemProps.href, itemProps.routerOptions);\n          // Always set selected keys back to what they were so that select and combobox close.\n          manager.setSelectedKeys(manager.selectedKeys);\n          return;\n        } else if (linkBehavior === 'override' || linkBehavior === 'none') return;\n      }\n      if (manager.selectionMode === 'single') {\n        if (manager.isSelected(key) && !manager.disallowEmptySelection) manager.toggleSelection(key);else manager.replaceSelection(key);\n      } else if (e && e.shiftKey) manager.extendSelection(key);else if (manager.selectionBehavior === 'toggle' || e && ((0, $581M0$isCtrlKeyPressed)(e) || e.pointerType === 'touch' || e.pointerType === 'virtual'))\n        // if touch or virtual (VO) then we just want to toggle, otherwise it's impossible to multi select because they don't have modifier keys\n        manager.toggleSelection(key);else manager.replaceSelection(key);\n    }\n  };\n  // Focus the associated DOM node when this item becomes the focusedKey\n  // TODO: can't make this useLayoutEffect bacause it breaks menus inside dialogs\n  // However, if this is a useEffect, it runs twice and dispatches two blur events and immediately sets\n  // aria-activeDescendant in useAutocomplete... I've worked around this for now\n  (0, $581M0$useEffect)(() => {\n    let isFocused = key === manager.focusedKey;\n    if (isFocused && manager.isFocused) {\n      if (!shouldUseVirtualFocus) {\n        if (focus) focus();else if (document.activeElement !== ref.current && ref.current) (0, $581M0$focusSafely)(ref.current);\n      } else (0, $581M0$moveVirtualFocus)(ref.current);\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [ref, key, manager.focusedKey, manager.childFocusStrategy, manager.isFocused, shouldUseVirtualFocus]);\n  isDisabled = isDisabled || manager.isDisabled(key);\n  // Set tabIndex to 0 if the element is focused, or -1 otherwise so that only the last focused\n  // item is tabbable.  If using virtual focus, don't set a tabIndex at all so that VoiceOver\n  // on iOS 14 doesn't try to move real DOM focus to the item anyway.\n  let itemProps = {};\n  if (!shouldUseVirtualFocus && !isDisabled) itemProps = {\n    tabIndex: key === manager.focusedKey ? 0 : -1,\n    onFocus(e) {\n      if (e.target === ref.current) manager.setFocusedKey(key);\n    }\n  };else if (isDisabled) itemProps.onMouseDown = e => {\n    // Prevent focus going to the body when clicking on a disabled item.\n    e.preventDefault();\n  };\n  // With checkbox selection, onAction (i.e. navigation) becomes primary, and occurs on a single click of the row.\n  // Clicking the checkbox enters selection mode, after which clicking anywhere on any row toggles selection for that row.\n  // With highlight selection, onAction is secondary, and occurs on double click. Single click selects the row.\n  // With touch, onAction occurs on single tap, and long press enters selection mode.\n  let isLinkOverride = manager.isLink(key) && linkBehavior === 'override';\n  let hasLinkAction = manager.isLink(key) && linkBehavior !== 'selection' && linkBehavior !== 'none';\n  let allowsSelection = !isDisabled && manager.canSelectItem(key) && !isLinkOverride;\n  let allowsActions = (onAction || hasLinkAction) && !isDisabled;\n  let hasPrimaryAction = allowsActions && (manager.selectionBehavior === 'replace' ? !allowsSelection : !allowsSelection || manager.isEmpty);\n  let hasSecondaryAction = allowsActions && allowsSelection && manager.selectionBehavior === 'replace';\n  let hasAction = hasPrimaryAction || hasSecondaryAction;\n  let modality = (0, $581M0$useRef)(null);\n  let longPressEnabled = hasAction && allowsSelection;\n  let longPressEnabledOnPressStart = (0, $581M0$useRef)(false);\n  let hadPrimaryActionOnPressStart = (0, $581M0$useRef)(false);\n  let performAction = e => {\n    if (onAction) onAction();\n    if (hasLinkAction && ref.current) {\n      let itemProps = manager.getItemProps(key);\n      router.open(ref.current, e, itemProps.href, itemProps.routerOptions);\n    }\n  };\n  // By default, selection occurs on pointer down. This can be strange if selecting an\n  // item causes the UI to disappear immediately (e.g. menus).\n  // If shouldSelectOnPressUp is true, we use onPressUp instead of onPressStart.\n  // onPress requires a pointer down event on the same element as pointer up. For menus,\n  // we want to be able to have the pointer down on the trigger that opens the menu and\n  // the pointer up on the menu item rather than requiring a separate press.\n  // For keyboard events, selection still occurs on key down.\n  let itemPressProps = {\n    ref: ref\n  };\n  if (shouldSelectOnPressUp) {\n    itemPressProps.onPressStart = e => {\n      modality.current = e.pointerType;\n      longPressEnabledOnPressStart.current = longPressEnabled;\n      if (e.pointerType === 'keyboard' && (!hasAction || $880e95eb8b93ba9a$var$isSelectionKey())) onSelect(e);\n    };\n    // If allowsDifferentPressOrigin and interacting with mouse, make selection happen on pressUp (e.g. open menu on press down, selection on menu item happens on press up.)\n    // Otherwise, have selection happen onPress (prevents listview row selection when clicking on interactable elements in the row)\n    if (!allowsDifferentPressOrigin) itemPressProps.onPress = e => {\n      if (hasPrimaryAction || hasSecondaryAction && e.pointerType !== 'mouse') {\n        if (e.pointerType === 'keyboard' && !$880e95eb8b93ba9a$var$isActionKey()) return;\n        performAction(e);\n      } else if (e.pointerType !== 'keyboard' && allowsSelection) onSelect(e);\n    };else {\n      itemPressProps.onPressUp = hasPrimaryAction ? undefined : e => {\n        if (e.pointerType === 'mouse' && allowsSelection) onSelect(e);\n      };\n      itemPressProps.onPress = hasPrimaryAction ? performAction : e => {\n        if (e.pointerType !== 'keyboard' && e.pointerType !== 'mouse' && allowsSelection) onSelect(e);\n      };\n    }\n  } else {\n    itemPressProps.onPressStart = e => {\n      modality.current = e.pointerType;\n      longPressEnabledOnPressStart.current = longPressEnabled;\n      hadPrimaryActionOnPressStart.current = hasPrimaryAction;\n      // Select on mouse down unless there is a primary action which will occur on mouse up.\n      // For keyboard, select on key down. If there is an action, the Space key selects on key down,\n      // and the Enter key performs onAction on key up.\n      if (allowsSelection && (e.pointerType === 'mouse' && !hasPrimaryAction || e.pointerType === 'keyboard' && (!allowsActions || $880e95eb8b93ba9a$var$isSelectionKey()))) onSelect(e);\n    };\n    itemPressProps.onPress = e => {\n      // Selection occurs on touch up. Primary actions always occur on pointer up.\n      // Both primary and secondary actions occur on Enter key up. The only exception\n      // is secondary actions, which occur on double click with a mouse.\n      if (e.pointerType === 'touch' || e.pointerType === 'pen' || e.pointerType === 'virtual' || e.pointerType === 'keyboard' && hasAction && $880e95eb8b93ba9a$var$isActionKey() || e.pointerType === 'mouse' && hadPrimaryActionOnPressStart.current) {\n        if (hasAction) performAction(e);else if (allowsSelection) onSelect(e);\n      }\n    };\n  }\n  itemProps['data-collection'] = (0, $feb5ffebff200149$export$6aeb1680a0ae8741)(manager.collection);\n  itemProps['data-key'] = key;\n  itemPressProps.preventFocusOnPress = shouldUseVirtualFocus;\n  // When using virtual focus, make sure the focused key gets updated on press.\n  if (shouldUseVirtualFocus) itemPressProps = (0, $581M0$mergeProps)(itemPressProps, {\n    onPressStart(e) {\n      if (e.pointerType !== 'touch') {\n        manager.setFocused(true);\n        manager.setFocusedKey(key);\n      }\n    },\n    onPress(e) {\n      if (e.pointerType === 'touch') {\n        manager.setFocused(true);\n        manager.setFocusedKey(key);\n      }\n    }\n  });\n  let {\n    pressProps: pressProps,\n    isPressed: isPressed\n  } = (0, $581M0$usePress)(itemPressProps);\n  // Double clicking with a mouse with selectionBehavior = 'replace' performs an action.\n  let onDoubleClick = hasSecondaryAction ? e => {\n    if (modality.current === 'mouse') {\n      e.stopPropagation();\n      e.preventDefault();\n      performAction(e);\n    }\n  } : undefined;\n  // Long pressing an item with touch when selectionBehavior = 'replace' switches the selection behavior\n  // to 'toggle'. This changes the single tap behavior from performing an action (i.e. navigating) to\n  // selecting, and may toggle the appearance of a UI affordance like checkboxes on each item.\n  let {\n    longPressProps: longPressProps\n  } = (0, $581M0$useLongPress)({\n    isDisabled: !longPressEnabled,\n    onLongPress(e) {\n      if (e.pointerType === 'touch') {\n        onSelect(e);\n        manager.setSelectionBehavior('toggle');\n      }\n    }\n  });\n  // Prevent native drag and drop on long press if we also select on long press.\n  // Once the user is in selection mode, they can long press again to drag.\n  // Use a capturing listener to ensure this runs before useDrag, regardless of\n  // the order the props get merged.\n  let onDragStartCapture = e => {\n    if (modality.current === 'touch' && longPressEnabledOnPressStart.current) e.preventDefault();\n  };\n  // Prevent default on link clicks so that we control exactly\n  // when they open (to match selection behavior).\n  let onClick = manager.isLink(key) ? e => {\n    if (!(0, $581M0$openLink).isOpening) e.preventDefault();\n  } : undefined;\n  return {\n    itemProps: (0, $581M0$mergeProps)(itemProps, allowsSelection || hasPrimaryAction || shouldUseVirtualFocus && !isDisabled ? pressProps : {}, longPressEnabled ? longPressProps : {}, {\n      onDoubleClick: onDoubleClick,\n      onDragStartCapture: onDragStartCapture,\n      onClick: onClick,\n      id: id\n    },\n    // Prevent DOM focus from moving on mouse down when using virtual focus\n    shouldUseVirtualFocus ? {\n      onMouseDown: e => e.preventDefault()\n    } : undefined),\n    isPressed: isPressed,\n    isSelected: manager.isSelected(key),\n    isFocused: manager.isFocused && manager.focusedKey === key,\n    isDisabled: isDisabled,\n    allowsSelection: allowsSelection,\n    hasAction: hasAction\n  };\n}\nfunction $880e95eb8b93ba9a$var$isActionKey() {\n  let event = window.event;\n  return (event === null || event === void 0 ? void 0 : event.key) === 'Enter';\n}\nfunction $880e95eb8b93ba9a$var$isSelectionKey() {\n  let event = window.event;\n  return (event === null || event === void 0 ? void 0 : event.key) === ' ' || (event === null || event === void 0 ? void 0 : event.code) === 'Space';\n}\nexport { $880e95eb8b93ba9a$export$ecf600387e221c37 as useSelectableItem };","map":{"version":3,"names":["$880e95eb8b93ba9a$export$ecf600387e221c37","options","id","selectionManager","manager","key","ref","shouldSelectOnPressUp","shouldUseVirtualFocus","focus","isDisabled","onAction","allowsDifferentPressOrigin","linkBehavior","router","$581M0$useRouter","$581M0$useId","onSelect","e","pointerType","$feb5ffebff200149$export$d3e3bd3e26688c04","toggleSelection","selectionMode","isLink","current","itemProps","getItemProps","open","href","routerOptions","setSelectedKeys","selectedKeys","isSelected","disallowEmptySelection","replaceSelection","shiftKey","extendSelection","selectionBehavior","$581M0$isCtrlKeyPressed","$581M0$useEffect","isFocused","focusedKey","document","activeElement","$581M0$focusSafely","$581M0$moveVirtualFocus","childFocusStrategy","tabIndex","onFocus","target","setFocusedKey","onMouseDown","preventDefault","isLinkOverride","hasLinkAction","allowsSelection","canSelectItem","allowsActions","hasPrimaryAction","isEmpty","hasSecondaryAction","hasAction","modality","$581M0$useRef","longPressEnabled","longPressEnabledOnPressStart","hadPrimaryActionOnPressStart","performAction","itemPressProps","onPressStart","$880e95eb8b93ba9a$var$isSelectionKey","onPress","$880e95eb8b93ba9a$var$isActionKey","onPressUp","undefined","$feb5ffebff200149$export$6aeb1680a0ae8741","collection","preventFocusOnPress","$581M0$mergeProps","setFocused","pressProps","isPressed","$581M0$usePress","onDoubleClick","stopPropagation","longPressProps","$581M0$useLongPress","onLongPress","setSelectionBehavior","onDragStartCapture","onClick","$581M0$openLink","isOpening","event","window","code"],"sources":["/Users/nathandarma/Documents/App Testing/Diptych/diptych/node_modules/@react-aria/grid/node_modules/@react-aria/selection/dist/packages/@react-aria/selection/src/useSelectableItem.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {DOMAttributes, DOMProps, FocusableElement, Key, LongPressEvent, PointerType, PressEvent, RefObject} from '@react-types/shared';\nimport {focusSafely, PressHookProps, useLongPress, usePress} from '@react-aria/interactions';\nimport {getCollectionId, isNonContiguousSelectionModifier} from './utils';\nimport {isCtrlKeyPressed, mergeProps, openLink, useId, useRouter} from '@react-aria/utils';\nimport {moveVirtualFocus} from '@react-aria/focus';\nimport {MultipleSelectionManager} from '@react-stately/selection';\nimport {useEffect, useRef} from 'react';\n\nexport interface SelectableItemOptions extends DOMProps {\n  /**\n   * An interface for reading and updating multiple selection state.\n   */\n  selectionManager: MultipleSelectionManager,\n  /**\n   * A unique key for the item.\n   */\n  key: Key,\n  /**\n   * Ref to the item.\n   */\n  ref: RefObject<FocusableElement | null>,\n  /**\n   * By default, selection occurs on pointer down. This can be strange if selecting an\n   * item causes the UI to disappear immediately (e.g. menus).\n   */\n  shouldSelectOnPressUp?: boolean,\n  /**\n   * Whether selection requires the pointer/mouse down and up events to occur on the same target or triggers selection on\n   * the target of the pointer/mouse up event.\n   */\n  allowsDifferentPressOrigin?: boolean,\n  /**\n   * Whether the option is contained in a virtual scroller.\n   */\n  isVirtualized?: boolean,\n  /**\n   * Function to focus the item.\n   */\n  focus?: () => void,\n  /**\n   * Whether the option should use virtual focus instead of being focused directly.\n   */\n  shouldUseVirtualFocus?: boolean,\n  /** Whether the item is disabled. */\n  isDisabled?: boolean,\n  /**\n   * Handler that is called when a user performs an action on the item. The exact user event depends on\n   * the collection's `selectionBehavior` prop and the interaction modality.\n   */\n  onAction?: () => void,\n  /**\n   * The behavior of links in the collection.\n   * - 'action': link behaves like onAction.\n   * - 'selection': link follows selection interactions (e.g. if URL drives selection).\n   * - 'override': links override all other interactions (link items are not selectable).\n   * - 'none': links are disabled for both selection and actions (e.g. handled elsewhere).\n   * @default 'action'\n   */\n  linkBehavior?: 'action' | 'selection' | 'override' | 'none'\n}\n\nexport interface SelectableItemStates {\n  /** Whether the item is currently in a pressed state. */\n  isPressed: boolean,\n  /** Whether the item is currently selected. */\n  isSelected: boolean,\n  /** Whether the item is currently focused. */\n  isFocused: boolean,\n  /**\n   * Whether the item is non-interactive, i.e. both selection and actions are disabled and the item may\n   * not be focused. Dependent on `disabledKeys` and `disabledBehavior`.\n   */\n  isDisabled: boolean,\n  /**\n   * Whether the item may be selected, dependent on `selectionMode`, `disabledKeys`, and `disabledBehavior`.\n   */\n  allowsSelection: boolean,\n  /**\n   * Whether the item has an action, dependent on `onAction`, `disabledKeys`,\n   * and `disabledBehavior`. It may also change depending on the current selection state\n   * of the list (e.g. when selection is primary). This can be used to enable or disable hover\n   * styles or other visual indications of interactivity.\n   */\n  hasAction: boolean\n}\n\nexport interface SelectableItemAria extends SelectableItemStates {\n  /**\n   * Props to be spread on the item root node.\n   */\n  itemProps: DOMAttributes\n}\n\n/**\n * Handles interactions with an item in a selectable collection.\n */\nexport function useSelectableItem(options: SelectableItemOptions): SelectableItemAria {\n  let {\n    id,\n    selectionManager: manager,\n    key,\n    ref,\n    shouldSelectOnPressUp,\n    shouldUseVirtualFocus,\n    focus,\n    isDisabled,\n    onAction,\n    allowsDifferentPressOrigin,\n    linkBehavior = 'action'\n  } = options;\n  let router = useRouter();\n  id = useId(id);\n  let onSelect = (e: PressEvent | LongPressEvent | PointerEvent) => {\n    if (e.pointerType === 'keyboard' && isNonContiguousSelectionModifier(e)) {\n      manager.toggleSelection(key);\n    } else {\n      if (manager.selectionMode === 'none') {\n        return;\n      }\n\n      if (manager.isLink(key)) {\n        if (linkBehavior === 'selection' && ref.current) {\n          let itemProps = manager.getItemProps(key);\n          router.open(ref.current, e, itemProps.href, itemProps.routerOptions);\n          // Always set selected keys back to what they were so that select and combobox close.\n          manager.setSelectedKeys(manager.selectedKeys);\n          return;\n        } else if (linkBehavior === 'override' || linkBehavior === 'none') {\n          return;\n        }\n      }\n\n      if (manager.selectionMode === 'single') {\n        if (manager.isSelected(key) && !manager.disallowEmptySelection) {\n          manager.toggleSelection(key);\n        } else {\n          manager.replaceSelection(key);\n        }\n      } else if (e && e.shiftKey) {\n        manager.extendSelection(key);\n      } else if (manager.selectionBehavior === 'toggle' || (e && (isCtrlKeyPressed(e) || e.pointerType === 'touch' || e.pointerType === 'virtual'))) {\n        // if touch or virtual (VO) then we just want to toggle, otherwise it's impossible to multi select because they don't have modifier keys\n        manager.toggleSelection(key);\n      } else {\n        manager.replaceSelection(key);\n      }\n    }\n  };\n\n  // Focus the associated DOM node when this item becomes the focusedKey\n  // TODO: can't make this useLayoutEffect bacause it breaks menus inside dialogs\n  // However, if this is a useEffect, it runs twice and dispatches two blur events and immediately sets\n  // aria-activeDescendant in useAutocomplete... I've worked around this for now\n  useEffect(() => {\n    let isFocused = key === manager.focusedKey;\n    if (isFocused && manager.isFocused) {\n      if (!shouldUseVirtualFocus) {\n        if (focus) {\n          focus();\n        } else if (document.activeElement !== ref.current && ref.current) {\n          focusSafely(ref.current);\n        }\n      } else {\n        moveVirtualFocus(ref.current);\n      }\n    }\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [ref, key, manager.focusedKey, manager.childFocusStrategy, manager.isFocused, shouldUseVirtualFocus]);\n\n  isDisabled = isDisabled || manager.isDisabled(key);\n  // Set tabIndex to 0 if the element is focused, or -1 otherwise so that only the last focused\n  // item is tabbable.  If using virtual focus, don't set a tabIndex at all so that VoiceOver\n  // on iOS 14 doesn't try to move real DOM focus to the item anyway.\n  let itemProps: SelectableItemAria['itemProps'] = {};\n  if (!shouldUseVirtualFocus && !isDisabled) {\n    itemProps = {\n      tabIndex: key === manager.focusedKey ? 0 : -1,\n      onFocus(e) {\n        if (e.target === ref.current) {\n          manager.setFocusedKey(key);\n        }\n      }\n    };\n  } else if (isDisabled) {\n    itemProps.onMouseDown = (e) => {\n      // Prevent focus going to the body when clicking on a disabled item.\n      e.preventDefault();\n    };\n  }\n\n  // With checkbox selection, onAction (i.e. navigation) becomes primary, and occurs on a single click of the row.\n  // Clicking the checkbox enters selection mode, after which clicking anywhere on any row toggles selection for that row.\n  // With highlight selection, onAction is secondary, and occurs on double click. Single click selects the row.\n  // With touch, onAction occurs on single tap, and long press enters selection mode.\n  let isLinkOverride = manager.isLink(key) && linkBehavior === 'override';\n  let hasLinkAction = manager.isLink(key) && linkBehavior !== 'selection' && linkBehavior !== 'none';\n  let allowsSelection = !isDisabled && manager.canSelectItem(key) && !isLinkOverride;\n  let allowsActions = (onAction || hasLinkAction) && !isDisabled;\n  let hasPrimaryAction = allowsActions && (\n    manager.selectionBehavior === 'replace'\n      ? !allowsSelection\n      : !allowsSelection || manager.isEmpty\n  );\n  let hasSecondaryAction = allowsActions && allowsSelection && manager.selectionBehavior === 'replace';\n  let hasAction = hasPrimaryAction || hasSecondaryAction;\n  let modality = useRef<PointerType | null>(null);\n\n  let longPressEnabled = hasAction && allowsSelection;\n  let longPressEnabledOnPressStart = useRef(false);\n  let hadPrimaryActionOnPressStart = useRef(false);\n\n  let performAction = (e) => {\n    if (onAction) {\n      onAction();\n    }\n\n    if (hasLinkAction && ref.current) {\n      let itemProps = manager.getItemProps(key);\n      router.open(ref.current, e, itemProps.href, itemProps.routerOptions);\n    }\n  };\n\n  // By default, selection occurs on pointer down. This can be strange if selecting an\n  // item causes the UI to disappear immediately (e.g. menus).\n  // If shouldSelectOnPressUp is true, we use onPressUp instead of onPressStart.\n  // onPress requires a pointer down event on the same element as pointer up. For menus,\n  // we want to be able to have the pointer down on the trigger that opens the menu and\n  // the pointer up on the menu item rather than requiring a separate press.\n  // For keyboard events, selection still occurs on key down.\n  let itemPressProps: PressHookProps = {ref};\n  if (shouldSelectOnPressUp) {\n    itemPressProps.onPressStart = (e) => {\n      modality.current = e.pointerType;\n      longPressEnabledOnPressStart.current = longPressEnabled;\n      if (e.pointerType === 'keyboard' && (!hasAction || isSelectionKey())) {\n        onSelect(e);\n      }\n    };\n\n    // If allowsDifferentPressOrigin and interacting with mouse, make selection happen on pressUp (e.g. open menu on press down, selection on menu item happens on press up.)\n    // Otherwise, have selection happen onPress (prevents listview row selection when clicking on interactable elements in the row)\n    if (!allowsDifferentPressOrigin) {\n      itemPressProps.onPress = (e) => {\n        if (hasPrimaryAction || (hasSecondaryAction && e.pointerType !== 'mouse')) {\n          if (e.pointerType === 'keyboard' && !isActionKey()) {\n            return;\n          }\n\n          performAction(e);\n        } else if (e.pointerType !== 'keyboard' && allowsSelection) {\n          onSelect(e);\n        }\n      };\n    } else {\n      itemPressProps.onPressUp = hasPrimaryAction ? undefined : (e) => {\n        if (e.pointerType === 'mouse' && allowsSelection) {\n          onSelect(e);\n        }\n      };\n\n      itemPressProps.onPress = hasPrimaryAction ? performAction : (e) => {\n        if (e.pointerType !== 'keyboard' && e.pointerType !== 'mouse' && allowsSelection) {\n          onSelect(e);\n        }\n      };\n    }\n  } else {\n    itemPressProps.onPressStart = (e) => {\n      modality.current = e.pointerType;\n      longPressEnabledOnPressStart.current = longPressEnabled;\n      hadPrimaryActionOnPressStart.current = hasPrimaryAction;\n\n      // Select on mouse down unless there is a primary action which will occur on mouse up.\n      // For keyboard, select on key down. If there is an action, the Space key selects on key down,\n      // and the Enter key performs onAction on key up.\n      if (\n        allowsSelection && (\n          (e.pointerType === 'mouse' && !hasPrimaryAction) ||\n          (e.pointerType === 'keyboard' && (!allowsActions || isSelectionKey()))\n        )\n      ) {\n        onSelect(e);\n      }\n    };\n\n    itemPressProps.onPress = (e) => {\n      // Selection occurs on touch up. Primary actions always occur on pointer up.\n      // Both primary and secondary actions occur on Enter key up. The only exception\n      // is secondary actions, which occur on double click with a mouse.\n      if (\n        e.pointerType === 'touch' ||\n        e.pointerType === 'pen' ||\n        e.pointerType === 'virtual' ||\n        (e.pointerType === 'keyboard' && hasAction && isActionKey()) ||\n        (e.pointerType === 'mouse' && hadPrimaryActionOnPressStart.current)\n      ) {\n        if (hasAction) {\n          performAction(e);\n        } else if (allowsSelection) {\n          onSelect(e);\n        }\n      }\n    };\n  }\n\n  itemProps['data-collection'] = getCollectionId(manager.collection);\n  itemProps['data-key'] = key;\n  itemPressProps.preventFocusOnPress = shouldUseVirtualFocus;\n\n  // When using virtual focus, make sure the focused key gets updated on press.\n  if (shouldUseVirtualFocus) {\n    itemPressProps = mergeProps(itemPressProps, {\n      onPressStart(e) {\n        if (e.pointerType !== 'touch') {\n          manager.setFocused(true);\n          manager.setFocusedKey(key);\n        }\n      },\n      onPress(e) {\n        if (e.pointerType === 'touch') {\n          manager.setFocused(true);\n          manager.setFocusedKey(key);\n        }\n      }\n    });\n  }\n\n  let {pressProps, isPressed} = usePress(itemPressProps);\n\n  // Double clicking with a mouse with selectionBehavior = 'replace' performs an action.\n  let onDoubleClick = hasSecondaryAction ? (e) => {\n    if (modality.current === 'mouse') {\n      e.stopPropagation();\n      e.preventDefault();\n      performAction(e);\n    }\n  } : undefined;\n\n  // Long pressing an item with touch when selectionBehavior = 'replace' switches the selection behavior\n  // to 'toggle'. This changes the single tap behavior from performing an action (i.e. navigating) to\n  // selecting, and may toggle the appearance of a UI affordance like checkboxes on each item.\n  let {longPressProps} = useLongPress({\n    isDisabled: !longPressEnabled,\n    onLongPress(e) {\n      if (e.pointerType === 'touch') {\n        onSelect(e);\n        manager.setSelectionBehavior('toggle');\n      }\n    }\n  });\n\n  // Prevent native drag and drop on long press if we also select on long press.\n  // Once the user is in selection mode, they can long press again to drag.\n  // Use a capturing listener to ensure this runs before useDrag, regardless of\n  // the order the props get merged.\n  let onDragStartCapture = e => {\n    if (modality.current === 'touch' && longPressEnabledOnPressStart.current) {\n      e.preventDefault();\n    }\n  };\n\n  // Prevent default on link clicks so that we control exactly\n  // when they open (to match selection behavior).\n  let onClick = manager.isLink(key) ? e => {\n    if (!(openLink as any).isOpening) {\n      e.preventDefault();\n    }\n  } : undefined;\n\n  return {\n    itemProps: mergeProps(\n      itemProps,\n      allowsSelection || hasPrimaryAction || (shouldUseVirtualFocus && !isDisabled) ? pressProps : {},\n      longPressEnabled ? longPressProps : {},\n      {onDoubleClick, onDragStartCapture, onClick, id},\n      // Prevent DOM focus from moving on mouse down when using virtual focus\n      shouldUseVirtualFocus ? {onMouseDown: e => e.preventDefault()} : undefined\n    ),\n    isPressed,\n    isSelected: manager.isSelected(key),\n    isFocused: manager.isFocused && manager.focusedKey === key,\n    isDisabled,\n    allowsSelection,\n    hasAction\n  };\n}\n\nfunction isActionKey() {\n  let event = window.event as KeyboardEvent;\n  return event?.key === 'Enter';\n}\n\nfunction isSelectionKey() {\n  let event = window.event as KeyboardEvent;\n  return event?.key === ' ' || event?.code === 'Space';\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}